<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[跨链三部曲之：IBC]]></title>
    <url>%2F2018%2F07%2F22%2F%E8%B7%A8%E9%93%BE%E4%B8%89%E9%83%A8%E6%9B%B2%E4%B9%8B%EF%BC%9AIBC%2F</url>
    <content type="text"><![CDATA[Cosmos Network 中最令人兴奋的特色是 InterBlockchain Communication (IBC) 协议，允许不同区块链之间进行资产转移。IBC 已经实现为一个 basecoin 插件，本节我将介绍如何使用它进行不同区块链间的资产互转。 IBCIBC 的目的是让区块链彼此之间充当一个轻量级的客户端。由于我们使用经典的拜占庭一致性容错算法，在客户端上进行验证是简单可行的：只须校验最新块的签名并验证 ABCI 应用的默克尔树根。 在 Tendermint 共识引擎中，多个校验节点在处理新的区块之前会先达成一致。这意味着在下一个区块来临之前，当前区块的签名及其根状态不会加入到区块链中。每个区块包含一个 LastCommit （用于确认前一个区块的投票信息）和 AppHash（在区块头部，指处理完前一个区块的交易后的默克尔树根的 hash）。 因此，如果我们要从高度 H 验证 AppHash，我们需要高度 H+1 节点的 LastCommit 的签名（请记住：AppHash 只包含了从叶子节点到 H-1 高度节点的所有交易结果）。 不像 PoW，轻量级客户端协议不需要下载并检查所有区块链节点的头部信息，客户端总是能够直接跳跃到最新的头部，只要 validator 节点集还没有变更。如果 validator 节点集发生了变动，客户端需要跟踪这些变化，这个时候才需要从变更点开始下载所有区块点头部。这里，简单起见，我们假设这些 validator 节点集是静态不变的。 现在，让我们来演示 IBC 是如何工作的。假设我们有两条链：chain1 和 chain2，从 chain1 发送数据到 chain2，我们需要这么几个步骤: 在 chain2 上注册 chain1 的信息（chainID、genesis 配置等） 在 chain1 上，广播一条将要外发给 chain2 的 IBC 交易 广播一条交易给 chain2 告诉它 chain1 的最新状态（header和commit信息） chain1 向 chain2 发送 IBC 交易（区块高度、数据以及并默克尔证明），由于 chain2 已经知道了 chain1 的最新状态，它只需验证这个默克尔证明就可以了。 最重要的部分是： 在 chain2 上更新 chain1 的最新的状态，然后 chain1 向 chain2 发出 Merkle proof：我的数据包确实已经发出来了。 上述每一步都包含一种 IBC 交易类型，让我们 one by one 地来看一下： IBCRegisterChainTxIBCRegisterChainTx 用来注册一条链到另外一条链上。 123456type IBCRegisterChainTx struct &#123; BlockchainGenesis &#125;type BlockchainGenesis struct &#123; ChainID string Genesis string &#125; 对于给定的 chainID，该类型交易只能发送一次，重复发送将返回错误。 IBCUpdateChainTxIBCUpdateChainTx 用于在其它链上更新当前链的信息。 1234type IBCUpdateChainTx struct &#123; Header tm.Header Commit tm.Commit&#125; IBCPacketCreateTxIBCPacketCreateTx 用来创建一个将要外发给其他链的交易。 1234567891011type IBCPacketCreateTx struct &#123; Packet&#125;type Packet struct &#123; SrcChainID string DstChainID string Sequence uint64 Type string Payload []byte&#125; IBCPacketPostTxIBCPacketPostTx 用来向外发送交易到另外一条链。 12345type IBCPacketPostTx struct &#123; FromChainID string // The immediate source of the packet, not always Packet.SrcChainID FromChainHeight uint64 // The block height in which Packet was committed, to check Proof Packet Proof *merkle.IAVLProof&#125; IBC State了解完跟跨链相关的交易类型，来看看 state。每条链都会在默克尔树中存储关于 IBC 的 state，对于当前链来说，它记录的每条注册到它上面的其它链的信息包括： Genesis configuration Latest state Headers for recent heights 当然，还会记录所有它收到(ingress) 和外发(egress)的交易（packet）。 每当一笔提交 IBCUpdateChainTx 交易，这条链的会相应地更新它的 state, 每当创建一笔IBCPacketCreateTx 交易，新的 packet 数据会添加到 egress state 中，每当接收到一笔 IBCPacketPostTx 交易并验证通过了 proof 后，新的 packet 数据会添加到 ingress state 中。 Relay由于我们内部需要这些跟跨链相关的交易，以便在不同链之间以一种安全的方式来跟踪所有 proof，为了让整个流程显得流畅自然，我们可以运行一个 relay 程序来处理这些跟跨链相关的交互操作。 在本例中，只需要 2 步： basecoin relay init：每条链都在上面注册好另外一条链，并确保彼此可以发送和接收交易。 basecoin relay start：长轮询，不断地从一条链上拉取跨链交易并转发到另外一条链上。 前提是：relay 程序必须有权限读写这些链的账户及资产信息，因为发送 IBC 交易需要支付一定的 Fee。 Try it out有了前面这些知识做铺垫，现在，让我们来真实地体验下跨链交易： Preliminaries12# first, clean up any old garbage for a fresh slate...rm -rf ~/.ibcdemo/ 为了方便后续操作，先设置好一些环境变量和命令行别名： 12345678export BCHOME1_CLIENT=~/.ibcdemo/chain1/clientexport BCHOME1_SERVER=~/.ibcdemo/chain1/serverexport BCHOME2_CLIENT=~/.ibcdemo/chain2/clientexport BCHOME2_SERVER=~/.ibcdemo/chain2/serveralias basecli1="basecli --home $BCHOME1_CLIENT"alias basecli2="basecli --home $BCHOME2_CLIENT"alias basecoin1="basecoin --home $BCHOME1_SERVER"alias basecoin2="basecoin --home $BCHOME2_SERVER" 设置两条链的 chainID 12export CHAINID1="test-chain-1"export CHAINID2="test-chain-2" 由于我们是在一个机器上运行两条基于 tendermint 的区块链，我们需要给两条链设置不同的端口： 1234export PORT_PREFIX1=1234export PORT_PREFIX2=2345export RPC_PORT1=$&#123;PORT_PREFIX1&#125;7export RPC_PORT2=$&#123;PORT_PREFIX2&#125;7 Setup Chain 1创建两个 test-chain-1 链的账户: 1234basecli1 keys new moneybasecli1 keys new gotnoneexport MONEY=$(basecli1 keys get money | awk '&#123;print $2&#125;')export GOTNONE=$(basecli1 keys get gotnone | awk '&#123;print $2&#125;') 初始化这条链，它会给 $MONEY 账户打很多钱： 1basecoin1 init --chain-id $CHAINID1 $MONEY 启动 basecoin 区块链： 123sed -ie "s/4665/$PORT_PREFIX1/" $BCHOME1_SERVER/config.tomlbasecoin1 start &amp;&gt; basecoin1.log &amp; test-chain-1 跑起来了，你可以通过 tail -f basecoin1.log 实时查看它的日志。 接下来，我们将 basecli 客户端连接上 test-chain-1，验证 test-chain-1 的最新状态，下面第一个账户应该显示有钱，第二个显示没钱。 123basecli1 init --node=tcp://localhost:$&#123;RPC_PORT1&#125; --genesis=$&#123;BCHOME1_SERVER&#125;/genesis.jsonbasecli1 query account $MONEYbasecli1 query account $GOTNONE Setup Chain 2设置 test-chain-2 跟 test-chain-1 步骤类似： 1234basecli2 keys new moremoneybasecli2 keys new brokeMOREMONEY=$(basecli2 keys get moremoney | awk '&#123;print $2&#125;')BROKE=$(basecli2 keys get broke | awk '&#123;print $2&#125;') 准备创世块，启动节点： 12345basecoin2 init --chain-id $CHAINID2 $(basecli2 keys get moremoney | awk '&#123;print $2&#125;')sed -ie "s/4665/$PORT_PREFIX2/" $BCHOME2_SERVER/config.tomlbasecoin2 start &amp;&gt; basecoin2.log &amp; 我们将 basecli 客户端连接上 test-chain-2，验证 test-chain-2 的最新状态，同样，下面第一个账户应该显示有钱，第二个显示没钱。 123basecli2 init --node=tcp://localhost:$&#123;RPC_PORT2&#125; --genesis=$&#123;BCHOME2_SERVER&#125;/genesis.jsonbasecli2 query account $MOREMONEYbasecli2 query account $BROKE Connect these chainsOK，现在我们有两条独立的 basecoin 区块链在运行，让我们启动 relay 程序把它们串联起来，让它们可以彼此发送交易给对方。 relay 账户需要有余额来支付 IBC 消息，因此，我们需要先往 relay 账户充值部分钱。 12345678910# note that this key.json file is a hardcoded demo for all chains, this will# be updated in a future releaseRELAY_KEY=$BCHOME1_SERVER/key.jsonRELAY_ADDR=$(cat $RELAY_KEY | jq .address | tr -d \")basecli1 tx send --amount=100000mycoin --sequence=1 --to=$RELAY_ADDR --name=moneybasecli1 query account $RELAY_ADDRbasecli2 tx send --amount=100000mycoin --sequence=1 --to=$RELAY_ADDR --name=moremoneybasecli2 query account $RELAY_ADDR 一切准备就绪，启动 relay 程序： 12345678basecoin relay init --chain1-id=$CHAINID1 --chain2-id=$CHAINID2 \ --chain1-addr=tcp://localhost:$&#123;RPC_PORT1&#125; --chain2-addr=tcp://localhost:$&#123;RPC_PORT2&#125; \ --genesis1=$&#123;BCHOME1_SERVER&#125;/genesis.json --genesis2=$&#123;BCHOME2_SERVER&#125;/genesis.json \ --from=$RELAY_KEYbasecoin relay start --chain1-id=$CHAINID1 --chain2-id=$CHAINID2 \ --chain1-addr=tcp://localhost:$&#123;RPC_PORT1&#125; --chain2-addr=tcp://localhost:$&#123;RPC_PORT2&#125; \ --from=$RELAY_KEY &amp;&gt; relay.log &amp; Sending cross-chain payments好了，test-chain-1 和 test-chain-2 通过 IBC 协议彼此连接好，跨链中最艰巨的部分已经完成，现在，就是见证 跨链交易 奇迹的时刻： 12345678# Here's an empty account on test-chain-2basecli2 query account $BROKE# Let's send some funds from test-chain-1basecli1 tx send --amount=12345mycoin --sequence=2 --to=test-chain-2/$BROKE --name=money# give it time to arrive...sleep 2# now you should see 12345 coins!basecli2 query account $BROKE Conclusion本节我们详细阐述了 IBC 的工作机制，并演示了如何利用它在链间通信，并手把手教你进行跨链交易。其中，IBC 最核心的部分是： 在 chain2 上更新 chain1 的最新的状态，然后 chain1 向 chain2 发出 Merkle proof：我的数据包确实已经发出来了。]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>区块链，跨链，IBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨链三部曲之：Basecoin Plugin]]></title>
    <url>%2F2018%2F06%2F16%2F%E8%B7%A8%E9%93%BE%E4%B8%89%E9%83%A8%E6%9B%B2%E4%B9%8B%EF%BC%9ABasecoin%20Plugin%2F</url>
    <content type="text"><![CDATA[在前一节中，我们学习了如何使用 basecoin 启动区块链和 basecli 来发送交易，同时研究了 Account 和 SendTx 这两种基本类型。本节，我们将演示如何扩展 SendTx 以便让它支持另外一种交易类型：AppTx，这样就可以发送数据到一个自定义的插件 plugin。这里，我们来探索一个简单的 plugin：Counter。 Example Pluginbasecoin 的设计使得实现一个用户自定义插件变得十分简单，Counter 插件是和 basecoin 区块链打包在一起的，因此，如果你已经安装了 baseocin，并且运行了 make install，你应该可以直接运行 Counter 区块链节点和它的客户端 countercli，它和我们之前的 basecli 用法十分相似。 除了 --name和 --amount是必选参数，Counter 交易由其他两个参数确定：boolean 类型的 valid，和 countfee 表示某种代币类型和数量。只有当 valid 为 true 且 amount 数量大于 counterfee 时，该笔交易才是有效的。 跟之前 basecoin 区块链一样，类似的，counter 区块链也可以这样初始化： 12345678910# WARNING: this wipes out data - but counter is only for demos...rm -rf ~/.countercountercli reset_allcountercli keys new coolcountercli keys new friendcounter init $(countercli keys get cool | awk '&#123;print $2&#125;')counter start counter 的配置文件默认存放在 ~/.counter 目录，打开另一个命令行窗口， 初始化 countercli 并用 tx 的子命令 send 发送交易： 1234countercli init --node=tcp://localhost:46657 --genesis=$HOME/.counter/genesis.jsonYOU=$(countercli keys get friend | awk '&#123;print $2&#125;')countercli tx send --name=cool --amount=1000mycoin --to=$YOU --sequence=1 Counter 的 tx 还有另外一个子命令 counter，它会为这个 plugin 构造一个特殊的 AppTx： 12countercli tx counter --name cool --amount=1mycoin --sequence=2countercli tx counter --name cool --amount=1mycoin --sequence=3 --valid 第一笔交易不会被区块链接受，因为它没有指定 valid 参数，第二笔顺利发送，接下来我们可以查询这个 plugin： 1countercli query counter 可以看到，我们这个自定义插件已经可以跑通，你应该看到 Counter 值为 1 代表当前 counter 的有效交易数量，如果再发送一笔交易： 12countercli tx counter --name cool --amount=2mycoin --sequence=4 --valid --countfee=2mycoincountercli query counter 再次查询，我们将看到 Counter 值会变为 2，这一次，我们指定了 countfee=2mycoin，它没有超出 --amount=2mycoin，因此，可以通过 counter 区块链的合法性验证。 记住，和 basecli 一样，每次查询， countercli 都会验证区块链返回的 proof，保证返回结果是最新且正确的。 AppTx在实现我们自己的 plugin 之前，有必要先探究下 AppTx 和 basecoin 的 plugin 系统。 AppTx 和 SendTx 相似，不同之处在于，SendTx 是从 inputs 发送交易到 outputs，而 AppTx 是从一个 input 发送交易到一个 plugin，当然，也可以附加其他数据 Data。 1234567type AppTx struct &#123; Gas int64 `json:"gas"` Fee Coin `json:"fee"` Input TxInput `json:"input"` Name string `json:"type"` // Name of the plugin Data []byte `json:"data"` // Data for the plugin to process&#125; 通过 plugin 的方式，AppTx 可以使 Basecoin 扩展为能够处理除了转账之外的其他交易。Name字段代表某个处理特殊交易的 plugin 名字，Data 代表 plugin 要处理的数据。 Plugins一个 plugin，简单来说，它实现了 Plugin 接口中定义的方法： 1234567891011121314151617181920type Plugin interface &#123; // Name of this plugin, should be short. Name() string // Run a transaction from ABCI DeliverTx RunTx(store KVStore, ctx CallContext, txBytes []byte) (res abci.Result) // Other ABCI message handlers SetOption(store KVStore, key string, value string) (log string) InitChain(store KVStore, vals []*abci.Validator) BeginBlock(store KVStore, hash []byte, header *abci.Header) EndBlock(store KVStore, height uint64) (res abci.ResponseEndBlock)&#125;type CallContext struct &#123; CallerAddress []byte // Caller's Address (hash of PubKey) CallerAccount *Account // Caller's Account, w/ fee &amp; TxInputs deducted Coins Coins // The coins that the caller wishes to spend, excluding fees&#125; 关键在于 RunTx 方法，AppTx 中的 Data 会赋值给 txBytes，Input 则用来填充 CallContext。 注意到 RunTx 还接收一个 KVStore 类型参数 store，它抽象化了底层默克尔树对 account 数据的操作，这样 plugin 可以直接更新 Basecoin 节点里面的 account 信息，也可以存储其它信息用来来反馈区块链应用的最新状态。 通过 plugin 的方式，基于 Basecoin 的区块链应用可以得到很大扩展，甚至，可以实现类似于以太坊虚拟机那样的插件。这里 有些别人已经实现好的 plugin 例子。 Conclusion本节我们演示了如何创建一个 plugin 来扩展现有 Basecoin 实现发送用户自定义交易到区块链，下一节，我们将介绍一个用于区块链跨链通信 IBC(Inter Blockchain Communication) 的插件。]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>区块链，跨链，IBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨链三部曲之：Basecoin]]></title>
    <url>%2F2018%2F05%2F22%2F%E8%B7%A8%E9%93%BE%E4%B8%89%E9%83%A8%E6%9B%B2%E4%B9%8B%EF%BC%9ABasecoin%2F</url>
    <content type="text"><![CDATA[前面我们讲到 Basecoin 是一个基于 tendermint 的 ABCI 应用，同时它也是一个跨链应用。这节，我给大家介绍如何利用它在不同的账户之间发送交易，并试着探索下其中的技术内幕。 Install墙外的用户直接运行: 1go get -u github.com/tendermint/basecoin/cmd/... 像我们被困在墙内的用户怎么办呢，Basecoin 是用 glide 管理依赖包的，老司机都知道通过 glide miror set 来设置那些被墙包的镜像，具体请看我的另一篇 《我是如何管理goalng包的》。 安装好后，会有两个工具： basecoin 运行区块链节点 basecli 轻客户端命令行 Generate some keys首先，生成 2 组 key，一个用来接收初始分配的币，一个用来发送币。 12345678# WARNING: this will wipe out any existing info in the ~/.basecli dir# including private keys, don't run if you have lots of local state already# while we're at it let's remove the working directory for the full node toobasecli reset_allrm -rf ~/.basecoinbasecli keys new coolbasecli keys new friend 生成 key 时会提示你输入密码，生成好后，查看已有的 key 列表: 1234AllendeMacBook-Pro:~ $ basecli keys listAll keys:cool CD86946FB29D3F9666294BEAC036062F4340FD1Ffriend 851010D4FDA491244ACAAD5B0E97E71DBFD85625 你可以看到在目录下已经有 cool 和 friend 两组 key 了： 123456AllendeMacBook-Pro:~ $ ls -l ~/.basecli/keys/total 32-rw------- 1 hxz staff 140 4 26 11:44 cool.pub-rw------- 1 hxz staff 238 4 26 11:44 cool.tlc-rw------- 1 hxz staff 142 4 26 11:45 friend.pub-rw------- 1 hxz staff 240 4 26 11:45 friend.tlc Initialize Basecoin初始化 Basecoin 区块链: 1234# WARNING: this will wipe out any existing info in the ~/.basecoin dir# don't run if you have lots of local state alreadyrm -rf ~/.basecoinbasecoin init $(basecli keys get cool | awk '&#123;print $2&#125;') basecoin 会创建出运行区块链必须的文件，在 ~/.basecoin 目录下，有一个 validator（验证节点）和一个账户(cool)。 1234567AllendeMacBook-Pro:~ $ ls -l ~/.basecoin/total 32-rw-r--r-- 1 hxz staff 309 4 26 11:47 config.tomldrwx------ 2 hxz staff 64 4 26 11:47 data-rw-r--r-- 1 hxz staff 529 4 26 11:47 genesis.json-r-------- 1 hxz staff 368 4 26 11:47 key.json-r-------- 1 hxz staff 475 4 26 11:47 priv_validator.json Start准备就绪！现在，我们可以启动 Basecoin 区块链了： 1basecoin start 你可以从控制台上看到，Basecoin 会每隔一秒出一个新块。 Initialize Light-Client现在，Basecoin 区块链已经运行，我们可以初始化 basecli了，它可以发送交易给 basecoin，并查询 basecoin 区块链的状态。 打开一个新的命令行窗口： 1basecli init --node=tcp://localhost:46657 --genesis=$HOME/.basecoin/genesis.json 通过提供 genesis 配置文件给 basecli，它会解析出区块链的 chainID 和 validator 集合，basecli 需要这些信息才能通过 basecoin 区块链的密码学验证逻辑。 注意：--genesis 只有在 validator 集合没有变动的情况下才能生效，如果之前 validator 集合发生过更改，你需要通过其他方式来找到当前区块链的 validator 集合。 Send transactions现在，我们可以发送交易了。 首先，来看下我们之前创建的两个账户的资产信息： 1234ME=$(basecli keys get cool | awk '&#123;print $2&#125;')YOU=$(basecli keys get friend | awk '&#123;print $2&#125;')basecli query account $MEbasecli query account $YOU 第一个账户显示出了它的资产信息，第二个账户显示账户不存在。让我们从第一个账户发点币给第二个账户： 123456789101112131415$ basecli tx send --name=cool --amount=1000mycoin --to=$YOU --sequence=1&#123; "check_tx": &#123; "code": 0, "data": "", "log": "" &#125;, "deliver_tx": &#123; "code": 0, "data": "96905F5B71953A6C9BF20ABF05B2C614176BC0A9", "log": "" &#125;, "hash": "743D40A6EB009E18C162FA7DA98B57FBC324187E", "height": 1013&#125; 第二个账户现在有 1000 个 mycoin 了，我们可以从第二个账户发回 500 个给第一个账户： 1basecli tx send --name=friend --amount=500mycoin --to=$ME --sequence=1 如果我们发送的币超出发送者拥有的数量，毫无疑问，会报错： 1basecli tx send --name=friend --amount=500000mycoin --to=$ME --sequence=2 从上面例子都可以看出，每次发送交易时，需指定发送者名字 --name，发送币及数量 --amount，接收者名字 --to 以及本次交易的序列号 --sequence（有序递增），区块链则返回本次交易 hash，我们可以根据这个 hash 查询到本次交易在区块链上的记录。 123456789101112131415161718192021222324252627282930313233343536373839404142434445basecli query tx 743D40A6EB009E18C162FA7DA98B57FBC324187E&#123; "height": 1013, "data": &#123; "type": "send", "data": &#123; "gas": 0, "fee": &#123; "denom": "mycoin", "amount": 0 &#125;, "inputs": [ &#123; "address": "CD86946FB29D3F9666294BEAC036062F4340FD1F", "coins": [ &#123; "denom": "mycoin", "amount": 1000 &#125; ], "sequence": 1, "signature": &#123; "type": "ed25519", "data": "66EB328A0CD5AF23C7740CF833E20D3D7A424D3535528EBCDFACB39EA92FE354DDF5EBE7B04D4BB064D10AA675F561E9EC94FCB896DE830234F5E191B1815C09" &#125;, "pub_key": &#123; "type": "ed25519", "data": "DB09171E2557503457F8C4DD518A0B030089F0A967068C8F8C69EBC59CCFF0F9" &#125; &#125; ], "outputs": [ &#123; "address": "851010D4FDA491244ACAAD5B0E97E71DBFD85625", "coins": [ &#123; "denom": "mycoin", "amount": 1000 &#125; ] &#125; ] &#125; &#125;&#125; Accounts and Transactions为了更好地理解 basecli 以及 basecoin 是如何工作的，我们需要先补点跟账户、交易相关的基础知识 Accounts受以太坊的账户系统的启发，Basecoin 维护了一个账户系统，每个账户包含一个公钥、不同币种的资产信息以及一个严格递增的交易序列号。请注意：Basecoin 是一个多数字货币资产钱包，因此每个账户可以有许多种不同的 token。 123456789101112type Account struct &#123; PubKey crypto.PubKey `json:"pub_key"` // May be nil, if not known. Sequence int `json:"sequence"` Balance Coins `json:"coins"`&#125;type Coins []Cointype Coin struct &#123; Denom string `json:"denom"` Amount int64 `json:"amount"`&#125; 如果你想往区块链里添加更多的币种，只需要在区块链初始化前手动编辑 ~/.basecoin/genesis.json 。 账户被序列号保存在默克尔树中，键为 base/a/&lt;address&gt;，其中&lt;address&gt;是账户的地址。一般地，账户地址是一个 20 字节的公钥哈希（RIPEMD160算法），当然，其他格式也支持。Basecoin 中用到的默克尔树是一个平衡二叉查找树，也称 IAVL树。 TransactionsBasecoin 定义里一个简单的交易类型 SendTx，它包含一个或多个输入和输出，允许 token 从一个账户转移到其他账户。 12345678910111213141516171819type SendTx struct &#123; Gas int64 `json:"gas"` Fee Coin `json:"fee"` Inputs []TxInput `json:"inputs"` Outputs []TxOutput `json:"outputs"`&#125;type TxInput struct &#123; Address []byte `json:"address"` // Hash of the PubKey Coins Coins `json:"coins"` // Sequence int `json:"sequence"` // Must be 1 greater than the last committed TxInput Signature crypto.Signature `json:"signature"` // Depends on the PubKey type and the whole Tx PubKey crypto.PubKey `json:"pub_key"` // Is present if Sequence == 0&#125;type TxOutput struct &#123; Address []byte `json:"address"` // Hash of the PubKey Coins Coins `json:"coins"` //&#125; 注意到SendTx还包含 Gas和 Fee字段，Gas 限制了每次交易最多允许执行的计算次数，Fee 指这比交易的交易费，validator 根据交易费大小对接收到的交易进行打包排序，这有点类似于比特币中手续费概念。 和以太坊中的 Gas、GasPrice 概念稍微有点不同，以太坊中的交易费 Fee = Gas x GasPrice，在 Basecoin 中，Gas 和 Fee 是两个独立的概念。 只有在 Sequence == 0 的时候，PubKey才是必选项。之后，它会存储在默克尔树该账户对应的 key 中，后续的交易只需要引用PubKey对应的 Address就可以指定发送者了。 最后，多个输入账户和多个输出账户可以让我们在一笔交易中就实现在不同账户间多个 token 的转移，当然，你必须保证”价值守恒”(输入=输出，交易费已经在 Fee 中指定)，并且，每个输入都要有对应账户的私钥签名。 Conclusion本章介绍了 basecoin 和 basecli 两个命令行工具及其基本用法，演示了如何启动一条 basecoin 区块链，怎样在账户间发送 token，并讨论了 basecoin 中账户和交易类型，下一章，我们将介绍 Basecoin 的插件系统，实现不同插件的扩展。]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>区块链，跨链，IBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨链三部曲之：开篇]]></title>
    <url>%2F2018%2F05%2F07%2F%E8%B7%A8%E9%93%BE%E4%B8%89%E9%83%A8%E6%9B%B2%E4%B9%8B%EF%BC%9A%E5%BC%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[区块链技术发展到现在，从开山鼻祖比特币开始，涌现出了各种形形色色的链。 但，由于每个链都是独立的、垂直的封闭体系，当前的链圈只是由许多彼此割裂开来的区块链「孤岛」构成，链与链之间无法进行价值和数据的交换。 讽刺的是，声称去中心化的区块链之间的价值互换却主要依靠中心化的交易所来完成。 为了实现区块链之间的原子交易、资产转换、区块链内部信息互通，涌现了各种 跨链 技术。 但是，跨链是一个复杂的过程，它涉及到三个核心功能点： 单独验证链中信息 去中心化的输入 获取验证链外信息 《深度解析：区块链跨链技术》 和 V神：区块链跨链技术大规模应用将在一到两年内爆发 这两篇文章总结了目前主流的跨链技术： 公证人机制（Notary schemes） 侧链/中继（Sidechains/relays） 哈希锁定（Hash-locking） 分布式私钥控制（Distributed private key control） 早期跨链技术关注的是资产转移，这类代表有瑞波和 BTC Relay；现有跨链技术则侧重于跨链基础设施，典型代表有 Polkadot 和 Cosmos；新出现的 FUSION 想要做价值互联网时代的金融（即加密金融），它实现了高效率的、面向多币种和多种触发机制的增强型智能合约，可以支持丰富的的跨链金融应用。 这些跨链技术，网上都有很多理论性的分析文章，但理论归理论，“纸上得来终觉浅”，没有一个实际的例子，总感觉领会得不够透彻。 这个系列，我将由浅入深地给大家介绍一个基于 Cosmos 生态的跨链例子：Basecoin。但是，先别急，在此之前，你得补习下跟 Basecoin 相关的背景知识。 为了研究一个点，你需要搞清楚它的来龙去脉，因果背景……没有前面这些知识的铺垫，我估计没人知道我在说什么。 首先，有必要先了解下 Cosmos。《前沿跨链技术Cosmos简介》 这篇文章介绍了 Cosmos 的前世今生，对于初学者来说是很好的科普资料。这里，我略作总结： Cosmos 是跨链开源项目，它的目标是建立区块链的“互联网”，在多链多币的世界里，通过跨链代币转移技术构造一个深度集成的代币经济生态系统。 Cosmos 的底层是 Tendermint，它包含两个核心组件：一个区块链共识引擎（Tendermint Core）和一个通用的应用程序接口（ABCI）。 共识引擎采用了 PBFT 共识算法，通过一个基于弱同步的假设的两轮投票机制，最多可以容忍 1/3 的拜占庭节点（可简单理解为“异常节点”和“作恶节点”），它也是确定性一致算法，区块链保证永不分叉，共识效率比较高，秒级出快，TPS 可达到上千。 Tendermint 通过提供一个非常简单的 ABCI 接口，将区块链底层复杂的共识逻辑和应用程序逻辑分离开来。举个大家比较熟悉的例子，比特币。比特币是一个加密货币区块链，每个节点维护了一份完整的 UTXO 数据库。如果有人想基于 Tendermint 创建一个类似比特币的 ABCI 应用，Tendermint Core 将会负责： 在节点间广播区块和交易 维护区块链的不可变性 而 ABCI 应用程序将会负责： 维护 UTXO 数据库 验证交易的加密签名 阻止花费尚未存在的交易 允许客户端查询 UTXO 数据库 ABCI 应用的合约可以用任何编程语言进行编写，这比起以太坊应用的合约受限于 Solidity 这么一种冷门的编程语言来说，区块链开发者们纷纷表态“不能同意更多”。 Cosmos 中使用的跨链技术用的是 侧链 机制，它规定了一套跨链通讯协议（IBC），通过它来实现的代币的跨链转移，我们这个系列要讲的 Basecoin 说白了也是一个 IBC 的具体实现。 IBC 的目的是让区块链彼此之间充当一个轻量级的客户端，由于 Tendermint 底层使用PBFT 共识算法，多个校验节点在处理新的区块之前会先达成一致，在客户端上进行验证是简单可行的：只须校验最新块的签名并验证默克尔树的 PoS 即可。 IBC 工作流程如下： 假设我们有两条区块链：Test_chain_1 和 Test_chain_2，从 Test_chain_1 发送数据到 Test_chain_2: 好了，前期知识铺垫得差不多了：我们从跨链技术的背景讲起，讲到了 Cosmos，Tendermint，ABCI，IBC，在这个过程中，大家脑海里应该被我灌输了这么几个概念： Cosmos 是一个专注于跨链资产转移的代币生态系统 Cosmos 的底层是 Tendermint 共识引擎 IBC 是 Cosmos 生态内部的一套跨链通讯协议 Basecoin 是一个基于 Tendermint 的 ABCI 应用 Basecoin 是一个基于 IBC 协议的跨链应用 终于要正式迎接 Basecoin 粉墨登场了。]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>区块链，跨链，IBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我体验了 N 款数字货币钱包]]></title>
    <url>%2F2018%2F05%2F06%2F%E6%88%91%E4%BD%93%E9%AA%8C%E4%BA%86%20N%20%E6%AC%BE%E6%95%B0%E5%AD%97%E8%B4%A7%E5%B8%81%E9%92%B1%E5%8C%85%2F</url>
    <content type="text"><![CDATA[钱包，被看作未来数字资产交易的入口，谁能成为其中的独角兽，谁就可能会成为未来区块链版的“支付宝”，甚至“微信”。 我司举办了一次“钱包抓虫大赛”，号召全公司员工去体验市面上流行的各种数字货币钱包，分析其优缺点，以便为我们的钱包设计提供借鉴和参考。 目前，各大主流钱包花样繁多，归根结底，我认为，钱包需要解决的核心需求无外乎： 资产管理 转账收款 私钥管理（我一直认为，凡是在服务端保存用户私钥的钱包都是伪钱包，无一例外） 一个钱包至少要在这三个功能点上做到“上手容易、操作简便、体验流畅”才能算是一个合格的钱包。 当然，大多数钱包还会在其它非主流功能上做文章： 收发红包 联系人 市场行情 业内资讯 第三方应用 C2C交易 多语种 小明周末两天挨个问候了目前用户群比较大的几款钱包，稍作整理，报告如下（仅代表个人看法）： imToken 优点： 界面优雅，蓝白相间的主题色调给人一种静谧的安全感（看得出，imToken 的设计师有一定的美学修养） 添加 token、收款转币体验非常流畅。特别是转账操作，既支持普通简易版，也支持高级选项版（设置 gas，gas price，自定义数据），照顾了多种用户需求，用户提示信息也出现得恰到好处。 支持多种导入导出方式（助记词、keystore、私钥、二维码扫描） 支持离线签名 卡片式集成第三方 DApp 缺点： 目前只支持以太坊生态圈币种（不过，据说最新的内测版支持 BTC 等其它主流币种） 资产不为零的 token 不会主动显示，需手动添加 行情只能看，无法进行交易 设置收款金额后，生成二维码时，二维码显示白底，需过一会后才恢复正常 比特派与其说它是钱包，不如说是个交易所 App，因此谈不上有什么钱包的优缺点，下面我从交易所 App 的角度来评价。 整体界面设计水平一般，顶层两栏有碍瞻观。 优点： 支持主流币种，其中 BTC 和 ETH 系的可以直接添加，其它系的需要搜索 支持一键买卖(支付宝、银行卡)、C2C交易、一键发token、eos映射 缺点： 切换币种时有烦人的提示 用户无法管理私钥，极不安全 身份验证无法上传照片，只能拍摄 功能太杂太乱 Kcash优点： 简直就是 imToken 的翻版（抄也抄得有模有样），不过这里的背景色调为金灰色，给人一种金光闪闪的土豪即视感。 用户体验和 imToken 不相上下，学习成本低 一套助记词，生成多种主流币种的私钥 支持 收发红包（红包代币可选，这是个中心化功能，需要用户注册登陆，钱包会为用户分配一个托管账户来管理跟红包相关的资产，托管账户和本地钱包账户是独立的），领红包界面设计得很好，用户提示细致周到，一步一步手把手告诉用户怎么领红包，充分吸引新用户去下载使用钱包 缺点： 新用户领红包要输入两次手机号和短信验证码，过程略繁琐 不支持多个钱包账户 不支持联系人功能 不支持离线签名 转账不支持用户设置矿工费和自定义数据 Cobo 钱包优点： 界面清爽，收发币体验流畅 支持主流币种 支持 收发红包，领红包过程较 kcash 更流畅 缺点： 需要注册登陆后才能用 本地无法管理私钥，由服务端保存，不安全 P钱包 http://pqb.com这款是我们公司开发的，由于没有专业的设计师和产品经理把关，无论是从设计还是用户体验来看，这款钱包都还有很多值得改进的地方。 优点： 一套助记词，生成多种主流币种的私钥 支持多个钱包账户 私钥只在本地保存（还支持导出到手机 SIM 卡） 支持离线签名（需搭配离线钱包使用） 缺点： 界面不美观：对于交易记录没有或很少的币种，上方的币种 Tab 页拥挤在一起，下方却显示一大片空白区域。 收发币操作流程不流畅： 首先，需要先滑到对应那个币种的 Tab 页 然后，选择接收方地址还要在“我的地址（默认）”和“我的好友” Tab 栏中切换一次，其实用户大部分都是转币给别人，为什么不默认跳到“我的好友”栏 名字太不好听，“屁钱包”？ 只能新增、无法删除某个钱包账户 生成私钥最后一步，“导出私钥”，界面却显示“导入私钥”，让人搞不明白到底什么意思 不支持生成固定金额的收款二维码 加载币种历史账单记录，一直显示“正在加载” 资产显示有问题，区块链上确认得记录了，P 钱包这边等了几个小时还是显示 0.0…… 总结总的来说，钱包市场百花齐放，良莠不齐，各领风骚。 imToken 因为其优雅的界面和良好的用户体验吸引了第一波种子用户，并且用户群在业内是当之无愧的第一位（已经上百万了）。 但是，由于它仅支持 ETH 系币种，使得其它支持 BTC 等主流币种的钱包异军突起。KCash 和 Cobo 对着 imToken 的设计依样画葫芦，通过 “抢红包” 这个大招吸引了不少用户群。 我司的 P 钱包（以后会重塑个上得了台面的名字吧）仍需努力啊。]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>钱包</tag>
        <tag>imToken</tag>
        <tag>KCash</tag>
        <tag>P钱包</tag>
        <tag>Cobo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gopher 做 PPT 的正确姿势]]></title>
    <url>%2F2018%2F03%2F28%2Fslide-present%2F</url>
    <content type="text"><![CDATA[试想一下，你作为一枚区块链技术开发者，受邀到某个区块链峰会做演讲，你总得做个 PPT 吧，做 PPT， mac 上自带了 keynote、pages 等软件还好，windows 系统的话你还得装个 powerpoint 吧。 到了会上做演讲，要么你自带笔记本，要么会场的电脑也得装了 PPT 播放软件，你才能把 PPT 投射出来。 嗯，情况就是这样。 我总觉得还是有点不方便。 而且，我想，我肯定不是第一个有这种感觉的人。 Origin最近，我们区块链底层开发组来了好几个实习生，我要给这拨刚毕业的同学们做个 go 语言基础培训，那肯定要做个类似于课件啊、讲义之类的 PPT 吧。 刚开始，我打开了 mac 的 keynote 捣鼓会，其实就跟 windows 上搞 ppt 差不多的操作…… 但是，我烦了。 我们这类技术培训，大部分内容跟代码相关，在 PPT 上贴一大段代码毕竟画面不会太好看，“PPT+IDE”组合又得不停地在两种窗口间切换来切换去，并且还得另外准备一份演示用的代码集。 懒人开始思考。 我想起刚学 go 语言那会在 YouTube 上看了不少 Google 大牛的 go 语言布道视频，他们演讲时好像是播放一种叫 slide 的文件，直接呈现在网页里，还可以在里面直接运行代码。 这正是我想要的，我花点时间研究了下其中的内幕。 Experientslide 是随着 Go 诞生而出现的一种 present 格式，Go 语言研发组那帮老爷们十分喜欢以这种格式分享 Go语言技术心得和想法，几乎所有技术会议的幻灯片均是以 .slide 形式提供的，给人一种“真会装逼”的感觉。 present 是一种文本标记语言，使用普通文本编辑器就能编写（还装什么 powerpoint、keynote啊），只要遵循它的语法，就可以使普通文本内容呈现出特定的格式。说白了，就跟我现在用 markdown 语法写这篇文章差不多，它让作者把精力花在内容上，而无需过多关心格式、排版等问题。 简单体验下 present 语法： 12345678Hello SlideHuang_Xuezhong33.cnhxz@disanbo.comhttp://hxzqlh.com* Hello world 就这么几行文本，就可以渲染出下面 3 张 slide。 回车键、方向键都可以控制往前或往后看～，神奇吧～ 本地运行的话，有这么几步： 1.先装一个 present 渲染工具。 1go get golang.org/x/tools/present 很不幸，如果你在天朝，无法访问 golang.org/x/tools, 不过好在你是一个 gopher，肯定知道，它已经转移到 github.com/golang/tools 有它的镜像，因此，在你的 GOPATH/src 下面手动创建个 golang.org/x 文件夹，再 git clone github.com/golang/tools，再 go install golang.org/x/tools/cmd/present, present 就安装到你的 GOPATH/bin目录中了。 2.在 slide 文件目录，将 present 跑起来： 12hxzdeMac-mini:~/workspace/slide $ present2018/03/27 20:34:36 Open your web browser and visit http://127.0.0.1:3999 3.打开浏览器访问 http://127.0.0.1:3999，会列出它渲染的 slide 文件列表，点击进去，就是见证奇迹的时刻…… Present花点时间熟悉下 persent 语法。 present 语法格式要求用户定义好 头部 和 正文。 header12345678910Title of documentSubtitle of document15:04 2 Jan 2006Tags: foo, bar, baz&lt;blank line&gt;Author NameJob title, Companyjoe@example.comhttp://url/@twitter_name 头部只有标题是必需的，它是第一个非空非注释行，子标题、日前、标签、作者等信息都是可选的，标题、作者头衔以及所在机构作为 slide 的第一页。 标签栏后留一个空行，可以附上作者信息：作者姓名、头衔、所在机构、邮箱、网站、Twitter名等，这部分会显示在最后那张 Thank you 的 slide 中。 body正文部分以 *后跟当前页标题来区分每张 slide。 正文语法示例如下，支持多级标题、列表、图片、代码段、网页链接等多种格式。 1234567891011121314151617181920212223242526272829* Title of slide or section (must have asterisk)Some Text** Subsection- bullets- more bullets- a bullet with*** Sub-subsectionSome More text Preformatted text is indented (however you like)Further Text, including invocations like:.code x.go /^func main/,/^&#125;/.play y.go.image image.jpg.background image.jpg.iframe http://foo.link http://foo label.html file.html.caption _Gopher_ by [[https://www.instagram.com/reneefrench/][Renée French]]Again, more text 最最令人兴奋的是，可以在里面直接跑代码： 真正的所见即所得啊，再也不用在代码区和演示文稿窗口间切来切去啦～这正是我等代码家梦寐以求的 PPT 打开方式啊。 关于 present 语法，这里 有详细的文档。 Watch It Everywhere本地 present 服务可以作为调试用，slide 最终是给别人看的。 通过 https://talks.godoc.org/ 提供的 present 渲染服务可以在线浏览 slide，并且支持 github 仓库中的 slide 文件。 Go 开发者们只需要将自己写好的 slide 文件存放在自己 github 上的仓库中，就可以随时随地打开这类 present 文件给大家分享了。 比如，我的 github 有一个叫 slide 的仓库地址：github.com/hxzqlh/slide/ ，里面有一个 golang_coding_standard.slide 然后，你只需按照【仓库地址/slide文件名】格式拼接到 https://talks.godoc.org/ 后面就可以观看了： https://talks.godoc.org/github.com/hxzqlh/slide/golang_coding_standard.slide 很实用吧。 但是…… 还是因为墙的原因，https://talks.godoc.org/ 在大陆是无法直接访问的，有梯子的还可以访问，没有梯子的怎么办？ TODO, 这里先挖个坑： 等有空了，我自己搭建个 https://talks.godoc.org/ 镜像。 有个老外在 YouTube 上放了个非常酷炫的 视频 来介绍 present，我上面讲的这些内容，里面都有涉及，我把它搬砖到腾讯视频了，快来看看吧。 Last如此一番折腾，我们得到了什么？ 我们可以不装 office，不用 keynote，只需打开你随身携带的记事本，简简单单地用 present 写 slide，一键上传至 github，只要有网，人人皆可访问。]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>slide</tag>
        <tag>present</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lisk：下一个百倍币，也许现在是最佳入手时机。]]></title>
    <url>%2F2018%2F03%2F07%2FLisk%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%99%BE%E5%80%8D%E5%B8%81%2C%E4%B9%9F%E8%AE%B8%E7%8E%B0%E5%9C%A8%E6%98%AF%E6%9C%80%E4%BD%B3%E5%85%A5%E6%89%8B%E6%97%B6%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[最近，老外在 Twitter、Reddit、GitHub 上讨论得最多的数字货币是哪个？Lisk。 什么是 Lisk？Lisk 是第一个完全用 Javascript 实现的去中心化的区块链应用开发平台，建立于 2016 年初。它的宣传口号是“一个App一条侧链”，Lisk 使开发人员能够通过部署侧链到主网来创建、分发、管理去中心化的区块链应用（简称：dApp）。 以太坊有什么问题？目前，90% 的智能合约都是跑在以太坊上，用户想要创建一个基于区块链的语言受到多方面的限制： 合约只能用一种小众得不能再小众的 Solidity 语言编写 只能用 pow 挖矿算法 不得不忍受交易高峰期的网络拥堵 Lisk 有何与众不同之处？目前，业界的区块链解决方案都是基于单个区块链或为某个专用区块链量身定制的。如果某个智能合约出现漏洞，那么其它智能合约甚至整个区块链网络都会深受其害，最明显的例子就是 2016 年爆发的以太坊 DAO 漏洞，该漏洞迫使以太坊不得不进行“硬分叉”（严格意义上来说，我们现在所说的以太坊其实是伪区块链，因为它为了挽回用户被盗的币，篡改了区块链账本，致使部分交易记录凭空消失，而秉持区块链“不可篡改性”的一方后来称之为以太坊经典）。 Lisk 则努力提供两全其美的解决方案：Lisk 主链提供了稳定性和安全性，而侧链则具有无限的灵活性，可以创建成千上万个个性化的 dApp。 Lisk 主链为开发人员提供了一个安全可控的环境，开发人员可以为自己的应用创建一条侧链，从而不必面对从零开始构建区块链网络的复杂性。 不同侧链之间互不影响，所以，即使某个合约出现 bug，危害范围也只局限于它所在的那一条链，主链和其它侧链感觉不到。 由于侧链的灵活性，开发人员可以完全实现和定制其 dApp，“一个应用一个侧链”，保持了主链的简单干净，用户只有用到相关的应用时才需要下载对应的侧链，同步速度非常快，整个 Lisk 网络可以高效运行，这可能就是 Lisk 跟其它区块链开发平台（以太坊、EOS、NEO）最大的不同并可能超越它们的地方。 Lisk 的愿景是让开发者能快速方便地使用区块链技术，而不仅仅局限于一小戳极客圈子里，它提供了一个使用 JavaScript 语言编写的 SDK 和详细的说明 文档。 众所周知，JavaScript 语言本身十分简单，上手快，工具链丰富，用户群比 Solidity 多得不知道哪里去了，光开发语言这一点，Lisk 就占尽了先机。任何 Web 开发人员只要会 JavaScript 和 Node.js ，都可以立即转移到 Lisk 去开发去中心化的应用程序。 Lisk BlockchainLisk 是一条公链，主网从 2016-05-24 开始运行，平均每 10 秒产生一个新块，现在已经到了 540 万左右高度。 Lisk 区块链进行交易的代币叫 LSK，目前市场价格大概为 16 美元，初始分配额度为 100000000 LSK。每创建一个新块，5 个新的 LSK 将被添加到总供应中。每经过 3000000（〜1年）个高度，新块奖励减少 1 LSK，最终减少至每块 1 LSK，当前新块奖励为 4 LSK。 Lisk 采用 dPOS 共识机制，每次选出 101 名代表为 Lisk 网络提供安全保障，新块奖励在 101 名代表中平均分配。此外，代表根据他们为特定区块中的交易收取交易费用。这套激励机制，可以保护 Lisk 区块链网络能够自发健全地演化下去。 对于那些小交易，一般会在 6 个块（1分钟）后得到确认，大交易在本轮委托投票期（1010 秒，～17分钟）结束后得到确认。 类似比特币、以太坊，它也有自己的浏览器: https://explorer.lisk.io，用户地址格式如 13449367279616835943L，是一串 20 个阿拉伯数字后面跟一个L。 Why Best Time to Buy LSK?好了，现在回答我的标题，为什么说“现在是 LSK 的最佳入手时机”？ 2018-02-20, Lisk 在柏林举行了 Rebrand 发布会，在接下来的 4 到 6 周（也就是三月底到四月初），将会发布重大更新：Lisk Core 1.0 Beta 版。跟据过往经验，一般某个币种社区公布了某项具有突破性质的进展后，该币都会蹭蹭蹭直线上涨。 我们看数字货币行情，受主流数字货币影响，LSK 近期已经从 35 美元持续下跌到了 16 美元。奇货可居啊，聪明的韭菜都知道在低价的时候买入，等待它涨到理想的高价吧。 据 CryptoMiso 报道，一大波开发者们正在涌向 Lisk：过去 3 个月，LSK 位列”数字货币类 GitHub 代码活跃度”排名榜首，众人看好的 EOS 也不过排第三而已。 是的。2018 年，LSK 极有可能上涨到 100 美元。]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>LSK</tag>
        <tag>以太坊</tag>
        <tag>EOS</tag>
        <tag>NEO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再来一次手牵手：php7.0 + protobuf]]></title>
    <url>%2F2018%2F01%2F19%2Fphp7.0_protobuf%20%E5%A1%AB%E5%9D%91%E4%B9%8B%E6%97%85%2F</url>
    <content type="text"><![CDATA[这两天在折腾 php。 php 作为世界世界上最好的编程语言，我不过是读研那会给导师做项目的时候撸过一年的代码，水平一般，只了解基本的语法，会进行简单的 php 后台开发，后来就没再用过了。 这次，是为了工作需要，在整理项目模块的时候，同事反映“之前的 php5.x 对 protobuf 的支持不是很好，解码出来的数据结构跟其它语言的对不上……”， 我当时的第一反应是：居然有这种事？至于具体是不是真的如此，我也懒得去重现。那是两年前的事，现在 php 都到 7.x ，protobuf 都到 3.5.1 了，时过境迁，IT 技术日新月异，或许问题早就解决了呢？ 报着试一试的态度，我主动提出来调研下 “protobuf 在 php7.0 的用法”。 phpdocker 里面现成的 php 镜像多的是，想要快的话，直接 run 一个 php 容器出来就可以，但是我想从零开始，体验下 Linux 配置 php 开发环境的流程，一步一个脚印，给人一种稳重的安全感。 所以，所以还是从一个裸体的 ubuntu 系统开始吧。 启动一个 ubuntu:16.04 容器： 1docker run -d -P -it ubuntu:16.04 bash 先装 php 的，这里我选了 7.0 版本： 1234567root@aae76b5e0ca4:/var/www/html# apt-get updateroot@aae76b5e0ca4:/var/www/html# apt-get install php7.0root@aae76b5e0ca4:/var/www/html# php -vPHP 7.0.22-0ubuntu0.16.04.1 (cli) ( NTS )Copyright (c) 1997-2017 The PHP GroupZend Engine v3.0.0, Copyright (c) 1998-2017 Zend Technologies with Zend OPcache v7.0.22-0ubuntu0.16.04.1, Copyright (c) 1999-2017, by Zend Technologies 装个 nginx 服务器来驱动 php 脚本吧： 123root@aae76b5e0ca4:/var/www/html# apt-get intall nginxroot@aae76b5e0ca4:/var/www/html# nginx -vnginx version: nginx/1.10.3 (Ubuntu) 配置下 nginx，开启 php 解释器， 修改 /etc/nginx/sites-enabled/default 这部分如下： 1234567location ~ \.php$ &#123; include snippets/fastcgi-php.conf; # With php7.0-cgi alone: # fastcgi_pass 127.0.0.1:9000; # With php7.0-fpm: fastcgi_pass unix:/run/php/php7.0-fpm.sock;&#125; 启动 PHP 和 nginx 服务： 123root@aae76b5e0ca4:/var/www/html# service php7.0-fpm startroot@aae76b5e0ca4:/var/www/html# service nginx start * Starting nginx nginx [ OK ] 这样，php 运行环境就搭建好了，可以写个简单的 PHP 脚本 helloworld.php 来验证下，把它放在 nginx 默认的网站根目录 /var/www/html 中: 123&lt;?php echo "Hello World!";?&gt; 现在就是见证奇迹的时刻： 12root@aae76b5e0ca4:/var/www/html# curl 127.0.0.1/helloworld.phpHello World! 只需几步就配置好了 php 运行环境，真是 Excited！ protobufphp7 要使用 Google protobuf 需要安装两个东西：protoc 编译器 和 php 扩展库。 protoc 编译器到 https://github.com/google/protobuf/releases 下载 linux 平台的 protoc ，把 bin 和 include 里面的文件拷贝到 /usr/local 的对应目录，这样 protoc 就算安装完成了： 12root@aae76b5e0ca4:/var/www/html# protoc --versionlibprotoc 3.5.1 写个 test.proto： 123456789101112131415161718syntax = "proto3";message PhoneNumber &#123; string number = 1; int32 type = 2;&#125;message Person &#123; string name = 1; int32 id = 2; string email = 3; repeated PhoneNumber phone = 4; double money = 5;&#125;message AddressBook &#123; repeated Person person = 1;&#125; 这个 proto 文件是什么意思，相信用过 proto 的人都知道。 编译 proto 文件： 123456789root@aae76b5e0ca4:/var/www/html# mkdir fooroot@aae76b5e0ca4:/var/www/html# protoc --php_out=foo test.protoroot@aae76b5e0ca4:/var/www/html# tree foo/foo/|-- AddressBook.php|-- GPBMetadata| `-- Test.php|-- Person.php`-- PhoneNumber.php 可以看到，protoc 编译出的结果里包含三个 php 文件（对应 proto 文件里面声明的三种结构）和 一个 GPBMetadata 文件夹（下面的 Test.php 描述了 test.proto 文件的元信息）。 php 扩展库protobuf 的 php 扩展 官方 提供了 c 动态库 和 php 包两种形式。 php 包形式我折腾了半天也不会用，烦死了。还是安装 c 动态库形式的扩展吧： 12345678root@aae76b5e0ca4:/var/www/html# apt-get install php-pear php7.0-dev autoconf automake libtool make gccroot@aae76b5e0ca4:/var/www/html# pecl install protobuf-3.5.1...Build process completed successfullyInstalling '/usr/lib/php/20151012/protobuf.so'install ok: channel://pecl.php.net/protobuf-3.5.1configuration option "php_ini" is not set to php.ini locationYou should add "extension=protobuf.so" to php.ini 提示安装成功，但还需要修改 php 的配置文件 /etc/php/7.0/fpm/php.ini， 开启 protobuf 库支持： 12;extension=php_xsl.dllextension=protobuf.so 重启 php7.0-fpm 服务。 Test准备工作做好后，就可以正式进行 protobuf 解析了。 写个测试例子 test.php： 123456789101112131415161718192021222324252627282930313233343536&lt;?phprequire_once "foo/GPBMetadata/Test.php";require_once "foo/AddressBook.php";require_once "foo/Person.php";require_once "foo/PhoneNumber.php";$foo = new Person();$foo-&gt;setName('hxz');$foo-&gt;setId(2);$foo-&gt;setEmail('notexist@foxmail.com');$foo-&gt;setMoney(1988894.995);$phone_num = new PhoneNumber();$phone_num-&gt;setNumber('1351010xxxx');$phone_num-&gt;setType(3);$phone = array();array_push($phone, $phone_num);$foo-&gt;setPhone($phone);$packed = $foo-&gt;serializeToString();try &#123; $p = new Person(); $p-&gt;mergeFromString($packed); echo "------------parsed-------\n"; echo $p-&gt;getName() ."\n"; echo $p-&gt;getEmail() ."\n"; echo $p-&gt;getMoney() ."\n"; echo $p-&gt;getId() . "\n"; echo $p-&gt;getPhone()[0]-&gt;getNumber() ."\n";&#125; catch (Exception $ex) &#123; die('Upss.. there is a bug in this example');&#125;?&gt; 访问 127.0.0.1/test.php 输出： 1234567root@aae76b5e0ca4:/var/www/html# curl localhost/test.php------------parsed-------hxznotexist@foxmail.com1988894.99521351010xxxx 看上去，protobuf 的 serializeToString 和 mergeFromString 都没有问题。 一切看上去都那么自然，但，这里有个问题，不得不提下。测试发现： 在 test.php 中，必须引入 proto 文件中声明过的所有结构类型（即使你只用到了里面的一个类型），否则会报错。 比如，注释掉这行 require_once &quot;foo/AddressBook.php&quot;;（事实上，AddressBook 这个类也没有用到）, nginx-error 日志输出： 12018/01/19 08:32:10 [error] 6880#6880: *39 recv() failed (104: Connection reset by peer) while reading response header from upstream, client: 127.0.0.1, server: _, request: "GET /test.php HTTP/1.1", upstream: "fastcgi://unix:/run/php/php7.0-fpm.sock:", host: "localhost" 这个就很恶心了，“我只想要个苹果，你却给我一车梨？”。具体原因我还不知道，谁能帮我解释下吗？ 总结php 本身的确是门很简单易用的语言，加上我当年学到的东西还没有忘光，所以重新拾起来还是有故人重逢的感觉。 小试牛刀发现：php7.0 下 protobuf 扩展是可以用的，配置起来也不是很难。 然后，我在调研过程中，还是留了 2 个坑： php 扩展包的另外一种安装方式 拔一发而动全身：必须引入 proto 文件中声明过的所有结构类型 有收获，也有遗憾，这次 “php7.0+protobuf” 的填坑之旅就这样告一段落吧，具体的业务代码，就让 phper 们去撸吧， 我还是喜欢用 go。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>protobuf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cgo 让 c 和 go 手牵手]]></title>
    <url>%2F2018%2F01%2F11%2FCGO%20%E8%AE%A9%20c%20%E5%92%8C%20go%20%E6%89%8B%E7%89%B5%E6%89%8B%2F</url>
    <content type="text"><![CDATA[go 里面的 cgo 包可以直接调用 c 代码，只需要遵守一定的使用规则即可，对于那些熟悉 c/c++ 的开发者来说，不失为一个福音。 三个代表cgo 会从 go 代码中去寻找 c/c++ 代码，约定： 紧挨在 import &quot;C&quot; 上面的所有 c 风格的注释语句都可以被 go 编译。 1.所有代码都写在一个 go 文件中123456789101112131415161718//foo.gopackage main/*#include &lt;stdio.h&gt;int count = 6;void foo() &#123; printf("I am foo!\n");&#125;*/import "C"import "fmt"func main() &#123; fmt.Println(C.count) C.foo()&#125; 这是最简便的方式，适用于 c 代码逻辑比较简单的情况。 12345678hxzdeMac-mini:~ $ tree.├── foo.go0 directories, 1 fileshxzdeMac-mini:~ $ go build -o foohxzdeMac-mini:~ $ ./foo6I am foo! 2.c 代码和 go 代码写在独立文件1234567891011121314151617181920212223242526//foo.hextern int count;void foo();//foo.c#include &lt;stdio.h&gt;#include "foo.h"int count = 6;void foo() &#123; printf("I am foo!\n");&#125;//foo.gopackage main/*#include "foo.h"*/import "C"import "fmt"func main() &#123; fmt.Println(C.count) C.foo()&#125; 像这种直接编译 c 源码和 go 源码的方式，只需执行 go build，cgo 会在当前目录或 c 语言 -I 编译参数指定的目录寻找需要的.h,.c文件。 12345678910hxzdeMac-mini:~ $ tree.├── foo.c├── foo.go└── foo.h0 directories, 3 fileshxzdeMac-mini:~ $ go build -o foohxzdeMac-mini:~ $ ./foo6I am foo! 3.go 代码调用动态链接库如果只提供了 c 的动态链接库和头文件，那么需要在 go 文件中指定 cgo 的 CFLAGS, CPPFLAGS, CXXFLAGS, LDFLAGS 等编译选项： 123456789101112131415161718//foo.hextern int count;void foo();//foo.gopackage main/*#cgo LDFLAGS: -L./ -lfoo#include "foo.h"*/import "C"import "fmt“func main() &#123; fmt.Println(C.count) C.foo()&#125; 1234567891011hxzdeMac-mini:~ $ tree.├── foo.go├── foo.h└── libfoo.dylib0 directories, 3 fileshxzdeMac-mini:~ $ go build -o foohxzdeMac-mini:~ $ ./foo6I am foo! go 引用 cC 里面的标准类型可以在 go 里面直接引用： 12345678910C.char, C.schar (signed char), C.uchar (unsigned char)C.short, C.ushort (unsigned short), C.int, C.uint (unsigned int), C.long, C.ulong (unsigned long), C.longlong (long long), C.ulonglong (unsigned long long), C.float, C.double, C.complexfloat (complex float), C.complexdouble (complex double).void* == unsafe.Pointer__int128_t and __uint128_t == [16]byte 引用 struct，union，enum： 123C.struct_Foo == struct FooC.union_Foo == union FooC.enum_Foo == enum Foo Go 里面的 struct 不能包含 C 类型。 sizeof：1C.sizeof_struct_Foo == sizeof(struct Foo) c 中结构体字段如果是 go 里面的关键字，那么可以在该结构体字段名前面加个 _ 来引用，比如： 1234567typedef struct Foo &#123; int val; int type;&#125;Foo;foo := C.Foo&#123;2,4&#125;fmt.Println(foo.val, foo._type) // 2 4 Cgo 将 C 类型转译成对应的 go 类型是不可导出的，因此，go 包导出的 API 里面不能含有 C 类型。 C 里面的函数执行结果可以赋给 go 里面的多返回值（执行结果和可能产生的错误值），即使是没有返回值的 void 类型函数。 12n, err = C.sqrt(-1)_, err := C.voidFunc() cgo 目前还不支持直接调用 C 里面的函数指针，你可以声明一个包含 C 函数指针的 go 变量（如下的 f），这样就可以在 go 和 C 之间传递了。 1234567891011121314151617181920212223package main/*typedef int (*intFunc) ();int bridge_int_func(intFunc f) &#123; return f();&#125;int fortytwo()&#123; return 42;&#125;*/import "C"import "fmt"func main() &#123; f := C.intFunc(C.fortytwo) fmt.Println(int(C.bridge_int_func(f))) // Output: 42 fmt.Println(int(C.bridge_int_func(C.fortytwo))) // error // cannot use _Cgo_ptr(_Cfpvar_fp_fortytwo) (type unsafe.Pointer) as type *[0]byte in argument to _Cfunc_bridge_int_func&#125; 在 C 里面， 如果一个函数接受一个数组参数，只需要传递数组名即可，但在 go 里面不行，你必须显示指定数组首元素的地址： 12345void f(int[] arr) &#123;&#125;f(arr); // CC.f(&amp;C.arr[0]) // go 下面是几组 c 和 go 之间拷贝数据的语法： 1234567891011// Go string to C string; result must be freed with C.freefunc C.CString(string) *C.char// C string to Go stringfunc C.GoString(*C.char) string// C string, length to Go stringfunc C.GoStringN(*C.char, C.int) string// C pointer, length to Go []bytefunc C.GoBytes(unsafe.Pointer, C.int) []byte c 引用 go 使用 //export &lt;function-name&gt; 导出 Go 代码 在 C 代码里面使用 extern 关键字引用 go 代码 12345678910111213141516171819202122package main/*extern void myprint(int i);void dofoo(void) &#123; int i; for (i=0;i&lt;10;i++) &#123; myprint(i); &#125;&#125;*/import "C"//export myprintfunc myprint(i C.int) &#123; fmt.Printf("i = %v\n", uint32(i))&#125;func main() &#123; C.dofoo()&#125; 传递指针go 是一门垃圾回收语言，垃圾回收器需要知道每个指针所指向的内存位置，正因为如此，在 go 和 c 之间传递指针有些许限制。 go 指针：使用 &amp; 操作符或 new 函数返回的指针 c 指针： 使用 C.malloc 返回的指针 首先，我们需要明白： 将指针传递给 struct 某个字段时，所涉及的 Go 内存是该字段占用的内存，而不是整个结构体占有的内存；将指针传递给数组或切片中的元素时，所涉及的 Go 内存是整个数组或整个切片的底层数组。 go 代码可以传递 go 指针给 c, 前提是这个指针指向的内存不包含任何 go 指针。c 代码必须保留这个属性： 它不能在 go 内存中存储任何 go 指针（即使是临时变量也不行）。 C 代码调用的 Go 函数可能会将 C 指针作为参数，并且可能通过这些指针存储非指针或 C 指针数据，但是它可能不会将 Go 指针存储在由C 指针指向的内存中；C 代码调用的 Go 函数可能会将 Go 指针作为参数，但它必须保留“指向的 Go 内存不包含任何 Go 指针”的属性。 Go 代码可能不会在 C 内存中存储 Go 指针，C 代码可能会在 C 内存中存储 Go 指针，这取决于上面的规则：当 C 函数返回时，它必须停止存储 Go 指针。 References https://blog.golang.org/c-go-cgo https://golang.org/cmd/cgo/]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>cgo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go 迷思之 Named 和 Unnamed Types]]></title>
    <url>%2F2017%2F11%2F27%2FGo-%E8%BF%B7%E6%80%9D%E4%B9%8B-Named-and-Unnamed-Types%2F</url>
    <content type="text"><![CDATA[先来热身一下，下面的代码能编译吗？为什么？ 1234567891011package maintype stack []uintptrfunc callers() stack &#123; return make([]uintptr, 20)&#125;func main() &#123; callers()&#125; (此处省略一分钟冥思苦想状….) 好啦，不用多想了，当然可以编译。 但是……这个问题重要吗？ 是的，很重要。 如果上面这份代码不能编译，那意味着你无法写这样的代码： 12type stack []uintptrvar st stack = make([]uintptr, 20) 而我们知道，这样的代码几乎无处不在。 再来，下面的代码能通过编译吗？ 12345678type T intfunc F(t T) &#123;&#125;func main() &#123; var q int F(q)&#125; 结合你平时写的代码，再思考一分钟…… Ops, it couldn’t。 稍微改动如下，它能通过编译吗？ 12345678type T []intfunc F(t T) &#123;&#125;func main() &#123; var q []int F(q)&#125; Yes, it does. Surprised?! How could this happen？ Read The Fxxking Manual言归正传，先来看下这又臭又长的 《Go 规范手册》 是怎么解释 Types 的。 A type determines a set of values together with operations and methods specific to those values. A type may be denoted by a type name, if it has one, or specified using a type literal, which composes a type from existing types. Named instances of the boolean, numeric, and string types are predeclared. Other named types are introduced with type declarations. Composite types—array, struct, pointer, function, interface, slice, map, and channel types—may be constructed using type literals. Each type T has an underlying type: If T is one of the predeclared boolean, numeric, or string types, or a type literal, the corresponding underlying type is T itself. Otherwise, T’s underlying type is the underlying type of the type to which T refers in its type declaration. Named vs Unnamed TypeNamed types 有两类： 内置的类型，比如 int, int64, float, string, bool， 用 type 关键字声明的类型，比如 type Foo string Unamed types：基于已有的 named types 声明出的组合类型，uname types 在 Go 里俯拾皆是。比如 struct{}、[]string、interface{}、map[string]bool、[20]float32…… Named types 可以作为方法的接受者， unnamed type 却不能。比如： 1234567891011type Map map[string]string// okfunc (m Map) Set(key string, value string)&#123; m[key] = value &#125;// invalid receiver type map[string]string (map[string]string is an unnamed type)func (m map[string]string) Set(key string, value string)&#123; m[key] = value &#125; Underlying Type每种类型 T 都有一个底层类型：如果 T 是预声明类型或者 类型字面量(笔者注：type literal 翻译成类型字面量，地道不？) ，它的底层类型就是 T 本身，否则，T 的底层类型是其类型声明中引用的类型的底层类型。 123456type ( B1 string B2 B1 B3 []B1 B4 B3 ) string, B1 和 B2 的底层类型是 string. B2 引用了 B1，那么 B2 的底层类型其实是 B1 的底层类型，而 B1 又引用了 string，那么 B1 的底层类型其实是 string 的底层类型，很明显，string 的底层类型就是string，最终 B2 的底层类型是 string。 []B1, B3, 和 B4 的底层类型是 []B1. []B1 是类型字面量，因此它的底层类型就是它本身。 所有基于相同 unnamed types 声明的变量的类型都相同，而对于 named types 变量而言，即使它们的底层类型相同，它们也是不同类型。 12345678910111213// x 是 unnamed typesvar x struct&#123; I int &#125;// x 和 x2 类型相同var x2 struct&#123; I int &#125;// y 是 named typetype Foo struct&#123; I int &#125;var y Foo// y 和 z 类型不同type Bar struct&#123; I int &#125;var z Bar Assignability不同类型的变量之间是不能赋值的。 1234type MyInt intvar i int = 2var i2 MyInt = 4i = i2 // error: cannot use i2 (type MyInt) as type int in assignment 你不能把 i2 赋值给 i，因为它们的类型不同，虽然它们的底层类型都是 int。 对于那些拥有相同底层类型的变量而言，还需要理解另外一个重要概念：可赋值性。在 Assignability 的六大准则中，其中有一条： x’s type V and T have identical underlying types and at least one of V or T is not a defined type. 也就是说底层类型相同的两个变量可以赋值的条件是：至少有一个不是 named type。 1234x = y // oky = x // okx = x2 // oky = z // error: cannot use y (type Foo) as type Bar in assignment 现在，你知道“为什么开头那两份代码为什么一个能编译另一个不能”了吧。 Type Embedding当你使用 type 声明了一个新类型，它不会继承原有类型的方法集。 1234567891011121314151617package maintype User struct &#123; Name string&#125;func (u *User) SetName(name string) &#123; u.Name = name&#125;type Employee User func main()&#123; employee := new(Employee) employee.SetName("Jack"). // error employee.SetName undefined (type *Employee has no field or method SetName)&#125; 作为一个小技巧，你可以将原有类型作为一个匿名字段内嵌到 struct 当中来继承它的方法，这样的 struct 在 Go 代码中太常见不过了。 比如： 12345678910111213141516171819package maintype User struct &#123; Name string&#125;func (u *User) SetName(name string) &#123; u.Name = name&#125;type Employee struct &#123; User // annonymous field Title string&#125;func main()&#123; employee := new(Employee) employee.SetName("Jack")&#125; Last But Not LeastGo 里面关于类型 Types 的一些规定有时候让初学者丈二和尚摸不着头脑，而 Types 几乎是任何一门编程语言的基石，如果你不能理解 Go 里面最基本的概念之一：Types，相信我，你将不可能在这门语言上走远。]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Named Types</tag>
        <tag>Unnamed Types</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go 语言从入门到放弃之 range]]></title>
    <url>%2F2017%2F10%2F29%2Fgo-range_quiz%2F</url>
    <content type="text"><![CDATA[《Go Range 内部实现》 这篇译文对于 Go 开发者来说，很值得一读。 对比老外的原文和作者的翻译，可以学到些许关于 for...range 语法的奥妙。尤其是对于 Go 初学者来说，可以避免少踩几次关于 range 的「坑」。 缘起老外在 twitter 上图这个 Go 语言小测试，初看此题，直觉上你可能会认为这个 for 循环会无休止地执行下去，因为每次都往切片尾部新增了一个元素，导致切片无法遍历结束。蛤蛤，这是典型的一知半解式解答。不过，即便你能猜到该程序能正常结束并且 v 最终为 [1 2 3 0 1 2]，你也未必能讲明白 Why。 剖析在 《Go 规范文档》 「For statements with range clause」 一节可以找到关于 for...range 语法的相关说明。 123for v := range a &#123; fmt.Println(v)&#125; 我不想大段大段地摘抄原文，你需要知道的一个关键点是： 循环变量（v）在每一次迭代中都被 赋值 且 复用。 range 右边（上例 a）的表达式（或表达式展开后的结果），可以是这些数据类型： 数组(或指向数组的指针） 切片 字符串 map 可以接收传输的 channel, 比如：chan int 或 chan&lt;- int 在 Go 里，所有的赋值都是 值拷贝。如果赋值了一个指针，那我们就复制了一个指针副本。如果赋值了一个结构体，那我们就复制了一个结构体的副本。 那么， 对于不同类型 a，range a 返回的结果是什么呢？ 类型 a range a 赋值结果 array 一个新数组：拷贝原始数组到新数组 slice 一个结构体：拥有一个变量 len 、一个变量 cap 和一个指针指向原有 slice 背后的数组 string 一个结构体：拥有一个变量 len 和一个指针指向原有 string 背后的字符数组 map 一个指针：指向原有 map 底层结构体（哈希表） channel 一个指针：指向原有 channel 原文作者还去瞅了瞅 Go 里面 for...range 一个 slice 编译的源码: 12345678// for_temp := range// len_temp := len(for_temp)// for index_temp = 0; index_temp &lt; len_temp; index_temp++ &#123;// value_temp = for_temp[index_temp]// index = index_temp// value = value_temp// original body// &#125; 回到这个测试题； 123456func main() &#123; v := []int&#123;1, 2, 3&#125; for i := range v &#123; v = append(v, i) &#125;&#125; 这段代码之所以会结束是因为它其实可以粗略的翻译成类似下面的这段： 12345678for_temp := vlen_temp := len(for_temp)for index_temp = 0; index_temp &lt; len_temp; index_temp++ &#123; value_temp = for_temp[index_temp] index = index_temp value = value_temp v = append(v, index)&#125; 在循环开始前对这个 slice 生成副本赋值给 for_temp，后面的循环实际上是在对 for_temp([1 2 3]) 而非原始变量 v 进行迭代。 再深一点前面列出了不同类型 a 经过 range a 赋值后的结果，有两个地方需要注意； 对数组赋值都会拷贝到一个新的数组，若要更改原始数组，可通过引用原数组下标的方式修改， 如 a[i] = val。 在 range 循环里对 map 做添加或删除元素的操作是安全的，添加的元素 不一定 会出现在后续的迭代中。 为什么在 map 后续的迭代中不一定能遍历到当前添加的元素？ 译文这样解释道： 如果你知道哈希表是如何工作的（map 本质上就是哈希表），就会明白哈希表内部数组里的元素并不是以特定顺序存放。最后一个添加的元素有可能经过哈希后被放到了内部数组里的第一个索引位，我们确实没有办法预测当前添加的元素是否会出现在后续的迭代中，毕竟在添加元素的时候很可能已经遍历过了第一个索引位。因此，当前添加的元素是否能在后续迭代中遍历到，还是看编译器的心情吧。 举个栗子： 12345678910111213141516func main() &#123; data := make(map[string]int) data["one"] = 1 data["two"] = 2 data["three"] = 3 for k, v := range data &#123; fmt.Println(k, v) if v == 1 &#123; data["four"] = 4 delete(data, "three") &#125; &#125; fmt.Println(data)&#125; 下面是几次运行结果： 12345678910111213one 1two 2map[two:2 four:4 one:1]three 3one 1two 2map[one:1 two:2 four:4]one 1two 2four 4map[one:1 two:2 four:4] 我们在遍历时即插入也删除了元素，最终都为 map[one:1 two:2 four:4]，但可以看到，对 map 元素的遍历是无序的，遍历时插入的元素也不一定出现在后续遍历中。 另一面前面说了： 循环变量（v）在每一次迭代中都被 赋值 且 复用。 赋值讲得差不多了，还有复用呢？ 这也是初学者易踩的一个大坑。在 《Go的50度灰：Golang新开发者要注意的陷阱和常见错误》 一文中，作者给了很大的篇幅详解「for 循环变量在每次迭代中会被复用」这一特性。这个特性意味着你在 for 循环中创建的闭包（即函数字面量）将会引用同一个变量（而在那些 goroutine 开始执行时就会得到那个变量的值）。 在 for 循环中开启 go routine 尤其需要注意「复用」这个特性，由于 go 一个协程出来，go 运行环境会为这个协程分配一个协程栈来存放函数参数、闭包引用的外部变量等。 比如下面这个例子： 1234567891011121314151617package mainimport ( "fmt" "time")func main() &#123; data := []string&#123;"one","two","three"&#125; for _,v := range data &#123; go func() &#123; fmt.Println(v) &#125;() &#125; time.Sleep(3 * time.Second) // 协程栈里的 v 是 for 语句里面 v 的副本, 而后者每次迭代都复用 // 3 个协程几乎都要等待 cpu 调度到这里才开始运行，此时协程栈里的 v 都是 「three」 // 因此输出: three, three, three&#125; 解决方法，众所周知的有两种： 1.不需要修改 goroutine，在 for 循环代码块内把当前迭代的变量值保存到一个局部变量中。 123456for _,v := range data &#123; vcopy := v go func() &#123; fmt.Println(vcopy) &#125;()&#125; 2.把当前的迭代变量作为 goroutine 的参数。 12345for _,v := range data &#123; go func(in string) &#123; fmt.Println(in) &#125;(v)&#125; 来看看这个稍微复杂一点的例子： 12345678910111213141516171819202122package mainimport ( "fmt" "time")type field struct &#123; name string&#125;func (p *field) print() &#123; fmt.Println(p.name)&#125;func main() &#123; data := []*field&#123; &#123;"one"&#125;,&#123;"two"&#125;,&#123;"three"&#125; &#125; // data for _,v := range data &#123; go v.print() &#125; time.Sleep(3 * time.Second)&#125; 相信你已经知道，如果 //data 这行改为 data := []field{ {&quot;one&quot;},{&quot;two&quot;},{&quot;three&quot;} }，毫无疑问三个协程输出都是 &quot;three&quot;，但这个例子，切片元素 filed 用指针修饰，输出将会如何呢？ 答案是输出: &quot;one&quot;,&quot;two&quot;,&quot;three&quot;。 data := []*field{ {&quot;one&quot;},{&quot;two&quot;},{&quot;three&quot;} } 中，for 循环的 v 是指针，print 这个方法接收的是指针的拷贝，协程栈里保存的 v 指针值都是不同的，所以每次输出不同。 因此，有第三种 fix 办法：将切片元素用指针修饰，同样可以达到 goroutine 引用到每个元素的目的。 总结其实，不管哪一门语言，即使是所谓的大神，一不小心在某些语法细节上栽跟头也是司空见惯。至于为什么会掉「坑」，无外乎这「三个代表」： 理解的得根本就不对，南辕北辙； 认知不够彻底，只知其一不知其二； 先入为主，把其他语言的思维惯用在这门语言之上。 到这里，希望你的脑中有了一副清晰的图像描绘 for...range在底层是如何运作的，以后别再掉进那些「坑」里。]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>range</tag>
        <tag>for</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go 之初体验]]></title>
    <url>%2F2017%2F05%2F11%2FGo%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[小明最近新入职了一家研究区块链技术的 复杂美科技有限公司，岗位职责是用 Go 语言做区块链底层开发。 Go 之前都没接触过，现学现卖咯～这几天上班，小明启动了 3 条工作线程： 熟悉公司的产品 消化这份 《区块链技术指南》 学习 Go 语言 在此，总结下初步学习 Go 语言的一些心得。 考虑到公众号粉丝群众的职业分布，小明温馨提示： 为避免文章内容专业性太强，引起部分用户生理不适，非计算机从业者请直接拉到最下赞赏通道 ^_^ …… 由来在接触 Go 以前，我用 C/C++、Python 作为后台的主要开发语言。 C/C++ 的问题： 开发效率低，对开发者要求高 Python 的问题： 动态语言，缺少编译过程，低级错误频出 性能差，不适合做高性能服务 我对 Go 的初体验： 有 C/Python 基础，学 Go 非常轻松 代码简洁，格式统一，阅读方便 天生支持高并发 略逊于 C/C++ 的高性能 + Python 的高开发效率 部署极其方便，不依赖其它库 格式化格式化问题总是充满了争议，但却始终没有形成统一的定论 缩进用空格还是制表符 Tab？ 大括号 { 要不要另起一行？ 代码结尾需不需要以分号;结尾？ 虽说人们可以适应不同的编码风格， 但抛弃这种适应过程岂不更好？若所有人都遵循相同的编码风格，在这类问题上浪费的时间将会更少。 问题就在于如何实现这种设想，而无需冗长的语言风格规范。在 Go 中我们另辟蹊径，让机器来处理大部分的格式化问题。 举例来说，你无需花时间将结构体中的字段注释对齐，gofmt 将为你代劳。 假如 teso.go 有以下声明： 1234type T struct &#123; name string // 对象名 value int // 对象值&#125; 运行 gofmt test.go，它将按列对齐为： 1234type T struct &#123; name string // 对象名 value int // 对象值&#125; 发明 go 语言的那帮老爷们简单粗暴终结了这三大影响程序员群体团结的争论： 缩进用 Tab 大括号 { 不要另起一行 代码结尾不要分号; 包每个 Go 程序都是由包组成的。 Go 源文件中的第一个语句必须是 1package 名称 如果是可执行程序，第一行必须是 1package main 程序运行的入口是函数 main。 12345678910package mainimport ( "fmt" "math/rand")func main() &#123; fmt.Println("My favorite number is", rand.Intn(10))&#125; 这个程序使用并导入了包 &quot;fmt&quot; 和 &quot;math/rand&quot;。 按照惯例，包名与导入路径的最后一个目录一致。例如，&quot;math/rand&quot; 包由 package rand 语句开始。 导入1234import ( "fmt" "math") 这个代码用圆括号组合了导入，这是打包导入语句。 同样可以编写多个导入语句，例如： 12import "fmt"import "math" 不过使用打包的导入语句是更好的形式。 函数函数可以没有参数或接受多个参数。 123func add(x int, y int) int &#123; return x + y&#125; add 接受两个 int 类型的参数。 类型在变量名 之后。(参考 这篇关于 Go 语法定义的文章了解类型以这种形式出现的原因。) 当两个或多个连续的函数命名参数是同一类型，则除了最后一个类型之外，其他都可以省略。 上面这个例子中， x int, y int 可以被缩写为： x, y int 多值返回函数可以返回任意数量的返回值。 123func swap(x, y string) (string, string) &#123; return y, x&#125; swap 函数返回了两个字符串。 命名返回值Go 的返回值可以被命名，并且像变量那样使用。 12345func split(sum int) (x, y int) &#123; x = sum * 4 / 9 y = sum - x return&#125; 返回值的名称应当具有一定的意义，可以作为文档使用。 没有参数的 return 语句返回结果的当前值。也就是直接返回。 变量var 语句定义了一个变量的列表，跟函数的参数列表一样，类型在后面。 12345678910package mainimport "fmt"var c, python, java boolfunc main() &#123; var i int fmt.Println(i, c, python, java)&#125; 就像在这个例子中看到的一样，var 语句可以定义在包或函数级别。 初始化变量变量定义可以包含初始值，每个变量对应一个。 如果初始化是使用表达式，则可以省略类型；变量从初始值中获得类型。 12345678910package mainimport "fmt"var i, j int = 1, 2func main() &#123; var c, python, java = true, false, "no!" fmt.Println(i, j, c, python, java)&#125; 短声明变量在函数中，:=简洁赋值语句在明确类型的地方，可以用于替代 var 定义。 函数外的每个语句都必须以关键字开始（var、func等） := 结构不能使用在函数外。 1234567func main() &#123; var i, j int = 1, 2 k := 3 c, python, java := true, false, "no!" fmt.Println(i, j, k, c, python, java)&#125; 基本类型123456789101112131415boolstringint int8 int16 int32 int64uint uint8 uint16 uint32 uint64 uintptrbyte // uint8 的别名rune // int32 的别名 // 代表一个Unicode码float32 float64complex64 complex128 零值变量在定义时没有明确的初始化时会赋值为零值。 数值类型为 0 布尔类型为 false 字符串为 &quot;&quot;（空字符串） 类型转换表达式 T(v) 将值 v 转换为类型 T。 一些关于数值的转换： 123var i int = 42var f float64 = float64(i)var u uint = uint(f) 或者，更加简单的形式： 123i := 42f := float64(i)u := uint(f) 与 C 不同的是 Go 在不同类型之间的项目赋值时需要显式转换。 类型推导在定义一个变量但不指定其类型时（使用没有类型的 var 或 := 语句）， 变量的类型由右值推导得出。 当右值定义了类型时，新变量的类型与其相同： 12var i intj := i // j 也是一个 int 但是当右边包含了未指名类型的数字常量时，新的变量就可能是 int 、float64 或 complex128，这取决于常量的精度： 123i := 42 // intf := 3.142 // float64g := 0.867 + 0.5i // complex128 常量常量的定义与变量类似，只不过使用 const 关键字。 常量可以是字符、字符串、布尔或数字类型的值。 常量不能使用 := 语法定义。 123const Pi = 3.14const World = "世界"const Truth = true 数值常量数值常量是高精度的值。 一个未指定类型的常量由上下文来决定其类型。 1234567891011121314151617181920package mainimport "fmt"const ( Big = 1 &lt;&lt; 100 Small = Big &gt;&gt; 99)func needInt(x int) int &#123; return x*10 + 1 &#125;func needFloat(x float64) float64 &#123; return x * 0.1&#125;func main() &#123; fmt.Println(needInt(Small)) //fmt.Println(needInt(Big)) // error: overflows int fmt.Println(needFloat(Small)) fmt.Println(needFloat(Big))&#125; 控制结构forGo 只有一种循环结构: for 循环。 基本的 for 循环除了没有了 ( ) 之外（甚至强制不能使用它们），看起来跟 C 或者 Java 中做的一样，而 { } 是必须的。 1234sum := 0for i := 0; i &lt; 10; i++ &#123; sum += i&#125; 跟 C 或者 Java 中一样，可以让前置、后置语句为空。 1234sum := 1for sum &lt; 1000 &#123; sum += sum&#125; 死循环如果省略了循环条件，循环就不会结束，因此可以用更简洁地形式表达死循环。 12for &#123;&#125; if &amp; elseif 语句除了没有了 ( ) 之外（甚至强制不能使用它们），看起来跟 C 或者 Java 中的一样，而 { } 是必须的。（耳熟吗？） 跟 for 一样，if 语句可以在条件之前执行一个简单的语句。 由这个语句定义的变量的作用域仅在 if 范围之内。在 if 的便捷语句定义的变量同样可以在任何对应的 else 块中使用。 123456789func pow(x, n, lim float64) float64 &#123; if v := math.Pow(x, n); v &lt; lim &#123; return v &#125; else &#123; fmt.Printf("%g &gt;= %g\n", v, lim) &#125; // 这里开始就不能使用 v 了 return lim&#125; switchswitch 的条件从上到下的执行，当匹配成功的时候停止。 1234switch i &#123; case 0: case f():&#125; 当 i==0 时不会调用 f。 没有条件的 switch 同 switch true 一样。 这一构造使得可以用更清晰的形式来编写长的 if-then-else 链。 12345678switch &#123; case t.Hour() &lt; 12: fmt.Println("Good morning!") case t.Hour() &lt; 17: fmt.Println("Good afternoon.") default: fmt.Println("Good evening.")&#125; deferdefer 语句会延迟函数的执行直到上层函数返回。 延迟调用的参数会立刻生成，但是在上层函数返回前函数都不会被调用。 延迟的函数调用被压入一个栈中。当函数返回时， 会按照 后进先出 的顺序调用被延迟的函数调用。 12345678910package mainimport "fmt"func main() &#123; defer fmt.Println("hxz") defer fmt.Println("world") fmt.Println("hello")&#125; 输出： 123helloworldhxz 阅读 博文 了解更多关于 defer 语句的信息。 指针Go 具有指针。 指针保存了变量的内存地址。 类型 *T 是指向类型 T 的值的指针。其零值是 nil。 &amp; 符号会生成一个指向其作用对象的指针。 12i := 42p = &amp;i * 符号表示指针指向的底层的值。 12fmt.Println(*p) // 通过指针 p 读取 i*p = 21 // 通过指针 p 设置 i 与 C 不同，Go 没有指针运算。 结构体一个结构体（struct）就是一个字段的集合。 结构体文法表示通过结构体字段的值作为列表来新分配一个结构体。 使用 Name: 语法可以仅列出部分字段。（字段名的顺序无关。） 特殊的前缀 &amp; 返回一个指向结构体的指针。 123456789101112131415161718package mainimport "fmt"type Vertex struct &#123; X, Y int&#125;var ( v1 = Vertex&#123;1, 2&#125; // 类型为 Vertex v2 = Vertex&#123;X: 1&#125; // Y:0 被省略 v3 = Vertex&#123;&#125; // X:0 和 Y:0 p = &amp;Vertex&#123;1, 2&#125; // 类型为 *Vertex)func main() &#123; fmt.Println(v1, p, v2, v3) //&#123;1 2&#125; &amp;&#123;1 2&#125; &#123;1 0&#125; &#123;0 0&#125;&#125; new 返回类型为 T 的指针 不会初始化内存，只会将内存置零 make 返回类型为 T 的值，不返回指针 内存已初始化 （而非置零） 它只用于创建切片、映射和信道 数组类型 [n]T 是一个有 n 个类型为 T 的值的数组。 表达式 var a [10]int定义变量 a 是一个有十个整数的数组。 数组的长度是其类型的一部分，因此数组不能改变大小。 数组在Go和C中的主要区别。在Go中: 数组是值。将一个数组赋予另一个数组会复制其所有元素。 若将数组传入某个函数，它将接收到该数组的一份副本而非指针。 数组的大小是其类型的一部分。类型 [10]int 和 [20]int 是不同的。 slice除了矩阵变换这类需要明确维度的情况外，Go中的大部分数组编程都是通过切片来完成的。 切片保存了对底层数组的引用，若你将某个切片赋予另一个切片，它们会引用同一个数组。 若将切片传入某个函数，它将接收到该切片的一份指针。 一个 slice 会指向一个序列的值，并且包含了长度信息。 []T 是一个元素类型为 T 的 slice。 slice 的零值是 nil。 一个 nil 的 slice 的长度和容量是 0。 切片sliceslice 可以重新切片，创建一个新的 slice 值指向相同的数组。 s[lo:hi]:从 lo 到 hi-1 的 slice 元素，含两端。 s[lo:lo]是空的，而s[lo:lo+1]有一个元素。 构造 sliceslice 由函数 make 创建： 1a := make([]int, 5) // len(a)=5 为了指定容量，可传递第三个参数到 make： 12345678910111213141516171819package mainimport "fmt"func main() &#123; a := make([]int, 5) printSlice("a", a) //a len=5 cap=5 [0 0 0 0 0] b := make([]int, 0, 5) printSlice("b", b) //b len=0 cap=5 [] c := b[:2] printSlice("c", c) //c len=2 cap=5 [0 0] d := c[2:5] printSlice("d", d) //d len=3 cap=3 [0 0 0]&#125;func printSlice(s string, x []int) &#123; fmt.Printf("%s len=%d cap=%d %v\n", s, len(x), cap(x), x)&#125; 向 slice 添加元素1func append(s []T, vs ...T) []T 第一个参数 s 是一个类型为 T 的数组，其余类型为 T 的值将会添加到 slice。 append 的结果是一个包含原 slice 所有元素加上新添加的元素的 slice。 如果 s 的底层数组太小，而不能容纳所有值时，会分配一个更大的数组。 返回的 slice 会指向这个新分配的数组。 了解更多关于 slice 的内容，参阅文章 slice：使用和内幕。 rangefor 循环的 range 格式可以对 slice 或者 map 进行迭代循环。 可以通过赋值给 _ 来忽略序号或 值。如果只需要索引值，去掉, value 的部分即可。 12345678910111213package mainimport "fmt"func main() &#123; pow := make([]int, 10) for i := range pow &#123; pow[i] = 1 &lt;&lt; uint(i) &#125; for _, value := range pow &#123; fmt.Printf("%d\n", value) &#125;&#125; mapmap 映射键到值。 map 在使用之前必须用 make 而不是 new 来创建；值为 nil 的 map 是空的，并且不能赋值。 12345678type Vertex struct &#123; Lat, Long float64&#125;m = make(map[string]Vertex)m["Bell Labs"] = Vertex&#123; 40.68433, -74.39967,&#125; 在 map m 中插入或修改一个元素： 1m[key] = elem 获得元素： 1elem = m[key] 删除元素： 1delete(m, key) 通过 双赋值 检测某个键存在： 1elem, ok = m[key] 如果 key 在 m 中，ok 为 true 。否则， ok 为 false，并且 elem 是 map 的元素类型的零值。 同样的，当从 map 中读取某个不存在的键时，结果是 map 的元素类型的零值。 闭包函数也是值。 Go 函数可以是闭包的。闭包是一个函数值，它来自函数体的外部的变量引用。 函数可以对这个引用值进行访问和赋值；换句话说这个函数被“绑定”在这个变量上。 例如，函数 adder 返回一个闭包。每个闭包都被绑定到其各自的 sum 变量上。 123456789101112131415161718192021package mainimport "fmt"func adder() func(int) int &#123; sum := 0 return func(x int) int &#123; sum += x return sum &#125;&#125;func main() &#123; pos, neg := adder(), adder() for i := 0; i &lt; 10; i++ &#123; fmt.Println( pos(i), neg(-2*i), ) &#125;&#125; 方法Go 没有类。然而，仍然可以在结构体类型上定义方法。 方法接收者出现在 func 关键字和方法名之间的参数中。 12345678910111213141516171819202122232425package mainimport ( "fmt" "math")type Vertex struct &#123; X, Y float64&#125;func (v *Vertex) Scale(f float64) &#123; v.X = v.X * f v.Y = v.Y * f&#125;func (v *Vertex) Abs() float64 &#123; return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func main() &#123; v := &amp;Vertex&#123;3, 4&#125; v.Scale(5) fmt.Println(v, v.Abs())&#125; 接口接口类型是由一组方法定义的集合。 12345678910111213141516171819202122232425262728293031323334353637383940414243package mainimport ( "fmt" "math")type Abser interface &#123; Abs() float64&#125;func main() &#123; var a Abser f := MyFloat(-math.Sqrt2) v := Vertex&#123;3, 4&#125; a = f // a MyFloat 实现了 Abser fmt.Println(a.Abs()) a = &amp;v // a *Vertex 实现了 Abser fmt.Println(a.Abs()) // 下面一行，v 是一个 Vertex（而不是 *Vertex） // 所以没有实现 Abser。 // a = v&#125;type MyFloat float64func (f MyFloat) Abs() float64 &#123; if f &lt; 0 &#123; return float64(-f) &#125; return float64(f)&#125;type Vertex struct &#123; X, Y float64&#125;func (v *Vertex) Abs() float64 &#123; return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125; 错误Go 程序使用 error 值来表示错误状态。 与 fmt.Stringer 类似，error 类型是一个内建接口： 123type error interface &#123; Error() string&#125; Readersio 包指定了 io.Reader 接口，它表示从数据流结尾读取。 Go 标准库包含了这个接口的许多实现， 包括文件、网络连接、压缩、加密等等。 io.Reader 接口有一个 Read 方法： 1func (T) Read(b []byte) (n int, err error) Read 用数据填充指定的字节 slice，并且返回填充的字节数和错误信息。 在遇到数据流结尾时，返回 io.EOF 错误。 下例创建了一个 strings.Reader。 并且以每次 8 字节的速度读取它的输出。 123456789101112131415161718192021package mainimport ( "fmt" "io" "strings")func main() &#123; r := strings.NewReader("Hello, Reader!") b := make([]byte, 8) for &#123; n, err := r.Read(b) fmt.Printf("n = %v err = %v b = %v\n", n, err, b) fmt.Printf("b[:n] = %q\n", b[:n]) if err == io.EOF &#123; break &#125; &#125;&#125; Web 服务器包 http 通过任何实现了 http.Handler 的值来响应 HTTP 请求： 12345package httptype Handler interface &#123; ServeHTTP(w ResponseWriter, r *Request)&#125; 在这个例子中，类型 Hello 实现了 http.Handler。 访问 http://localhost:4000/ 会看到来自程序的问候。 12345678910111213141516171819202122package mainimport ( "fmt" "log" "net/http")type Hello struct&#123;&#125;func (h Hello) ServeHTTP( w http.ResponseWriter, r *http.Request) &#123; fmt.Fprint(w, "Hello!")&#125;func main() &#123; var h Hello err := http.ListenAndServe("localhost:4000",h) if err != nil &#123; log.Fatal(err) &#125;&#125; goroutine注意不要混淆并发和并行的概念： 并发是用可独立执行的组件构造程序的方法 并行则是为了效率在多CPU上平行地进行计算 尽管 Go 的并发特性能够让某些问题更易构造成并行计算， 但 Go仍然是种并发而非并行的语言，且Go的模型并不适合所有的并行问题。 关于其中区别的讨论，见 concurrency-is-not-parallelism goroutine 是由 Go 运行时环境管理的轻量级线程。 A goroutine has a simple model: it is a function executing concurrently with other goroutines in the same address space。 开启一个新的 goroutine: 1go f(x, y, z) 执行: 1f(x, y, z) f ， x ， y 和 z 是当前 goroutine 中定义的，但是在新的 goroutine 中运行 f。 goroutine 在相同的地址空间中运行，因此访问共享内存必须进行同步。 channel它将共享的值通过信道传递， 在任意给定的时间点，只有一个Go 程序能够访问该值，数据竞争从设计上就被杜绝了。 不要通过共享内存来通信，而应通过通信来共享内存。 “引用计数”通过为整数变量添加互斥锁来地实现，但作为一种高级方法，通过信道来控制访问能够让你写出更简洁、正确的程序。 channel 是有类型的管道，可以用 channel 操作符 &lt;- 对其发送或者接收值。 12ch &lt;- v // 将 v 送入 channel ch。v := &lt;-ch // 从 ch 接收，并且赋值给 v。（“箭头”就是数据流的方向。） 和 map 与 slice 一样，channel 使用前必须创建： 1ch := make(chan int) channel 可以是 带缓冲的。为 make 提供第二个参数作为缓冲长度来初始化一个缓冲 channel： 1ch := make(chan int, 100) 默认情况下，在另一端准备好之前，发送和接收都会阻塞。这使得 goroutine 可以在没有明确的锁或竞态变量的情况下进行同步。 只有缓冲区满的时候发送者阻塞 只有缓冲区空的时候接收者阻塞 发送者可以 close 一个 channel 来表示再没有值会被发送了。接收者可以通过赋值语句的第二参数来测试 channel 是否被关闭：当没有值可以接收并且 channel 已经被关闭，那么经过 1v, ok := &lt;-ch 之后 ok 会被设置为 false。 循环 for i := range c 会不断从 channel 接收值，直到它被关闭。 注意： 只有发送者才能关闭 channel，而不是接收者。向一个已经关闭的 channel 发送数据会引起 panic。 还要注意： channel 与文件不同；通常情况下无需关闭它们。只有在需要告诉接收者没有更多的数据的时候才有必要进行关闭。 12345678910111213141516171819202122232425262728293031package mainimport ( "fmt" "time")func main() &#123; one := make(chan int) two := make(chan int) go func() &#123; fmt.Println("one is sleep...") time.Sleep(1 * time.Second) one &lt;- 100 &#125;() go func() &#123; fmt.Println("wait one...") v := &lt;-one fmt.Println("get one:", v) fmt.Println("two is sleep...") time.Sleep(2 * time.Second) two &lt;- v &#125;() fmt.Println("wait two...") vv := &lt;-two fmt.Println("get two:", vv)&#125; selectselect 语句使得一个 goroutine 在多个通讯操作上等待。 select 会 阻塞，直到条件分支中的某个可以继续执行，这时就会执行那个条件分支。当多个都准备好的时候，会随机选择一个。 默认选择当 select 中的其他条件分支都没有准备好的时候，default 分支会被执行。 为了非阻塞的发送或者接收，可使用 default 分支： 123456select &#123; case i := &lt;-c: // 使用 i default: // 从 c 读取会阻塞&#125; 总结现在只是掌握了基本的 go 语法，能看懂代码，以后要到项目中实战才能领略到 go 的威力，慢慢练吸 go 大法吧。]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>复杂美</tag>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人҉҉要҉҉是҉҉雾霾吸҉҉多҉҉了҉҉,҉҉连҉҉看҉҉东҉҉西҉҉眼҉҉都҉҉是҉҉花҉҉哈哈的҉҉。]]></title>
    <url>%2F2017%2F01%2F06%2F%E4%BA%BA%D2%89%D2%89%E8%A6%81%D2%89%D2%89%E6%98%AF%D2%89%D2%89%E9%9B%BE%E9%9C%BE%E5%90%B8%D2%89%D2%89%E5%A4%9A%D2%89%D2%89%E4%BA%86%D2%89%D2%89-%D2%89%D2%89%E8%BF%9E%D2%89%D2%89%E7%9C%8B%D2%89%D2%89%E4%B8%9C%D2%89%D2%89%E8%A5%BF%D2%89%D2%89%E7%9C%BC%D2%89%D2%89%E9%83%BD%D2%89%D2%89%E6%98%AF%D2%89%D2%89%E8%8A%B1%D2%89%D2%89%E5%93%88%E5%93%88%E7%9A%84%D2%89%D2%89%E3%80%82%2F</url>
    <content type="text"><![CDATA[去年微信爆出的《你女朋友撤回了一条消息还亲了你一口》那个 bug，让广大微信用户 excited了一把。 今天，小明在微信群和朋友圈看到了这样因缺思婷的消息: 消息栏里显示乱码，朋友圈也在玩： 此时，已到下班时间，但是你们都懂的，我是一个对技术敏感而细致的男人，对技术的由衷渴望明显战胜了凡夫俗子的食欲。 在第一时间知会微信总舵主张小龙后，我马上开始研究这个有趣的乱码。 经过一番调试后，小明发现是 u&quot;\u0489&quot; 这个 unicode 字符 ҉ 搞得鬼，它有一个诡异的名字叫 COMBINING CYRILLIC MILLIONS SIGN，翻译成国语就是 可拼接的西里尔修饰符字母。 那么，问题又来了，什么是西里尔字母? 谷歌一下： 西里尔字母主要在俄罗斯、东欧、北亚和中亚等国家使用。截至2011年，欧亚大陆约有2.52亿人使用它作为本国语言的官方字母表，俄罗斯约占其中一半。……西里尔语源自希腊语，现代学者认为，西里尔是由西里尔和迪乌斯的早期门徒发展和形式化的。 18世纪初，在俄罗斯使用的西里尔字母由彼得大帝重新改革，新形式的字母变得更接近拉丁字母，几个古老的字母被删除，几个字母是由彼得大帝亲自设计的（如Я，灵感来自拉丁语R）。 （҉，u0489）是西里尔字符系统中的一个修饰词，它无法独立显示，当附着在其他字符前面或后面后，就出出现叠加在字符上面的雾霾效果。 在各种编码系统中，如何表示这个符号呢： Encoding HTML Entity (decimal) &amp;#1161; HTML Entity (hex) &amp;#x489; How to type in Microsoft Windows Alt +0489 UTF-8 (hex) 0xD2 0x89 (d289) UTF-8 (binary) 11010010:10001001 UTF-16 (hex) 0x0489 (0489) UTF-16 (decimal) 1161 UTF-32 (hex) 0x00000489 (0489) UTF-32 (decimal) 1161 C/C++/Java source code “\u0489” Python source code u”\u0489” 为҉了҉便҉于҉缓҉解҉多҉年҉后҉人҉们҉对҉当҉下҉雾҉霾҉的҉思҉念҉，特҉别҉推҉出҉一҉款҉合҉成҉的҉雾҉霾҉专҉用҉纪҉念҉字҉体҉：雾҉霾҉体҉。҉ 雾҉霾҉体҉下҉可҉以҉有҉雾҉霾҉宋҉体҉、҉雾҉霾҉黑҉体҉、҉雾҉霾҉文҉泉҉驿҉以҉及҉超҉级҉雾҉霾҉体҉等҉等҉字҉体҉…҉…҉ 其҉字҉体҉的҉技҉术҉实҉现҉很҉简҉单҉，现҉有҉字҉加҉U҉n҉i҉c҉o҉d҉e҉字҉符҉：&#x0489;即҉可҉，如： 原&amp;#x0489;来&amp;#x0489;如&amp;#x0489;此&amp;#x0489; 就会显示成： 原&#x0489;来&#x0489;如&#x0489;此&#x0489;]]></content>
      <categories>
        <category>WeChat</category>
      </categories>
      <tags>
        <tag>微信</tag>
        <tag>字符编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两小儿 jiang 音辩「长城」]]></title>
    <url>%2F2016%2F12%2F17%2F%E4%B8%A4%E5%B0%8F%E5%84%BF-jiang-%E9%9F%B3%E8%BE%A9%E3%80%8C%E9%95%BF%E5%9F%8E%E3%80%8D%2F</url>
    <content type="text"><![CDATA[孔子东游钱塘江，水天相接，江天一色，美哉、壮哉。 路遇两小儿辩斗。 一儿曰：「长城」上映一日，口碑评分陷入江局，吾之于能否走向世界江信江疑。 一儿曰：江心比心，所谓仁者见仁，智者见智，个人主观臆断不可以偏概全。 一儿曰：艺谋张搞大场面，弄色之才登峰造极，然每每不能如观众所愿，江郎才尽乎？《英雄》之后，再无良作，江淹梦笔乎？ 一儿曰：不然，此片非往昔烂片可比，艺谋本色执导，好莱坞和我国一线伶人加盟，一流工业水准打造，即使在西方世界翻江倒海也未可知。 对曰：This is your feeling。国师坐拥天时地利人和之便，吾本对此片充满期待，然以今日之观感，大失所望：长城打怪，虽江心独妙，然西式的特效怪兽与中国特色精神文明建设格格不入；人物台词草草敷衍，人物性格亦无甚亮点；故事推进得莫名其妙，期间堆砌各种中国元素，恰似一个个割裂的舞台节目，掐着表计算演出时间，one by one 地～急着登场，又仓促谢幕。真是糟蹋了这满满一城的精致！ 一儿曰：此诚如所言，然五色禁军视觉之观感、大场景 3D 之特效、BGM 之震撼淋漓，不亦可赛艇乎？ 对曰：众人皆知国师有三把斧：霸气之阵容、华美之艳服、夺目之背景，然此等浮夸小技若欲俘获观众，须以故事情节之饱满、发人深省之价值观为本。江山易改，本性难移，汝不知《十面埋伏》《黄金甲》前车之鉴乎？江本逐末，甚之不惠。再有一附庸权贵伶人，世人皆称烂片女王，乃江门弃材也，而艺谋江颜屈体跪舔之，不惠又甚之诶。 「呸，汝江嘴拗舌，一派胡言，不要给我们景甜泼脏水」 「哼，汝江嘴硬牙，无可奉告，就要搞你们景甜大新闻」 孔子不能决也。 两小儿怒而蛤斥曰：「Naive，孰为汝多知乎？」]]></content>
      <categories>
        <category>蛤学</category>
      </categories>
      <tags>
        <tag>长城</tag>
        <tag>怪兽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[天分与坚持：四分之一世纪的跑步]]></title>
    <url>%2F2016%2F12%2F07%2F%E5%A4%A9%E5%88%86%E4%B8%8E%E5%9D%9A%E6%8C%81%EF%BC%9A%E5%9B%9B%E5%88%86%E4%B9%8B%E4%B8%80%E4%B8%96%E7%BA%AA%E7%9A%84%E8%B7%91%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[《当我谈跑步时，我谈些什么》这本书是村上春树的跑步回忆录，从 2005 夏天动笔到 2006 秋天写完，零零星星写了他跑步二十年多来的回忆或感悟。 我为什么开始跑步了1978 年 4 月 1 日，下午一点半，29 岁的村上春树决定开始写小说。 为了全身心地投入到写小说中，他和妻子商量卖掉了经营得还不错的酒吧，改掉了原先凌晨两三点下班回家睡觉、中午起床的作息习惯，开始每天清晨五点就起床，晚上十点前睡觉，这样一种规则的生活，一直坚持至今。 他这样看待因此而「荒废」的夜生活和不得不推脱的各种邀约聚会： 人生之中总有一个先后顺序，也就是如何去安排时间和能量。到一定的年龄之前，如果不在心中制定好这样的规划，人生就会失去焦点，变得张弛失当。与和周遭的人们交往相比，我宁愿又想确立能专心致志创作小说的稳定和谐的生活。我的人生中最为重要的人际关系并非同某些特定的人物构筑的，而是与或多或少的读者构筑的。稳定我的生活基盘，创造出能集中精力执笔写作的环境，催生出高品质的作品，才会为更多的读者欢迎，这也是我作为一个小说家的责任和义务。 「人不可能做到八面玲珑、四方讨巧」。说白了，就是此意。 刚刚成为专业小说家那会儿，他首先直面的问题却是「如何保持身体健康」。 打算作为小说家度过今后漫长的人生，就必须找到一个既能维持体力，又可将体重保持得恰到好处的方法。 村上春树性情孤绝，喜爱独处，他坦言自己没有发达的运动神经和灵活的四肢，不擅长那些速战速决型的竞技类体育项目，但是像跑步和游泳这种一个人就可以完成的运动，倒和他的胃口。 至少在跑步时不想和任何人交谈，不必听任何人说话，只需眺望周围的风光凝视自己便可，这是任何东西都无法替代的宝贵时刻。 而且，相比其他运动，跑步有几个显而易见的长处：不需要伙伴或对手也不需要特别的装备，更不必特地赶赴某个特别的场所，只要有一双适合跑步的鞋，有一条马马虎虎的路，就可以在兴致所至时爱跑多久就跑多久。 基于这些考虑，小说家村上春树在他 33 岁时开始了跑步这项运动，无论寒暑冬夏，几乎每天都坚持跑步，你猜他跑了多久？ 27 年！每周跑 60 公里，一周 6 次，平均每天 10 公里，累计参加 28 次马拉松…… 为自己而跑对于各种体育运动，村上春树说他不甚在乎胜负成败，倒是更关心能否达到为自己设定的标准。 他每日一面跑步，一面将目标的横杆一点点提高，通过超越这高度来提高自己，至少是通过刻意的训练来提高自己，并为之付出努力。在长跑中，如果说有什么必须战胜的对手，那就是过去的自己。 对于他来说，能否感到自豪或者类似自豪的东西，这，才是最重要的。当然不需要跑得比香港记者还快啊。 同样的说法也适用于写作，小说家这一职业至少对我来说是无所谓胜负成败的。书的销量、得奖与否、评论的好坏，这些或许能成为成功与否的标志，但不能说是本质问题。写出来的文字是否达到了自己设定的基准，这，才是至为重要；这，才容不得狡辩。别人大概怎么都可以搪塞，自己的心灵却无法蒙混过关。在这层意义上，写小说很像跑全程马拉松，对于创作者而言，其动机安安静静、确确实实地存在于自身，不应向外部去寻求形式与标准。 跑步 vs 写小说写小说并非那么安逸的工作。坐在书桌前，将神经如同激光束一般集中于一点，动用想象力，从无的地平线上催生出故事来，挑选出一个个正确的词语，让所有的流程准确无误，这样一种工作与一般人想象的相比，更为长久的需要远为巨大的能量。 作为一个小说家，村上春树不是天生才华横溢的那类。为了写小说，非得奴役身体，耗费时间和劳力不可。因为长年累月的坚持这种生活，久而久之，就技术和体力而言，他都能相当高效的找到新的创作灵感。 他写小说的许多方法是每天清晨沿着道路跑步时学到的。 对小说家来说，最为重要的资质是什么？无需赘言，当然是才华。这是必要的资质，或者说前提条件，就好比如果没有燃料，再出色的汽车也无法开动。然而，才华于质于量都是主人难以驾驭的天分。 第二的重要资质，是集中力。将自己拥有的有限的才能汇集，然后倾注于最为需要之处的能力。没有它，则不足以办成任何大事。有效地使用这种力量，就可弥补才华的不足与偏颇。 第三是耐力，每天集中精力写作，坚持半载，一载，乃至两载，有志于写长篇的小说的作家就必须具有这种耐力，姑且把这比作「呼吸法」： 假使说集中力是屏住呼吸，耐力就是一面屏气，一面学会安静徐缓地呼吸。这两种呼吸法如果不能保持平衡，就难以长年累月地作为职业作家坚持写小说。得一面屏住呼吸，一面继续呼吸。 每天不间断地写作，集中意识地去工作，这事非做不可，将这样的信息持续不断地传递给身体系统，让他牢牢地记住，再悄悄移动刻度，一点一点将极限值向上提升，注意不让身体发觉。 这跟每天坚持慢跑，强化肌肉，逐步打造出跑者的体型，乃是异曲同工。给它刺激，持续，再给它刺激，持续。这一过程当然需要耐心，不过一定会得到相应的回报。 跑步哲学萨摩赛特·毛姆说：「任何一把剃刀都自有其哲学」。 无论何等微不足道的举动，只要天天坚持日日坚持，从中总会产生出某些类似观念的东西来。 村上春树 作家（兼跑者） 1949-20xx 他至少是跑到了最后]]></content>
      <categories>
        <category>心旷神怡</category>
      </categories>
      <tags>
        <tag>村上春树</tag>
        <tag>跑步</tag>
        <tag>写作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《你的名字》难再续]]></title>
    <url>%2F2016%2F12%2F04%2F%E3%80%8A%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97%E3%80%8B%E9%9A%BE%E5%86%8D%E7%BB%AD%2F</url>
    <content type="text"><![CDATA[梦里相逢人不见，若知是梦何须醒。纵然梦里常幽会，怎比真如见一回。 男高中生小江一天醒来突然发现自己变成了女生，拥有了亮丽的歌喉，而女高中生小宋醒来后发现自己裤腰带特别高。 身处两地的两人身体互换，奇妙地过上了对方的生活。 身为小宋的小江上课时听到老师讲林则徐的故事：「苟……」，大受启发；身为小江的小宋考入名牌大学，突然来到北京，突然就任要职。 有一天，小宋偶然发现自己不再能跟小江交换身体，于是前往北京寻找原因，发现未来的小江身患重病，躺在军区医院里。 小宋为了警告小江，跑到地动仪前祈祷再次穿越到小江的身体里。她看到蟾蜍嘴里的球掉了下来，陷入了昏迷。 醒来后，小宋再度变成了小江。 她跑到天安门前大喊「苟……」，此时，变成小宋的小江也在天安门前，听到小宋的呼喊。两人擦身错过，却看不到对方，只能听到声音。这时小江提议绕着天安门广场奔跑，跑得越来越快，直到两人均速一样的时候就看到了对方。 小宋拿起笔说我们写下对方的名字吧，小江说「好」，这时候小江消失了。当小宋醒来，却再也不记得那个人是谁。她打开手掌，只能看到手心里写着「+1s」。 原来，两个人一直在以 1s 的单位不停远离开去，所以永远都见不到对方。小宋在绝望之中站在天安门广场上大声呼喊「你的名字是……」 冥冥之中突然传来小江的声音：「蛤？」]]></content>
      <categories>
        <category>蛤学</category>
      </categories>
      <tags>
        <tag>新海诚</tag>
        <tag>你的名字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[苦涩虐心的爱河]]></title>
    <url>%2F2016%2F11%2F29%2F%E8%8B%A6%E6%B6%A9%E8%99%90%E5%BF%83%E7%9A%84%E7%88%B1%E6%B2%B3%2F</url>
    <content type="text"><![CDATA[渡边爱过直子，如今仍同样爱着她，希望等她病好了后和她重新开始新的生活。 从阿美寮疗养所看望直子回来后，渡边和绿子已经无法制止地相爱了。渡边爱绿子这点恐怕更早些时候就已了然于心，只不过他长期回避作出结论。 绿子心里多么渴望和渡边在一起啊，可是渡边牵挂的只是直子的病情，他把自己关在一个人的世界里，对外界的一切都不关心。自然，也就冷落了绿子这个活蹦乱跳的女孩： 「你可知道？今天你做了一件十分使我伤心事：你甚至没有注意到我发型的变化吧？我辛辛苦苦一点点把头发留长，好不容易在上周末把发型变得像个女孩模样，可你连这点都未察觉吧？我自以为十分可爱，加之久未见面，本想吓你一跳，然而你根本无动于衷，这岂不太跟人过不去？反正你现在恐怕连我穿什么衣服都记不起来了。我也是个女孩！你就是再有心事要想，也多少该正眼看我一下才行。只消说上一句’好可爱的发型’，往下无论你做什么，哪怕再心事重重，我都会原谅你」。 不错，我是生你气来着，恨不得狠狠踢你一百八十脚。还不是，好久才见一次面，你却呆愣愣地只顾想别的女人，看都不愿看我一眼，我就是生这个气。 在一起的时候不好好珍惜，绿子不理他了，渡边才发现自己内心其实也爱着绿子： 「由于不能同你说话，我送走了十分凄楚而寂寞的四月和五月，如此凄楚寂寞的春天，我还是第一次体会到。见不到你之后，我才深深意识到，只因有你，我才得以好歹坚持到现在，失去你之后，我实在孤独得好苦」。 他对绿子的爱或许是因为直子的缘故有所犹豫和保留，但绿子对渡边的爱则是那样汹涌澎湃，没有怀疑的余地。 「为什么？」绿子吼道，「你脑袋是不是不正常，又懂英语虚拟语气，又能解数列，又会读马克斯，这一点为什么不明白？为什么还要问？为什么非得叫女孩子开口不可？还不是因为我喜欢你超过喜欢他吗？我本来也很想爱上一个更英俊的男孩，但没办法就是看中了你」。 「我可是有血有肉的活生生的女孩」，绿子把脸颊擦着我的脖颈上说，「而且现在就在你的怀抱里表白说喜欢.只要你一声令下，赴汤蹈火都在所不惜.虽然我多少有蛮不讲理的地方，但心地善良正直，勤快能干，脸蛋也相当俊俏，乳房形状也够好看，饭菜做得又好，父亲的遗产也办了信托存款，你还不认为这是大甩卖？你要是不买，我很快就到别处去」。 问题在于渡边无法很好地向直子解释这种局面的发展。他对直子，一直抱有某种爱的责任，并且他不能放弃这种责任，纵使直子并不爱他，他在自己心田中为直子保留了相当大一片未曾被人染指的园地（渡边自从去年到疗养所看望直子，回来之后大半年再没和女孩子睡过觉）。 在直子身上，我感到的是娴静典雅而澄澈晶莹的爱，而绿子方面则截然相反，那是站立着的，在行走，在呼吸，在跳动，在摇撼我的身心的爱，我心乱如麻，不知所措。 他也无法制止和绿子相爱。「我渴求她，她也渴求我，我们已经在相爱，有谁能制止得了呢？」 渡边想起在雨中天台拥抱绿子，那是何等柔软；在她床上被其用手抚慰，又是何等温暖。 作为我，何尝不想把绿子剥得精光，分开下肢进入到她温暖的缝隙中去——为克制这种强烈的冲动，我不知做了多大努力。当她握住我那种东西的手指缓缓移动的时候，我实在不能自已。 绿子，热情如火；直子，平静如水。苦涩的爱河，不知流淌向何处。 村上村树借玲子给渡边的回信，表达了他对渡边和直子、绿子的三角关系的看法： 第一，渡边既痴情于直子，又强烈地被绿子吸引，这就好比「在风和日丽的天气里荡舟于美丽的湖面，我们会既觉得蓝天迷人，又深感湖水多娇」——乃人之常情。 第二，即使不作为直子的恋人，渡边依然可以是直子的精神支柱，还可以为直子做很多事。 第三，爱上一个人是难得的好事，更难得是两个人彼此都相爱。抓住机会，去追求你自己的幸福吧，人的一生中这种机会只有两三回，一旦失之交臂，一辈子都后悔莫及。 令读者惋惜的是，直子最后自杀了，渡边君最终也没能挽回绿子。 一股沉痛的忧伤！]]></content>
      <categories>
        <category>挪威的森林</category>
      </categories>
      <tags>
        <tag>绿子</tag>
        <tag>直子</tag>
        <tag>渡边</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一种从来不曾实现而且永远不可能实现的憧憬]]></title>
    <url>%2F2016%2F11%2F28%2F%E4%B8%80%E7%A7%8D%E4%BB%8E%E6%9D%A5%E4%B8%8D%E6%9B%BE%E5%AE%9E%E7%8E%B0%E8%80%8C%E4%B8%94%E6%B0%B8%E8%BF%9C%E4%B8%8D%E5%8F%AF%E8%83%BD%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%86%A7%E6%86%AC%2F</url>
    <content type="text"><![CDATA[初美是永泽的女朋友，她长得并不出众，但她身上有一股强烈打动人的力量，她娴静、理智、幽默、善良，浑身发出高贵而优雅的气质。 永泽时常同别的女孩子厮混，她基本晓得，但一次也没有出口怨言。她真心真意爱着永泽，却丝毫不加以干涉。 永泽是一个精致的利己主义者，用村上春树的话说就是，「一个在道德意义上破产的人」。 但这不代表他一无是处，他有句名言值得每一个有志青年共勉： 不要同情自己，同情自己是卑劣懦夫干的勾当。 他比身边绝大多数人都努力得多，其他人只是毫无目的地幸苦劳动，他是有目标地规划他想要的人生。 比如说，为了外务省工作更得心应手，他开始拼命自学西班牙语，法语也是自学的，并达到了无懈可击的地步。 他说： 和玩女人一个道理，只要摸到一条规律，往下任凭多少都是一个模式。 永泽无法打心眼里爱上一个人，而总有某个地方保持清醒的饥渴感，他需要的只是搂着女人肉体的快感，而不想担责任。 身体有了性欲，见面、干、分手，连女孩子名字都不知道，如此而已。 他敢于面对未来任何的阻挡，勇往直前，不为任何事情束缚牵绊。他享受当下的快感，又不期待未来的种种。这样的人是无法接受一般的所谓的幸福的，因为那些所谓的幸福在他的眼里低俗不堪，甚至无法忍受。 永泽对初美是一种欣赏和认同，出于对她某一特性的憧憬和触动。但这不能称之为爱，他感兴趣的，永远只是自己而已，就像他说的，「初美能理解最好，不能理解是她自己的问题」。 初美命中注定爱上了这样一个精明、自私、不负责任的男人，三年来如此执着地等着他。 终于有一次聚餐时，初美受够了永泽的傲慢自私，大喊： 我受伤害还不够吗，你们还想要多少人受伤害？ 永泽出走，初美嫁为人妇，不久便割腕自杀了。 由于初美的死，渡边觉得「某种东西消失了」。 这是种什么东西，渡边直到在十二三年后才恍然大悟： 它类似一种少年时代的憧憬，一种从来不曾实现而且永远不可能实现的憧憬。这种直欲燃烧般的天真烂漫的憧憬，我在很早以前就已遗忘在什么地方了，甚至在很长时间里我连它曾在我心中存在过都未曾记起。而初美所摇撼的恰恰就是我身上长眠未醒的「我自身的一部分」。当我恍然大悟时，一时悲枪之极，几欲涕零。 年少时，我们每个人都有过对爱情的幻想，那时憧憬的爱情是简单纯洁干净的。长大后，在滚滚红尘中打拼得久了，生活逐渐颓废，以往坚持的信念开始崩塌，虚无感产生之后便开始从花天酒地中寻找慰藉（就像永泽和渡边出去约炮）。 而初美身上，有一种纯真的力量，她对爱情执念如初，会勾起人遗失的记忆。渡边终于见到了这样的爱情，见到了这样的女性，这是如榜样一样的人啊，初美身上寄托了渡边所有对于爱情的理解与憧憬。 初美的一生都是纯粹的。 然而，初美死了，所以他觉得「某种东西消失了」。 唯死者永远年轻。]]></content>
      <categories>
        <category>挪威的森林</category>
      </categories>
      <tags>
        <tag>初美</tag>
        <tag>永泽</tag>
        <tag>纯真</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你真是个好人呢]]></title>
    <url>%2F2016%2F11%2F27%2F%E4%BD%A0%E7%9C%9F%E6%98%AF%E4%B8%AA%E5%A5%BD%E4%BA%BA%E5%91%A2%2F</url>
    <content type="text"><![CDATA[上次的那个星期天，绿子和渡边在晒衣台上看火灾、喝酒、唱歌，过得实在是太开心了。 别人总是对她挑鼻子竖横眼，一见面就叫她要这样不要那样……唯独渡边什么也没有强加于她，一切都是自然而然地就发生了。 渡边没什么朋友，喜欢独来独往，对周遭的人和事都抱着「无所谓、你开心就好」的态度，这种貌似软绵绵、缺乏男性魄力的特质，绿子却喜欢得不得了，经常约他出来一起玩。 绿子大胆地对他表白示爱，使劲地挑逗他，撩他，幻想渡边强奸她、幻想渡边想着她来手淫、幻想他俩被海盗抓住浑身扒光脸对脸绑在一起…… 倒不是说绿子性饥渴，她一直在女校长大、没有同龄的男孩子陪她玩、父母对她又缺乏关爱。因此，她仅仅是对此感兴趣，急于想知道罢了。想知道男孩子都在思考些什么，身体结构是什么样子。她男朋友却古板得要死，每次谈到这些，他就沉下脸，说她淫乱，不正常，连爱抚一下那里都不让。 绿子拉渡边去看色情电影，她最喜欢那种镜头出现的时候，听见周围一大群男人「咕噜」咽唾液的声音，可爱得不得了。 绿子觉得孤单，孤单得要命，希望渡边多陪陪她，渡边则一直谦让着她，由着她闹性子，陪她讲各种下流的脏话，陪她喝酒聊天看电影，在以往二十年人生当中，能允许她这样做的只有渡边一个。 她非常想和渡边在一起，「求你了，要不然我就坐在这儿呜呜哭一晚上，谁向我第一个搭话，就跟谁睡去」，渡边只得跟着绿子去了她家过夜。 “喂喂喂，说点什么呀！”绿子把脸埋在我胸前说。“说什么？”“什么都行，只要我听着心里舒坦。”“可爱极了！”“绿子，”她说，“要加上名字。”“可爱极了，绿子。”我补充道。“极了是怎么个程度？”“山崩海枯那样可爱。”绿子扬脸看看我：“你用词倒还不同凡响。”“给你这么一说，我心里也暖融融的。”我笑道。“来句更棒的。”“最最喜欢你，绿子。”“什么程度？”“像喜欢春天的熊一样。”“春天的熊？”绿子再次扬起脸，“什么春天的熊？”“春天的原野里，你一个人正走着，对面走来一只可爱的小熊，浑身的毛活像天鹅绒，眼睛圆鼓鼓的。它这么对你说道：‘你好，小姐，和我一块儿打滚玩好么？’接着，你就和小熊抱在一起，顺着长满三叶草的山坡咕噜咕噜滚下去，整整玩了一大天。你说棒不棒？”“太棒了。”“我就这么喜欢你。”绿子紧紧贴住我的胸口，“好上天了！” 渡边这段时间由于还没有确认对绿子到底是一种怎样的感情，因此他刻意避免同绿子发生性关系，即使和绿子躺在一张小床上，即使「绿子把鼻子贴着我的胸口，手搭在我的腰部」，渡边也极力克制了自己，待绿子响起睡熟的声音后，溜下床去厨房看《在轮下》。 可以说，渡边一旦确认了对对方的感情，比如直子，对待性就变得严肃起来，开始有了责任感，而不像从前那样，为了释放生理的欲望，随随便便就和女孩子上床睡觉。 而这，未尝不可视为他对纯真的爱情的追求。]]></content>
      <categories>
        <category>挪威的森林</category>
      </categories>
      <tags>
        <tag>好人</tag>
        <tag>在轮下</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[这世上的长者已不多]]></title>
    <url>%2F2016%2F11%2F26%2F%E8%BF%99%E4%B8%96%E4%B8%8A%E7%9A%84%E9%95%BF%E8%80%85%E5%B7%B2%E4%B8%8D%E5%A4%9A%2F</url>
    <content type="text"><![CDATA[他，一位可敬的长者，出生在 1926 年，曾经一度大权在握，也曾拥有许多信众，在乱世身经百战，与对手谈笑风生，在永生的道路上，他走得比谁都远…… 然而今天，这位长者，突然～就去见马克思了。 他的经历嘛，就是到了哈瓦那，到了 1959 年初的时候，他就领着他创建的古巴共产党建立了古巴社会主义共和国。 在哈瓦那执政 52 年，他也没做别的，主要就是三件事: 第一个，就是通过努力奋斗在 2014 年获得了孔子和平奖。 第二个，就是 sleep with 35000多个 women。 第三个，就是躲过了 638 次美国反动派的暗杀。 如果说还有什么别的，那就是在续命征程上落后了中国的长者，很惭愧，先走一步了。]]></content>
      <categories>
        <category>蛤学</category>
      </categories>
      <tags>
        <tag>卡斯特罗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不正常人类疗养院]]></title>
    <url>%2F2016%2F11%2F25%2F%E4%B8%8D%E6%AD%A3%E5%B8%B8%E4%BA%BA%E7%B1%BB%E7%96%97%E5%85%BB%E9%99%A2%2F</url>
    <content type="text"><![CDATA[《挪》书中的人物，似乎个个都有各自的缺陷，得不到排解的人，一死了之，活着的人，在苦苦探寻心灵的自我救赎。 木月不正常。 他拼命掩饰自己软弱的一面，在渡边面前装的一本正经，和直子独处时性情说变就变。他想努力改变自己，提高自己，却总不能如愿，又着急又伤心，直到最后打磨完自己的信心，自杀了事。 直子不正常。 一方面在于生理的缺陷。如果木月没死，她和木月是会在一起过一辈子的。她痛苦的是，她和木月没有真正意义上地体会过一对相爱的男女在一起做爱的快感，每当谈及这个问题，直子都啜泣不止。 虽然她心里爱着木月，和木月接吻的感觉也很妙，但是到关键时刻就是打不开，不知道尝试了多少回，可就是不成功，下面一点也不湿润，又干又痛，只能用手指和嘴唇来安慰木月。 但二十岁生日的那个晚上，和渡边在一起却湿润得一塌糊涂。身体和心灵想着不同的男人，连她自己都弄不清这到底是怎么回事，这种矛盾的羞耻感一直难以释怀。 另一方面，跟她同样也不健全的姐姐有关，她姐姐有时一连几天关在家里闭门不出，最后上吊自杀，至于为什么，谁也弄不明白。和木月一样，事件发生前没有任何前兆。 看着姐姐僵死在那里，直子一动没动，一句话都没说，好像毫无知觉了。或许，在很小的时候，直子和她姐姐就患有某种程度上的精神抑郁症。 玲子不正常。 年轻的时候她本可以做一个出色的钢琴弹奏家，突然就手指完全失去感觉，赋闲在家教一个十三岁聪明而富有心计的女孩学弹琴，未曾想那女孩是个同性恋，学着学着把玲子睡了。 女孩子的爱抚比她老公的感觉还舒服，让玲子一度怀疑自己是同性恋者。她自杀未遂，和丈夫离婚，来到了这里，一呆就是七八年，她害怕和外面的世界再发生关系，怕见各种人，怕想各种事。 可惜，不健全的木月和直子的姐姐，在旁人发现他们的不正常之前，就带着缺陷猝然离世，没有机会在阿美寮医院接受疗养。 死了的人一只都是死的，但直子和渡边还要活下去。她又不想因为她的病拖累了渡边： 我是个比你想的要不健全得多的人，我病的时间比你想的要长久的多，根也深得多。所以，如果你能往前行的话，希望你只管一个人前行就是，别等我。想和其他女孩子睡觉就睡好了，别考虑我顾忌我，喜欢什么就尽情做什么。要不然，我说不定会拖累你。我，不管发生什么，这事是绝对不想做的。不想耽误你的人生，也不想耽误任何人的人生。我只希望你时常来看我，永远记着我——我希望的只是这个。 现在似乎开始明白，村上开篇说的那个「永远不会忘记」的诺言是怎么回事了。]]></content>
      <categories>
        <category>挪威的森林</category>
      </categories>
      <tags>
        <tag>疗养院</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿美寮的三段言情戏]]></title>
    <url>%2F2016%2F11%2F24%2F%E9%98%BF%E7%BE%8E%E5%AF%AE%E7%9A%84%E4%B8%89%E6%AE%B5%E8%A8%80%E6%83%85%E6%88%8F%2F</url>
    <content type="text"><![CDATA[《挪威的森林》不得不说的三场言情戏。 1 久别独聚醒来就看到喜欢的女孩子注视着自己的脸，这等含情脉脉换做谁都会融化。 我，在三人一起见面前想单独看你一眼。也不是有什么话非说不可，只是想看看你的脸，习惯一下。要不然会觉得不习惯，我这人笨的很。 这部分内容虽只写了短短一页，却让读者有一种无以名状的甜蜜和温馨，足见村上营造情绪的功力。 2 浪漫月夜直子、渡边、玲子围烛而坐，恍若世界的角落里只剩下他们三人。月影悄无声息，烛光飘忽不定，把酒同欢，吉他弹舞曲，美人相伴，文艺小清新梦幻般的浪漫满屋。 半年时间，直子的娇美已开始带有成熟女性的风韵，她的娴静荡漾着一股给人以亲切和抚慰之感。 那天晚上，渡边分不清到底是置身梦境还是如临其境，直子裸露着身子站在他床边：她腰间美丽的曲线、丰满而光洁的乳房、随着呼吸静静起伏的平滑的小腹，以及下面软软的黑黑的毛丛。 3 绿茵藏艳第二天，渡边和直子二人到山上的草地里像之前那样胡乱地走着。两颗迫不及待的灵魂终于可以在一起互诉衷肠了，村上给他们来了段小黄文～ 想和我睡？自然。能等？当然等的。现在变硬了？脚底板？傻瓜……那滋味，不好受？什么？冲动啊。就是憋的不舒服。给你放出来好吗？用手？嗯。 他们抱在一起，淹没在草丛中，除了天空、白云，什么都看不见。 这三段感情戏，或虚或实，由浅至深，把渡边和直子俩人的思念化作触手可及的恋人间的你侬我侬，剧情需要，其中不乏露骨的性描写，为广大书迷所钟爱。渡边在阿美寮疗养所和直子相处的这短短两天，在 133 分钟的未删减版电影中，足足演绎了近半个小时，这也是全书中最唯美、最值得一读再读之处。]]></content>
      <categories>
        <category>挪威的森林</category>
      </categories>
      <tags>
        <tag>纯爱</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[他又出去约了]]></title>
    <url>%2F2016%2F11%2F23%2F%E4%BB%96%E5%8F%88%E5%87%BA%E5%8E%BB%E7%BA%A6%E4%BA%86%2F</url>
    <content type="text"><![CDATA[渡边经常会想起和木月在一起的日子，没有木月，他甚至会感到孤寂。 逝者，对于生者到底是个什么样的存在？或者说，谈不上存在，因为那肉身已化糜烂。但那偶尔浮现的往日在一起的记忆，却依旧会在某个不经意的瞬间让生者悸动。 小说才开始前半部分，村上已经谈死谈了好几次了。我似乎敏感地预感到《挪》书中的人物，莫非都会一个接一个地没了？就像木月之死，猝不及防。因为这本书，村上一开始就说「献给许许多多的祭日」。 虽说我同意「死作为生的一部分永存」，但青春不该是这么阴沉悲伤，它就该像绿子那般灿烂灵动。 日本作家都喜欢绞尽脑汁来悲天悯人，不搞出几个虐恋的故事，怎么好自称伤痕文学？爱，直至成伤，是他们一贯的套路。 当然，村上还没打算这么早就让他们一个接一个地死去，作为本书的主人公，渡边还要经历不少人不少事。 这不，他改不了的约炮陋习，又开始蠢蠢欲动了。 永泽找他去泡妞，这一次，一晚上，俩人一无所获，整个城市找遍所有的酒吧，他们愣是一个都没约成功，一！个！都！没！有！ 俩人各自告别后，渡边在早餐店邂逅了两个女孩子，其中一个因为男朋友出轨，悲痛不已，她要报复男朋友，于是和渡边开房去了。 女孩子的指甲死死地抠紧渡边的后背，高潮时喊了十六次那个渣男的名字…… 事后，渡边找这样的托词来辩白：「其实双方都不特别想一起睡觉，只是如若不睡，事情便无法收场」。 我强烈鄙视这样的狡辩。 无耻之徒，乘人之危，骗色骗炮。谁说不睡就不能收场？陪人家喝点酒，聊聊天，等她睡一觉恢复理智就好了，渡边君你可以一个人打开电视看球赛啊？或者继续发扬你国把女的绑起来自己专心致志地擀面条的优良传统啊……不想睡还睡？什么人啊，依他的德性，只要是个女人，他一精虫上脑，照样就睡了。 他妈的！敢做不敢当，就不能像林丹那样光明正大地承认错误？]]></content>
      <categories>
        <category>挪威的森林</category>
      </categories>
      <tags>
        <tag>林丹</tag>
        <tag>约炮</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[女追男 | 奇特的邂逅]]></title>
    <url>%2F2016%2F11%2F22%2F%E5%A5%B3%E8%BF%BD%E7%94%B7-%E5%A5%87%E7%89%B9%E7%9A%84%E9%82%82%E9%80%85%2F</url>
    <content type="text"><![CDATA[兴趣是结交好友的桥梁，也是搭讪的好手段。 《了不起的盖茨比》让渡边成了永泽的朋友，戏剧史Ⅱ，让绿子注意上了他。 渡边在一家饭店吃午饭时，绿子主动来搭讪。绿子给渡边的印象是，一个热情奔放，活力无限的短发女孩，简直就像刚刚迎着春光崩掉到世界上的一只小动物，这和娴静、文雅的直子形成了强烈对比。 绿子欣赏渡边独来独往一切看似无所谓的言谈举止方式，渡边则说，「哪里会有人喜欢孤独！不过是不乱交朋友罢了，那样只能落得失望」。 有一次，绿子带渡边来到她就读的高中，她其实打心眼里不乐意去那所学校读书的，里面的女生都非富即贵，而她家不过靠经营一个小书店维生。绿子是个很倔强的女孩子，一般不喜欢读书的女孩子用的是逃课这种伎俩，她则把内心的逆反通过这样一种看似妥协的方式来表达：「因为我讨厌学校讨厌得要死，所以才一次课都没旷过，心想怎么能败下去！即使高烧三十九度也照样去学校」。 绿子和渡边交谈起来也是无所顾忌： 学校院子里冒的白烟被她说成是在烧女生用完扔在垃圾桶里的卫生巾。 她说她家书店脱手最快的就是《妇女杂志》，附近的太太们把它买回家，背得滚瓜烂熟等丈夫回家演习。那东西真是黄的可以，附录中带有四十八种性姿势插图，鬼知道这世上的太太们每天想的是什么！ 住在这里的人是不是都打飞机啊？男的手淫和女孩子来月经是同一码事。 绿子约渡边星期天去她家玩，给他做了顿午饭吃。由于绿子家人忙于事务都不愿意做饭，绿子靠自学居然烧得出几个关西风味的好菜，让渡边 surprised 了一把。 她们家大人连厨具也不舍得买，绿子只得用买胸罩的钱买了一个煎蛋锅，结果有三个月她都是带着半湿不干的胸罩出门，册那！ 自古情人眼里出西施。在绿子看来，渡边别具一格的说话方式好讨人喜欢，她倾慕于渡边身上那种「不情愿被某种东西束缚住」的特质。她本人也怎么不在乎别人的看法，照样吸不适合女孩子的万宝路烟，灭烟姿势粗鲁得像砍柴女…… 这个下午，渡边和直子在晾衣台上看外面火灾的热闹，幸灾乐祸地对着不远处起火的地方唱歌、喝酒，对周围的事来个不屑一顾。 绿子坦白她对爱感到饥渴，「真想完完全全得到一次爱——哪怕仅仅一次也好，一次就行，只消一次，然而，不论是家人还是男朋友，他们竟一次都没满足过我。我下定决心，一定要找个百分之百爱我的人」。 她所追求的严格意义上来说不是那种完美无缺的爱，只是要容许她任性，百分之百的任性，这就足够了。 比方说，我现在对你说想吃草莓蛋糕，你就什么也不顾地跑去买，气喘吁吁地跑回来递给我，说「喏，绿子，这就是草买蛋糕」。可我又说「我已经懒得吃这玩意了！」，说着「砰」一声从窗户扔出去。这就是我说的真爱。 看完了热闹，俩人有些疲惫，一切那么自然地，四目相对，悄无声息地吻了五六秒钟。 渡边这样解释道，在午后的阳光下坐在晾衣台上喝着啤酒观看火灾，从吵吵嚷嚷到现在大街上的空空荡荡，他们一起感受到了某种情绪的高潮和低谷，无意中想以某种形式将其存留下来。 那吻的感觉是温柔而安稳的，但不知其归宿，甚至对都有交往对象的彼此来说，是包含某种危险的吻。]]></content>
      <categories>
        <category>挪威的森林</category>
      </categories>
      <tags>
        <tag>绿子</tag>
        <tag>女追男</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[男人啊，就这副德性？]]></title>
    <url>%2F2016%2F11%2F21%2F%E7%94%B7%E4%BA%BA%E5%95%8A%EF%BC%8C%E5%B0%B1%E8%BF%99%E5%89%AF%E5%BE%B7%E6%80%A7%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[因为被发现读《了不起的盖茨比》，渡边成了永泽这个富家子弟的朋友，永泽也成了渡边在宿舍楼里唯一的朋友。 永泽说：「通读三遍《了不起的盖茨比》的人，倒像是可以成为我的朋友。不是说我不相信现代文学，我只是不愿意在阅读未经过时间洗礼的书籍上面浪费时间，人生短暂」。 他极具个人魅力，天生具有那种吸引人、指使人的气质，他睡过七十多个女人，曾一次生吞过三条蛞蝓。 在渡边眼里，他是个矛盾的人：既有令人赞叹的高贵精神，又是个无可救药的时间俗物；可以春风得意地率领众人长驱直进，而那颗心，同时又在阴暗的泥沼里孤独的挣扎。 在渡边眼里，他还是个诚实的人，他对渡边始终亲切如一，生活上给予诸多关照。可以说，永泽真心把渡边当朋友，而渡边因而忍受不了他「醉后想方设法捉弄女孩子」，因而不肯对他像对木月那样交心相待。 渡边其实有那么点虚伪，他一方面认为永泽和女孩子睡觉并非出于真心，纯粹是泄欲的把戏，并自我标榜： 我自己其实不大喜欢同萍水相逢的女孩同床共衾。作为疏导情欲的一种方式，固然惬意，而且同女孩相互拥抱着触摸身体也颇为开心。但厌烦的是早起后房间的凌乱、情绪的昏沉、和道德上的自我厌恶、幻灭之感。 其实，我们知道，后来渡边还是因为忍受不了生理的饥渴而继续出去睡女孩子了，即使和直子以及后来出场的绿子处于恋爱期，这种事也从没断过。 有了女朋友还约炮，日本年轻人在六七十年代对「性」就是这个态度啊？ 他也算承认了私生活上的自我堕落，事后都羞愧不已： 我这是干的什么事？不由得一阵心灰意冷，我想我不应该干这等勾当，然而又不能不干，我的身体十分饥渴，巴不得同女人睡觉。而我同他们睡觉的时候又总是想着直子，想直子黑暗中白嫩嫩浮现出来的裸体，想她的喘息，以及外面的雨声。而且越想越觉得身体饥不可忍，渴可不耐。 腰间挂着两颗滚烫的肾，男人啊，就这副德性。 渡边向永泽探讨了关于睡女孩子一事，永泽像是在回答知乎上那个：「性对男人到底有多重要」的问题，或者说得更确切一点「性对青春期的男人到底有多重要」。 「这种事连续干过七十多次，是否会觉得空虚？」 「如果你觉得空虚，说明你是正人君子，可喜可贺」，他说，「和素不相识的女孩睡觉睡的太多，终归是徒劳无益，只落得疲惫不堪，自我生厌，我也一样。」 「那你为什么还那么卖力气？」 「很难解释。对了，你知道陀思妥耶夫基在一本关于赌博的书里说过，在周围充满可能性的时候，对其视而不见，是非常困难的事。你明白吗？傍晚，女孩子们走上街头，在那一带东游西逛，饮酒消遣。她们是在寻找某种东西，而这种东西我们又可以提供。这是再简单不过的买卖，就像拧开水龙头喝水一样。我们转瞬间就可以发泄，而对方又求之不得。这就是所谓的可能性。这种可能性就在眼前来回晃动，难道你能视而不见？自己具有这种能力，又有发挥这种能力的场所，你能默默通过不成？」 村上似乎想借永泽这个人物来剥落出普通男人身上的一些原始隐藏的欲望或者暗面吧，亦或通过永泽来传达出另外一个社会阶层的人的世界？ 永泽是个怎样的人，后续村上会怎样刻画使这个人物形象更丰满，拭目以待。]]></content>
      <categories>
        <category>挪威的森林</category>
      </categories>
      <tags>
        <tag>永泽</tag>
        <tag>约炮</tag>
        <tag>了不起的盖茨比</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[木月之死和黑暗中的裸体]]></title>
    <url>%2F2016%2F11%2F20%2F%E6%9C%A8%E6%9C%88%E4%B9%8B%E6%AD%BB%E5%92%8C%E9%BB%91%E6%9A%97%E4%B8%AD%E7%9A%84%E8%A3%B8%E4%BD%93%2F</url>
    <content type="text"><![CDATA[直子是木月的恋人，渡边是木月的好友。 三个人经常外出游玩，谈天说地，不知道欢聚了多少次。 每当木月暂时离开和直子独处时，渡边便显得坐立不安，他和直子谈不上三言两语，双方都不晓得从何谈起，只能一声不吭地喝水或者摆弄桌面上的东西，等待木月到来。 毫无征兆地，一个夜里，木月在自家车库自杀了。 木月死后到高中毕业的十个月时间里，渡边无法确定自己在周围世界中的位置，他结交了一个女孩子，同她睡过觉，但不到半年便分手了。 以前他认为： 死迟早会将我们俘获在手，但反言之，在死俘获我们之前，我们并未被死俘获。 十七岁那年五月的一个晚上，死俘获了木月，同时也俘获了渡边。 木月之死，给渡边带来了永无休止的圆周式思考，在活得好端端的青春时代，居然凡事都以「死」为轴心，旋转不休。 随着时间的推移，他的生死观开始以清楚而简单的轮廓呈现出来： 死并非生的对立面，而作为生的一部分永存。 高中毕业后，渡边到东京上大学，住进寄宿舍开始新的生活。 有一天，他和直子在一列电车里不期而遇。 差不多有一年没见到直子了，直子瘦成了另一个人。 原先别具风韵的丰满脸颊几乎变得平平的，脖颈也一下细了好多，但她的瘦削丝毫不给人以骨感啦不健康啦那类印象。她的瘦法看上去非常自然而娴雅，简直就像在某个狭长的场所悄然藏身体型自然变得纤细起来一样。 俩人漫无目的地散步，渡边跟直子讲述在寄宿舍里莫名其妙的生活：庄严的升降国旗仪式，满是男人的邋遢宿舍，贴在墙上的美人照，口吃、有洁癖、对着收音机做广播体操的敢死队…… 他们差不多每周日都幽会，就这样没完没了地在街头上行走不止，在空漠中寻求语言。 俩人开始彼此逐渐地依顺，心照不宣地避免谈及过去，尤其是木月。 每当冷风吹过，直子下意识地挽起渡边的手臂时，渡边觉得：「她所希求的并非是我的臂，必然是某人的臂，她所希求的并非是我的体温，而是某人的体温，而我只能是我本身，于是我总觉得有些愧疚」。 渡边认为，直子仍纠结于木月的死，她把对木月的感情诉移驾到渡边身上。然而，渡边他只能是他自己，无法像木月对直子那样来对待直子。 在直子二十岁生日的雨夜，渡边和她睡了。黑暗中，白嫩嫩浮现出来的裸体，她凄楚的喘息，以及外面的雨声…… 事后渡边犯了几乎每一个不自信的情场小白都会犯的错误，他问直子为什么没有和木月睡过，直子啜泣不止。 第二天直子悄无声息地搬走了，不知去向。 渡边给她寄信希望和她好好谈谈，等她的回信。直子过了几个月才回信说她因为得了重病在一个精神疗养院接受治疗，眼下还没有做好继续见面的准备，待准备完成了，才可以继续加深相互的了解。 渡边想起直子注视他时那透澈的眼睛，那仿佛在寻觅着什么东西的眼神，每次读信都觉得不胜自哀，这种百无聊赖的心情，既无法排遣，又不能藏匿，如此这般苦苦纠缠。]]></content>
      <categories>
        <category>挪威的森林</category>
      </categories>
      <tags>
        <tag>木月</tag>
        <tag>直子</tag>
        <tag>渡边</tag>
        <tag>自杀</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[希望你永远记住我]]></title>
    <url>%2F2016%2F11%2F19%2F%E5%B8%8C%E6%9C%9B%E4%BD%A0%E6%B0%B8%E8%BF%9C%E8%AE%B0%E4%BD%8F%E6%88%91%2F</url>
    <content type="text"><![CDATA[村上村树在 38 岁还拖着一点青春记忆尾巴的时候写了一部现实主义的恋爱小说，小明在快到 30 岁的时候才第一次读它。 今天翻看了第一章，趁着记忆还是新鲜的，写点文字留存。 日本的作家大都属于阴冷派，《挪》开篇也充斥着一股抑郁，阴沉，感伤的文艺气息。 37 岁的渡边君想起自己在过去的人生旅途中失却的许多东西，蹉跎的岁月，死去或离去的人们，无可追回的懊悔。 他能清晰地回忆起十八年前的那片草地：草的芬芳，风的微寒，山的曲线，犬的吠声……但，那可贵的东西：直子和当时的他以及他的世界，却无从想起。 他偶尔能想起直子的面容： 那冷冰冰的小手，那流线型泻下的手感爽适的秀发，那圆圆的软软的耳垂，以及紧靠其底端的小小黑痣，那冬日常穿的格调高雅的驼绒大衣，那总是定定地注视对方眼睛发问的惯常动作，那不时奇妙地发出微微颤抖的语声。 随着记忆逐渐模糊，为了显示对直子做出的「永远不会忘记」的诺言，村上抓住这些已经模糊并且时刻模糊下去的记忆残片，来创作这篇小说。 本章最后一句： 想到这里，我悲哀得难以自禁。因为，直子连爱都没爱过我。 咋一看，让人看得莫名其妙，刚才还缅怀恋人，现在就开始埋怨人家了。 在小明看来，这分明就是个文学创作套路嘛，好比中国古典小说里经常出现的那句「欲知后事如何，且听下回分解」。 村上这个老司机，于不经意处挑起了悬念。]]></content>
      <categories>
        <category>挪威的森林</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[看完这本书，你会比 95% 的中国人更懂中国]]></title>
    <url>%2F2016%2F11%2F17%2F%E7%9C%8B%E5%AE%8C%E8%BF%99%E6%9C%AC%E4%B9%A6%EF%BC%8C%E4%BD%A0%E4%BC%9A%E6%AF%94-95-%E7%9A%84%E4%B8%AD%E5%9B%BD%E4%BA%BA%E6%9B%B4%E6%87%82%E4%B8%AD%E5%9B%BD%2F</url>
    <content type="text"><![CDATA[这几天，下班后在家把《论中国》这本书看完了。这本书我2014年就买了，结果应了那句“书非借不读”，当初买了后，只稍微翻了翻就把它扔在家中某个犄角旮旯里。直到最近，川普选上了美国总统，眼看着中美关系将迎来最大波折，才想起看这本书来。 既然看完了，我就记录下阅后心得，权当作一篇读书笔记，不然，这书跟没读差不多。 作者是美国当代大名鼎鼎的外交家、国际问题专家亨利·基辛格。这本书依据他与四代中国领导人的谈话记录，主要讲述了自从新中国成立后，中美两国领导人之间的相互往来，它试图解释中国人对战争与和平、国家秩序等问题的理性思考，以及这种思考与美国人更为实用的、就事论事的思维方式的关系。 对中国的看法在历史意识中，中国是一个只需复原，而无须创建的既有国家。 中华文明的一个特点是，它似乎没有起点。中华文明不是作为一个传统意义上的民族国家，而是作为一种永恒的自然现象在历史上出现。 中国的光荣孤立在人类历史上独一无二，酝酿了一种独特的自我意识。中国的航海技术曾居世界之首，但并不热衷探险和征服，因而错失了海外扩张的良机。 中国与周边国家的疆界与其说是政治和领土的分界线，不如说是文化差异的分水岭。 中国它从未宣扬过美国式的普世观并借此在世界各地传播自己的一套价值观，而是仅把注意力放在驾驭近邻的蛮夷上。 中国挟其独特的传统和千年养成的优越感步入近代。这个独特的帝国声称它的文化和体制适用于四海，却不屑于去改变异族的宗教信仰；它是世界上最富饶的国家，却对与外国通商和技术革新漠不关心；它文化发达，却受制于一个对西方探险时代的来临一无所知的政治统治集团；它在辽阔的疆土上建立了一套政治体系，却对即将威胁其生存的技术文化大潮茫然无知。 为改变当时中西方交往方式，大英帝国派遣马嘎尔尼使团做了一次最著名、最友善和最不“炫耀武力”的访华努力，目标是取得通商贸易和建立外交关系，但由于东西方观点的巨大分歧，这次访问最终一无所获，结果是中国继续闭关锁国。英国在拿破仑战争结束后暂时休整，没过多久，就以“鸦片输送”这种可耻的借口，凭借着坚船利炮把中国的大门轰开了。中国由此遭受了西方列强一百多年侵略的屈辱史。 眼中毛泽东 尽管毛泽东的许多思想和做法在中国历史中都有迹可寻，但历史上从来没有哪一个执政者能像毛泽东那样集传统、权威、冷峻和全球视角于一身。他面对挑战时咄咄逼人，但当环境不允许他按照自己的心意行动时，他就灵活地转而采用外交技巧。他的外交政策虽然借用传统手法，但是影响宏大，立意大胆。 毛泽东制定外交策略常从中国经典古籍中，即他表面上鄙视的中国传统中汲取灵感。在制定外交政策举措时，他所参考的通常不是马克思主义理论，而是中国的古典著作。他把古代士大夫贬为压迫者和寄生虫，却和他们有着相同的兴致，喜好作诗填词，并对自己豪放的大草书法艺术深以为傲。 毛泽东热衷于搞革命，意识形态挂帅,他的革命理论可以用这这段哲学观点来概括：“不平衡是普遍的客观规律。从不平衡至平衡，又从平衡到不平衡，物质循环不已，永远如此，但是每一循环都进到高的一级。不平衡是经常的、绝对的；平衡是暂时的、相对的。” 这里，我举个最令对手毛骨悚然的例子来说明下毛泽东对革命无畏到何种程度。 1957年，在莫斯科召开的社会主义国家会议上，毛泽东对赫鲁晓夫的“社会主义阵营要努力和资本主义世界和平共处”政策给予了异常尖锐的驳斥，他在会上号召所有社会主义国家拿起武器同帝国主义进行斗争，并再次宣布中国不惧核战争，他声称“我们不要怕原子弹和导弹，无论爆发什么样的战争，常规战或热核战，我们都会胜利，如果帝国主义对中国发动战争，我们也许会受伤，但那又怎么呢？战争嘛，过几年我们会努力生出更多的孩子来”。当时听到他讲完话后，捷克斯洛伐克的共产党总书记说”我们怎么办？我们这个斯洛伐克只有1200万人。打起仗来都得死光，哪有人留下来重新开张？” 眼中周恩来 周恩来是我在六十年来工资生涯中遇到过的最有魅力的人，他个子不高，风度翩翩，目光炯炯，表情丰富，他能以他的超人的智慧和能力压倒谈判对手，能凭直觉猜到对方的心理活动。 他成为了毛泽东与人民群众之间重要的纽带。他把毛泽东的远大理想化为具体计划，同时他还因为给毛泽东的过激之处降温，至少是在毛泽东满腔豪情容许的范围内尽可能这么做，而赢得了很多中国人的感激。 在任何聚会中，毛泽东总是以其气势令举座注目，而周恩来则给人带来光明和温暖。毛泽东的满腔豪情会让反对者慑服，而周恩来会以其智慧力求以理服人和以智取胜。毛泽东说话尖锐犀利，周恩来说话则鞭辟入里。毛泽东喜欢将自己看作哲学家，周恩来则自认擅长行政管理或谈判。毛泽东致力于加快历史前进的速度，周恩来则善于乘时乘势。他常说“舵手必须懂得该怎样驾驭风浪”。 眼中邓小平 在习惯了毛泽东的哲学宏论和形象比喻，以及周恩来儒雅庄重的职业精神之后，面对邓小平言语辛辣、单刀直入的作风，偶尔犀利反讽的插话，不喜欢空谈理论，而习惯着眼于极度实际问题时，我花了相当一段时间才把自己调整过来。 他个子矮小，身体结实，进屋时就像有风力相助，坐下来就直切正题，他很少在寒暄上浪费时间，也觉得没有必要像毛泽东那样以寓言为包装来掩饰锋芒，邓小平不像周恩来那样让你有一种亲切感，也不像毛泽东那样把我视为哲学同道，他的态度是“我们都是为了自己的国事而来，又都是成人，对小小不言的摩擦不该介意”。周恩来有英文基础，偶尔也会说几句，邓小平则自称是土包子。 随着时间的推移，我逐渐对这位眼神忧郁，曾几度大起大落，却仍矢志不移，顾全大局，并在日后逐步振兴中国的强悍的小个子，产生了无比的敬意。 他公开强调中国的落后（长得丑却要打扮得像美人一样，那是不行的），强调中国需要向别国学习，这与中国的皇帝和官员与外国人打交道时表现出来的傲慢形成鲜明对比：没有一个中国统治者对外国人说过需要外国的东西。清廷接受了有限的外国创新，但一贯坚持所有外国人通商是为表现中国的仁善，而非中国所需；毛泽东也高度强调自力更生，即使因此使中国陷入贫穷和孤立。 眼中江泽民 他被普遍认为是过渡性人物，与前辈相比，他没有统帅一切的光环，权力基础也相对较少，他是第一位没有军事资历的中国共产党领导人，像其继任者一样，他的领导能力来源于政治履历和经济业绩。 以前的中共领导人，为人处世带有伟人的光环，既有新型马克思唯物主义的风格，也有中国儒家传统的痕迹，江泽民则不同，它更像一位平易近人的家人，热情而不拘礼节。 就对话风格而言，毛泽东是从奥林匹亚山巅俯视谈话对象，好像面对正在考试的研究生，考察他们的哲学见解恰当与否。周恩来谈话轻松优雅，充满儒家圣人般的智慧。邓小平会打断讨论，直奔主题，视离题寒暄为浪费时间。 江泽民温文尔雅、精力充沛，他时而面带微笑，时而放声大笑，讲逸闻趣事，感染谈话对象，他为自己的外语天赋和西方音乐知识感到自豪，时常为此兴高采烈。接见非华人来访者时，为了强调一个论点，他讲话中经常夹杂着英语、俄语甚至罗马尼亚词句，时而不经意间在大量中国古典成语与美国俗语间转换，如果场合允许，他可能会放声高歌来调节气氛，或者强调同志之间的友情。 中国的战略中国的战略一般有三个特点：精心分析长远趋势，仔细研究战术选择，冷静探讨行动方案。他们的领导人可能会决策失误，但鲜有考虑不周的例子。 中国强盛时，其外交体现为在意识形态上捍卫帝国权力的合理性；衰微时，外交则用来掩盖其弱点，帮助中国利用彼此争斗的各种势力。 西方传统推崇决战决胜，强调英雄壮举，而中国的理念强调巧用计谋及迂回策略，耐心累积相对优势。 中国和西方外交战略的首要区别在于劣势中的自处之道。美国和其他西方国家的外交官认为应谨慎行事，避免挑衅，中国则更倾向于摆出更加无谓的姿态。面对于己不利的力量对比，西方外交官倾向于寻求外交解决，他们敦促采取外交举措，陷对方于不义，以求在道义上孤立对方，但不主张使用武力。中国的战略规划者却更坚定决心用勇气和心理压力来对抗敌人实力上的优势，他们相信先发制人的威慑，若是敌人优势太强，而且战略趋势于己不利时，它们的应对方法是打击敌人的信心。 中国政治家对待结盟的态度：不组成联盟却作为盟国国一起行动，这把现实主义发挥到了极致，如果所有领导人都具有足够的战略眼光、深思熟虑的话，他们都会达成同样的结论，结盟等于多此一举，战略分析的逻辑即足以促使有关国家向同一方向努力。 大多数中国领导人认为中美之间建立正式联盟没有必要，而且总的来说在推行外交政局时还会累赘碍事，他们愿意依靠相互之间的心照不宣。 三角关系毛泽东一直在与苏联竞争意识形态上谁执牛耳和地缘战略分析上谁更正确，这两个社会主义国家因此绝不可能因他们各自对美国的敌意而走到一起。 冷战和核武器的巨大破坏性，在西方催生了“威慑”这一概念，但毛泽东认为西方的威慑可能过于消极，他绝不会让中国被动地等着挨打，而是要争取主动。在某种层面上，和西方先发自人的概念有相似之处，不过根据西方的理念，先发制人的目的，是取得胜利的军事优势，毛泽东先发制人的不同之处在于他对心理因素的高度重视，他先发制人的主要目的不是为了抢先进行决定性打击，而是为了改变双方的心理平衡，不是为了打败敌人，而是为了为了调整他所评估的各种风险。 中国在 1954-1958 年的台海危机中的行动，1962 年和印度的边境冲突，1969-1971 年在乌苏里江与苏联的冲突，以及 1979 年的中越边境之战，都有一个共同的特点：突然实施军事打击，马上继之以政治层面上的动作。 中国式先发制人，一旦遭遇西方的威慑，可能会产生恶性循环，中国自认为是防御性的举动，可能会被西方世界视为侵略性的，而西方的威慑行为则可能被中国解读为对它的包围，在冷战期间，美中两国就此纠缠不休，迄今为止，两国在某种程度上仍未摆脱这个恶性循环。 从传统强权政治的观点来看，中国当然无法和三角关系的美苏两方平起平坐，但是，他把核超级大国之间的敌意为己所用，给外界造成无惧核毁灭的印象，因而为中国谋求了一种外交保障。毛泽东不寻求其中一个超级大国的保护，而是利用美苏彼此的戒惧来同时反抗他们两国。 在冷战的两个关键时刻，中国政治家在军事上敌强我弱的情况下，成功地实施了它进攻性威慑的理念，从而实现其长期的战略大目标。1958 年的台海危机和 1979 年的对越作战，中国领导人都在即将采取行动之前，成功地使外界以为他的行动得到了一个超级大国的同意，从而吓阻另一个超级大国插手干预，把“空城计”运用得如火纯青。 那次事件在改革计划的头十年里，中国除了有成功的狂喜外，还遇到了一些挫折。从计划经济过渡到更大程度的权力下放，始终受到来自两方面的威胁：主张维持现状的既得利益者的抵制、因改革进程缓慢而心急的激进者的压力，以及经济权力下放导致要求政治决策多元化。 中国历史上，尤其是近两百年的历史上，有无数的例子证明，政权的四分五裂，有时是因为对更大自由的极大期待，往往导致社会和族裔的剧烈动荡，而最后胜出的一方往往不是最开明的一派。 在这种背景下，学生并不想对他们晓得是一个危险的政权提出致命的挑战，这一政权也不情愿对学生动武，双方有很多共同的目标，有共同的语言。但由于沟通不畅和错误的判断，各自将对方逼到越来越不可能妥协的境地，有几次似乎马上就找到了解决办法，但最后关头又溜走了。最初滑入灾难的速度似乎很慢，但随着双方分歧的加深，这一速度随之加快，在已知最终结果的今天，重温这一事件给人们带来的震撼不亚于从真正的悲剧中感受到的震撼。 如何谴责他们认为错误的行为并做出适当的反应，与此同时，又保持与中国的接触，即使这种关系必须暂时“搁置起来”，布什总统面对此窘境，可运作的空间也极为有限。布什坚信维护美中关系的长期发展无比重要，但他不能不尊重美国人民的情感，他们要求本国政府以某种具体方式表达他们的不赞成。 中国领导人坚持认为这是内政，美国政府则认为是人权的亵渎。双方都有道理，邓小平感到自己的政权四面受敌，布什则认为美国根本的价值观受到了挑战。 随着东欧剧变，苏联解体，多个共产党政府垮台，中国的改革受到国内动荡和国际压力的双重威胁。邓小平本可轻而易举地靠煽动民族主义感情去号召本国人民，但他没有这样做，而是求助于古老的价值观。邓小平给他的接班人和下一代领导人留下 24 字工作指示。 中美分歧中国领导人主张独立自主，不干涉他国内政不向国外传播意识形态，而美国坚持通过施压和激励来实现价值观的普适性，也就是要干涉别国的内政。 美国自建国以来笃信自己的理想具有普世价值，声称自己有义务传播这些理想，这一信念常常成为美国的驱动力。中国行为的依据是其独特性，它通过文化渗透而非传教狂热来扩大影响。 与美国打交道的国家需要懂得：美国对事物的判断，永远不可能与美国对民主制度的看法分开，有些事件必然会引起美国的反应，即使会损害总体关系也在所不惜。 在某些事件面前，美国的外交政策会超出对国家利益的考虑，没有任何一个美国总统可以对这类事情视而不见，但在界定这些事情是他必须小心谨慎，而且要知道意外后果的要义。任何一位外国领导人都不应对此不屑一顾，如何界定这类事件并建立平衡，将决定美国对华关系的性质，可能也将决定世界的和平。 对中国而言，美国太强大难以胁迫，而且致力于与中国发展建设性关系，中国也需要这种关系，超级大国美国、充满活力的中国，全球化的世界，以及世界事务重心逐渐从大西洋向太平洋转移，都需要一个和平合作的中美关系。但他们不能控制两国相互撞击的方式，这是中美关系中尚未解决的挑战。 进入 21 世纪以来，中国与现代西方国际体系的碰撞，在中国精英中间引发放了一个特殊趋势，他们全面的分析、辩论国家命运及其实现之道。以前的国家命运辩论讨论的是，中国是应该向外寻求知识以摆脱虚弱，还是应该眼光向内已远离技术先进但动机不纯的世界，而当前阶段辩论的重点则是，在认识到自立自强的伟大工程迈向成功，中国正在赶超西方的大背景下，确定中国与世界交往的条件。 历史会重演吗？21 世纪中美关系的预兆，和 20 世纪英德两国对抗的史例，看起来有战略相似性。 19 世纪末期，英德两国对抗是如何演进的？导致一战的危机是起因于德国崛起，引起了针对新的强大力量的某种有组织对抗，还是源于德国采取的一些具体的，因而也是可以避免的政策？危机是源于德国的能力还是德国的行为？ 克劳这样分析英国对德关系：不管德国崛起的目的是什么，是否显示足够的友好态度。其实德国崛起本身，就必然损害英国的利益。所以只要德国还在崛起中，对德国的外交围堵就必须加紧进行，这是零和博弈。换句话说，德国在一战前失去外交的灵活性，是德国国力不断增强必然导致英国的反制，与德国是否足够友好无关。 因此，克劳学派会认为中国的成功崛起与美国在太平洋乃至全世界的地位无法相容。 克劳学派把国际事务解读为不可避免的战略优势争夺，这种分析方式不仅限于西方的战略家，中国的必胜主义者运用了几乎是同样的推论。 基辛格不同意这类学派的看法，他的看法如下： 不同历史时期之间的比较重，本质上而言是不正确的，甚至最精确的类比，也不意味着当代人一定会重复前人的覆辙。 中美关系不必也不应成为零和博弈。重要的国际问题，在本质上是全球性的，达成共识可能非常困难等，但在这些问题上挑起对抗是自寻失败。 两个主角的内部演变与一战之前的形势也无法类比。 一个面对如此庞大国内任务的崛起国家，不太可能轻易投身于战略对抗或追求世界主导地位，大规模杀伤性武器的存在，再加上最终后果无法预知的现代军事技术，决定了今天与一战之前的时期明显不同。 基辛格认为，中美两国之间的决定性竞争，更可能是经济竞争，社会竞争，而不是军事竞争。中国和美国既合作又竞争，在许多方面共同发展。 尽管两国的出发点迥异，八位美国总统和四代中国领导人在处理微妙的双边关系时，却显示了惊人的连贯性，双方始终尽力维护这一实质性的合作关系，使之不受历史纠葛和各自国内问题的干扰。 中美关系的恰当表述应该是“共同进化”，而不是“伙伴关系”，这意味着两国都注重国内必须做的事情，在可能的领域开展合作，调整关系，减少冲突。任何一方都不完全赞同对方的目标，也不假定利益完全一致，但双方都努力寻找和发展相互补充的利益。 他呼吁建立太平洋共同体，中美彼此之间，以及和其他参加国家在其中拥有建设性关系。 亚洲，甚至世界的未来，将在很大程度上取决于中国和美国的远见，以及两国在多大程度上认同对方的地区历史角色。 1972 年，基辛格作为尼克松总统的特使秘密访华，周恩来总理和他就宣布中美联合公报达成一致时曾说“这将震撼世界”，在新世纪格局下，倘若中美两国能同心协力建设世界，而不是震惊世界，那将是何等大的成就？ 后记总的来说，这本正文有 500（除去文献引用的 100 多页）多页的大块头书，内容流畅而迷人，有历史细节，也有回忆反思，最重要的是对中国外交政策的前提、方法和目标做出了透彻审视。 看完这本书，你会比 95% 的中国人更懂中国。]]></content>
      <categories>
        <category>心旷神怡</category>
      </categories>
      <tags>
        <tag>看中国</tag>
        <tag>基辛格</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《半场无战事》观影]]></title>
    <url>%2F2016%2F11%2F12%2F%E3%80%8A%E5%8D%8A%E5%9C%BA%E6%97%A0%E6%88%98%E4%BA%8B%E3%80%8B%E8%A7%82%E5%BD%B1%2F</url>
    <content type="text"><![CDATA[「因为人生中最糟的一天而受到表彰，确实有点奇怪」，影片开门见山地点明了宗旨。 那 3 分 43 秒对林恩来说是最悲惨的回忆，班长中枪身亡，自己和敌人贴身肉搏，眼睁睁看着敌人被他用匕首插进心脏，双眼崩裂，血浆满地，窒息而亡。 班长的死，让他心痛；敌人的死，让他恐惧。战场的残酷无情给他造成了巨大的生理和心灵震撼，以至于他在家里听到母亲呵斥他姐姐时怒拍桌子的声音，都会歇斯底里地抽搐。 他不想再去回忆那悲惨的一天，他努力想寻求到认同感，不想再去感受那段心灵的痛创，然而，回到家后，他面临的却是一段段滑稽和无奈。 他的家人骄傲于整条街的人都在谈论他是个英雄；经纪人只想用他们的故事拍电影，大赚一笔；球场里那些工作人员、导演、球队老板表面拿他们当英雄，实际在赤裸裸地拿他们当工具；他最亲密的姐姐觉得是由于自己的原因，他才会被迫去伊拉克参军，想尽办法让他留下来。 所有人都在问林恩那一天发生的事情，有记者问他当时的体会，林恩无法躲避，只得无奈地向演出负责人要头痛药💊 也许看透了半场秀这样一个虚伪盛大的假象，或许是人们只在乎他们对所谓英雄主义的投射，无法体会军人本身在战场上的切身感受，这种错位和反差，最终让林恩和他的战友们重返战场，回到那个他们称作为家的地方。 由于大陆目前只在北京和上海有两家 120 帧的放映设备，很想体验下120帧每秒是什么样观影效果。 所以，要不去魔都再看一遍？]]></content>
      <categories>
        <category>心旷神怡</category>
      </categories>
      <tags>
        <tag>李安</tag>
        <tag>比利·林恩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我作为一个地产商怎么把我选到白宫去了]]></title>
    <url>%2F2016%2F11%2F09%2F%E6%88%91%E4%BD%9C%E4%B8%BA%E4%B8%80%E4%B8%AA%E5%9C%B0%E4%BA%A7%E5%95%86%E6%80%8E%E4%B9%88%E6%8A%8A%E6%88%91%E9%80%89%E5%88%B0%E7%99%BD%E5%AE%AB%E5%8E%BB%E4%BA%86%2F</url>
    <content type="text"><![CDATA[那么人呐就都不知道，自己就不可以预料。 一个人的命运啊，当然要靠自我奋斗，但是也要考虑到历史的行程。 我绝对不知道，我作为一个纽约的地产商，怎么就把我选到白宫去了，所以奥巴马同志跟我讲话，说「选民都决定啦，你来当总统」。 我说另请高明吧，我实在也不是谦虚，「我一个地产商人怎么跑到白宫来了呢」？ 但是呢，巴马同志讲「大家已经研究撅腚了」。 所以，后来我就念了两首诗，叫「苟利国家生死以，岂因祸福避趋之」。 那么所以，我就到了白宫…… 至于到了白宫之后的事，你问我，我只能对你说「无可奉告」。 作为美利坚的总统，我当然不会疯狂到去按核武器按钮，不过大家可以等着看我的四年计划哦～ 且看我怎么让墨西哥出钱建高墙，把2千万非法移民全都赶跑，禁止穆斯林入境，全歼伊斯兰国，撕毁巴黎协议，降税15%，让美国经济增长率追上中国，和中国打贸易战，推翻奥巴马医保，推翻平权法案，禁止人工流产，把希拉里关起来…… 一想起这些，我这年过 70 的老翁都禁不住感到 very excited！ 希拉里老妹，你也别那么沮丧。虽然你输了总统大位，我为你同情，不过你想开点，往后四年，你不必在你老公曾经出轨过的那个恶心的办公室工作，你应该感到庆幸才是，蛤蛤。]]></content>
      <categories>
        <category>蛤学</category>
      </categories>
      <tags>
        <tag>川普</tag>
        <tag>总统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《釜山行》的丧尸之膜]]></title>
    <url>%2F2016%2F09%2F26%2F%E3%80%8A%E9%87%9C%E5%B1%B1%E8%A1%8C%E3%80%8B%E7%9A%84%E4%B8%A7%E5%B0%B8%E4%B9%8B%E8%86%9C%2F</url>
    <content type="text"><![CDATA[最近，电影《釜山行》韩语中字版在朋友圈热传后，网上是一阵阵的好评如潮，尤其是著名相声演员于谦因在此片中饰演那个胖大叔而一炮走红。 要说这个胖大叔，其实人家真名叫马东锡，你要是韩片看得够多的话，会发现他经常出没在韩影出演配角，比如我看过的评价不错的就有惊悚片《邻居》、犯罪片《不当交易》《与犯罪的斗争》《罪恶的编年史》、古装动作片《群盗》等。 既然说了他，就不能不说主演孔侑了。这位又高又帅韩国实力派美男，他主演的《熔炉》豆瓣评分高达9.1分，值得每一个标榜自己喜欢韩国电影的有志青年去仔细体会。 《熔炉》揭露学校性侵暴力毕竟太过深沉，我更想说一下他主演的另一部爽快的动作片《嫌疑者》。 作为《谍影重重》的首席学徒，此片可谓青出于蓝而胜于蓝。 赤身搏斗戏、巷战、飙车大战，都流畅得不得了，近身格斗招招凌厉，眼花缭乱的剪辑玩的如火纯青，加上鼓点急促的配乐元素，观者无不看后大呼过瘾。其燃爆程度近年来看，唯有《疯狂的麦克斯4》可与之匹敌。 回过头来说《釜山行》，网上都说是 8分好评，我看这片也值这个评价，这也是韩国恐怖片正常发挥的水准。 为什么值8分呢？除了特效牛逼，剧情紧凑，人物性格突出外，还有一个最重要的原因：丧尸题材拍出了人性的高度。 跟《行至走肉》的主题类似，杀到最后，人类不是和丧尸斗争，而是和你身边的人搏斗，为了争取可怜的生存空间，自私、猜疑、孤立，相煎何太急…… 更让我 excited 的是：影片看到最后，导演也不忘来膜一把。 too young 的小白可能会问：膜在哪里？ 1997年长者访美第一站夏威夷州，与州长会晤时，会场外有大量抗议者用高音喇叭抗议，这虽然不是美国政府的安排，但估计也是得到了当局默许，人家正准备看长者的笑话呢。 长者什么场面没见识过？且看他如何化解。长者想起了自己民国大学时期学过夏威夷吉他，于是即兴演奏了一曲《Hello Hawaii》，并邀请州长夫人演唱，有效地缓解了会场尴尬的气氛，博得了会场嘉宾们好几百人的一致好评。 在《釜山行》结尾，历经生死磨难，列车上仅剩的一个孕妇和一个小女孩相互搀扶着走出隧道，外面伏击待命的士兵正准备开枪，突然听到了这首韩语版的《Aloha Oe》，马上下令「生存者，接近中」，全片终！ 红衣女孩高唱《Aloha Oe》得以续命，其他所有人的命都被贡献出来了，这才是本片的核心。 《Aloha Oe》，续命神曲，当之无愧啊。 现在知道导演膜力深厚了吧？]]></content>
      <categories>
        <category>蛤学</category>
      </categories>
      <tags>
        <tag>长者</tag>
        <tag>釜山行</tag>
        <tag>孔侑</tag>
        <tag>续命</tag>
        <tag>Aloha Oe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你国轰轰烈烈G20 我杭闷声放长假]]></title>
    <url>%2F2016%2F09%2F01%2F%E4%BD%A0%E5%9B%BD%E8%BD%B0%E8%BD%B0%E7%83%88%E7%83%88G20-%E6%88%91%E6%9D%AD%E9%97%B7%E5%A3%B0%E6%94%BE%E9%95%BF%E5%81%87%2F</url>
    <content type="text"><![CDATA[峰会在即，杭州全城都很激动，为了给全世界各国领导人留下一个安全、干净、舒畅的开会环境，我市9月1号到7号休假，把普通老百姓全给欢送出城了。 工厂歇业、店铺全关、道路畅通一改往日拥堵之旧貌……当是时，天时地利人和，徐嘉诰老先生研究了几十年的《天气晴朗学》在此举世瞩目的峰会到来期发挥了重要作用： 本来天气预报说这几天有雨，结果这G20一来啊，阳光明媚，你看，万里乌云的天空下还飘着朵朵蓝翔。 为了办好这届G20峰会，杭州普通市民的出行受到了不同程度的影响。 晚饭后去超市买盒牛奶打算早上喝，一路上，超市保安、公交司机、警察、小区门卫各让喝一口，早餐奶就这样全喝完了。 汽车后备箱里放箱红酒，安检要求每瓶喝一口。喝了后准备回家，刚启动车子，警察不让走说酒后驾车了。 你要问我滋词不滋词G20放假？我说滋词，我就明确告诉你这点。一年过两个国庆长假，有什么不好吗？ 但是，你一定要问我「你杭举全市之物力，接与列国之欢心」，这是不是在搞面子工程？ 没有任何这个意思。加强安保工作，是历届G20峰会的国际惯例。 我告诉你，我是身经百战，见得多了，西方国家的哪个峰会我没去过？人家比我们的严得不知道哪里去了。 2009年英国伦敦G20峰会，当地政府关闭了连接主会场的轻轨站，封堵附近道路，仅开放人行道供当地须出示有效身份证件的居民出入，并严格进行安检。 2010年韩国首尔G20峰会，采用“无车日”和“错峰限行”等多项交通管制措施，数以万计的士兵驻守在重要公共设施附近以及山区；在地铁站等大型公共场所部署了特种部队，车站寄存柜暂时封闭，垃圾箱被换成透明容器。 2011年法国戛纳G20峰会，当时法国海陆空三军总动员,安排拆弹专家排查码头或游艇，元首入住酒店安放防暴犬和监察设备，机场也进行空中警戒安保；戛纳当地学校停课，周围所有建筑禁止开窗。 2013年俄罗斯圣彼得堡G20峰会，安保严格到连宠物狗都登记了。…… 同其他各国相比，杭州G20峰会的安保投入并不夸张。我们的精神是：没有最严，只有更严。严防死守，滴水不漏！ 国进民退，闷声放长假，这是坠吼滴。]]></content>
      <categories>
        <category>蛤学</category>
      </categories>
      <tags>
        <tag>G20</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我承诺会给你一个美好的未来]]></title>
    <url>%2F2016%2F08%2F30%2F%E6%88%91%E6%89%BF%E8%AF%BA%E4%BC%9A%E7%BB%99%E4%BD%A0%E4%B8%80%E4%B8%AA%E7%BE%8E%E5%A5%BD%E7%9A%84%E6%9C%AA%E6%9D%A5%2F</url>
    <content type="text"><![CDATA[在以往的 C++98 中，多线程并行开发并不是那么容易的：你得小心翼翼地处理好「线程、锁、条件变量」的三角关系才能弄出个像样的多线程程序出来。 C++11 提供了 future 和 promise 来简化不同线程间的异步操作： 当一个任务需要向父线程（启动它的线程）返回值时，它把这个值放到 promise 中，之后，这个返回值会出现在和此 promise 关联的 future 中，于是父线程就能读到返回值。 在这种机制里，你只需要一个执行任务的线程，而不必再显示地使用其它的什么锁、条件变量等语义。 future从字面意思看，它表示「未来」，通常我们不能立即获取到异步操作的执行结果，只能在未来某个时候获取。 一个有效的 future 对象通常由以下三种 provider 创建，并和某个共享状态相关联。 async 函数 promise::get_future packaged_task::get_future 我们可以通过查询 future 的状态（future_status）来获取异步操作的结果。 future_status 有三种状态： deferred：异步操作还没开始 ready：异步操作已经完成 timeout：异步操作超时 获取 future 结果有三种方式： get 等待异步操作结束并返回结果 wait 只是等待异步操作完成，没有返回值 wait_for 超时等待返回结果 promisepromise 是个范型对象，可保存 T 类型的值，该值可被 future 对象在将来某个时刻读取。在构造 promise 时，promise 对象可以与共享状态关联起来，这个共享状态可以存储一个 T 类型或者一个由 std::exception 派生出的类的值，并可以通过 get_future 来获取与 promise 对象关联的对象，调用该函数之后，两个对象共享相同的共享状态(shared state)。 promise 对象是异步 provider，它可以在某一时刻设置共享状态的值。 future 对象可以返回共享状态的值，或者在必要的情况下阻塞调用者并等待共享状态标识变为 ready，然后才能获取共享状态的值。 12345678910111213141516171819#include &lt;iostream&gt; #include &lt;functional&gt; #include &lt;thread&gt; #include &lt;future&gt; void print_int(std::future&lt;int&gt;&amp; fut) &#123; int x = fut.get(); std::cout &lt;&lt; "value: " &lt;&lt; x &lt;&lt; '\n'; &#125;int main ()&#123; std::promise&lt;int&gt; prom; std::future&lt;int&gt; fut = prom.get_future(); std::thread t(print_int, std::ref(fut)); prom.set_value(10); t.join(); return 0;&#125; packaged_taskpackaged_task 和 promise 在某种程度上有点像，只不过 promise 保存了一个共享状态的值，而 packaged_task 保存的是一个可调用对象。 它包含了两个最基本元素： 被包装的任务(stored task)，一个可调用的对象，如函数指针、成员函数指针或者函数对象。 共享状态(shared state)，用于保存任务的返回值，可以通过 future 对象来达到异步访问共享状态的效果。 1234std::packaged_task&lt;int()&gt; task([]()&#123; return 7; &#125;);std::thread t1(std::ref(task)); std::future&lt;int&gt; f1 = task.get_future(); auto r1 = f1.get(); promise &amp; future &amp; packaged_taskpromise 和 packged_task 都是异步 provider，都可以在将来某个时候设置与其关联的共享状态的值，它们内部都关联了一个 future 来异步访问共享状态的值。 稍微有点不同的是 packaged_task 包装的是一个异步操作、具体任务的返回值；而 promise 包装的是一个明确的、具体的值。 我的体会是： 需要直接读取线程函数中的某个值，就用 promise，需要获取异步操作的返回值，就用 packaged_task。 就这点细微的区别，我想用人类的语言解释一下。 比如，一个小伙子给一个姑娘表白真心的时候可能会说：「我承诺会给你一个美好的未来」或者「我会努力奋斗为你创造一个美好的未来」。 姑娘往往会说：「我等着」。 这三句话翻译成 C++11 语言就是： 小伙子说：「我承诺会给你一个美好的未来」等于 C++11 中 promise a future; 小伙子说：「我会努力奋斗为你创造一个美好的未来」等于 C++11 中 packaged_task a future; 姑娘梨花带雨地说：「我等着」等于 C++11 中 future.get()/wait(); 小伙子两句话中的差异，自己琢磨一下，就是 promise 和 packaged_task 的差异，只可意会，不可言传吧。 现实中的山盟海誓靠不靠得住我不知道，但是 C++11 中的承诺和未来是一定可靠的，发起来了承诺就一定有未来，不管这个承诺是成功履行了（ready）或者出现了其它变故（exception）。 异步首选：asyncC++11 还提供了异步接口 async，它会自动创建一个线程去执行线程函数，返回一个 future，这个 future 中存储了线程函数的返回值。 async 使我们可以在不显示调用线程的情况下就实现异步操作，获取异步执行状态和结果，真是 so easy，另外，它还提供了两种线程的创建策略。 1async(std::launch::async | std::launch::deferred, f, args...) std::launch::async：调用就开始创建线程，默认策略。 std::launch::deferred：延迟加载方式，调用时不创建线程，直到调用了 future 的 get 或者 wait 时才创建线程。 12345678910111213141516171819202122#include &lt;iostream&gt; #include &lt;future&gt; // a non-optimized way of checking for prime numbersbool is_prime (int x) &#123; std::cout &lt;&lt; "Calculating. Please, wait...\n"; for (int i=2; i&lt;x; ++i) if (x%i==0) return false; return true;&#125;int main ()&#123; std::future&lt;bool&gt; fut = std::async (std::launch::deferred, is_prime, 313222313); std::cout &lt;&lt; "Checking whether 313222313 is prime.\n"; bool ret = fut.get(); // waits for is_prime to return if (ret) std::cout &lt;&lt; "It is prime!\n"; else std::cout &lt;&lt; "It is not prime.\n"; return 0;&#125; 总结C++11 本身提供了统一的跨平台的线程语法，在此基础上，future 和 promise、packged_task、async 进一步地简化了线程的异步操作，使得程序员从以前的多线程噩梦中解脱出来，而将更多的注意力放在具体的业务逻辑上，这是生产力的巨大进步。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>future</tag>
        <tag>promise</tag>
        <tag>packaged_task</tag>
        <tag>承诺</tag>
        <tag>未来</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[女排夺冠困扰我的两大难题]]></title>
    <url>%2F2016%2F08%2F21%2F%E5%A5%B3%E6%8E%92%E5%A4%BA%E5%86%A0-%E6%88%91%E6%83%B3%E5%88%B0%E4%BA%86%E8%BF%99%E4%BA%9B%2F</url>
    <content type="text"><![CDATA[今天早上的这场女排决赛，燃爆了，据路边社报道，国内收视率一度达到 58.7%，而湖南卫视、江苏卫视、浙江卫视还不及其十分之一，足见国人对女排的热情，其盛况不亚于巴西人万人空巷地看奥运男足。 我们的乒乓球号称「国球」，是因为它有着悠久的历史和辉煌的战绩，6届奥运会的24枚金牌，我们霸气地拿下了23枚；如果说我们国家有「母球」的话，我想，女排当之无愧。 从1984到2004，从2004到2016，中间虽然历经磨难，饱受摧残，依然本色不改：团结、拼搏，是她们一以贯之地优良传统，不像某些队那样…… 三大球中，也就女排最争气了。 1国内主流媒体的报道基本上是说，这次女排能夺冠，靠的就是「不畏强敌、团结协作、自强不息」的女排精神。 作为一个无神论者，我是不相信单纯依靠精神的力量就可以取胜的，何况我们的对手里面有巴西、美国、俄罗斯等老牌强劲对手以及塞尔维亚这样的后起之秀。 女排精神，固不可丢，这也是女排一路走来不断创造辉煌的主观因素。 倘若我们只谈情怀，避谈技术，就跟愤青没什么区别了。赛场上只有你争我夺的实力较量，要发得起有力的进攻，同时扛得住对手的进攻，精神力量只能起到辅助、催化、刺激的作用。 在精神层面，我们常看到自由人、接应凭借顽强的毅力去挽救那些几乎不可能救回的高难度球。 在技术层面，我们看到主攻、副攻借过硬的实力进攻屡屡得分。 2此番里约夺冠，郎平指导功不可没。 郎平用人很准，能充分地发挥出每位队员的特长，并及时地根据对手节奏的变化有针对性地进行战术调整。 在刻苦训练、顽强拼搏的基础上，郎平将国际化、专业化的团队合作形式和科学训练的理念引入中国女排，使得女排这么一支年轻的队伍，经过两三年训练就能脱胎换骨，斩获佳绩。 因此，可以这么说，郎平给中国女排实现了三个现代化：技术化、专业化、科学化，这才是女排继2015年夺得世界杯冠军后又荣获奥运冠军的根本原因。 反观国羽，固步自封，不求变化，对手都把它研究透了，它还躺在往日的成绩薄中不可自拔。短短4年，从伦敦奥运包揽5金，到这届奥运会连丢3金，问题都出在自己身上。 3这届奥运会女排的前三甲，还有段难以释怀的历史。「17 年前，季军轰炸了冠军在亚军的大使馆」。 长者在接受华莱士记者的采访中，谈到了此事，长者说： In the 1989 disturbance, we truly understand the passion of students recalling for democracy and freedom.In fact, we’ve been always working to improve our system of democracy, but we could not possibly allow people with ulterior motive to use students to overthrow the government under the pretest of democracy and freedom. 华莱士追问道： Did a part of you admire his courage? 长者机智地笑了，说： I know what you are driving at, but what I want to emphasize is that we fully respect every citizens’ right to freely express his wishes and desires, but I don’t favor any opposition to government actions during emergency. 华莱士提到了南斯拉夫大使馆问题，问：「你说是美国故意轰炸南斯拉夫大使馆？」 长者笑了，回问华莱士：「Did a part of you believe it?」 华莱士愣了，没敢回答。长者说，这个问题应该由你们美国回答，你们的武器很先进，出了这种问题，你们应该急着去找原因，克林顿已经多次道歉了…… 4最后，有两个问题还在困扰着我： 谁能告诉我塞尔维亚女排 19 号的微信号？ 求塞尔维亚女排教练同款口香糖？]]></content>
      <categories>
        <category>指点江山</category>
      </categories>
      <tags>
        <tag>蛤学</tag>
        <tag>女排</tag>
        <tag>塞尔维亚</tag>
        <tag>里约奥运</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[公众号最后一日：一场重命名风波]]></title>
    <url>%2F2016%2F08%2F19%2F%E5%85%AC%E4%BC%97%E5%8F%B7%E6%9C%80%E5%90%8E%E4%B8%80%E6%97%A5%EF%BC%9A%E4%B8%80%E5%9C%BA%E9%87%8D%E5%91%BD%E5%90%8D%E9%A3%8E%E6%B3%A2%2F</url>
    <content type="text"><![CDATA[今天副组长魏武挥在朋友圈发图说公众号可以改名了。 这可是个天大的好消息啊，想当年，小明注册这个公众号，用脚趾头想了个不伦不类的「我为朝露谁苦多」。说实话，这名字不押韵，不好记，坠痛苦的还是；那些纯情的女孩子，还没关注就被「譬如朝露，去日苦多」这股猥琐的气质给吓跑了。 后来，我一直寻思着想换个名字，但是霸道的公众平台一直不开放修改公众号名字的权限，这给我的自媒体声誉造成了不可估量的损失。 这让我不由得想起了那句老话，「时间对于爱耍小聪明的人是最无情的」。你觉得抖了个机灵，在别人眼里，也许就是逗逼犯傻。 比如，歌坛重量级人物刘欢，给女儿取名：「刘一丝」，说起这个奇怪的名字，一帮看热闹不嫌事大的记者围着他惊讶地问「取这个名字有什么寓意吗？」 刘欢很得意，哈哈狞笑道「这你们就不知道了吧。一丝来自成语一丝不挂，是佛家用语，指的是灵台清净、四大皆空、心里没有一丝尘世的牵挂，这叫一丝不挂，讲的是心境，是很高的修行啊」。 记者一脸懵逼，强拧着脸上的肌肉和刘欢笑成一团，「妈的，这个笨蛋想一丝不挂，自己姓刘又他妈忘了，居然还给女儿留了一丝……」 这就是卖弄学问、弄巧成拙的例子。 王朔有一句体谅人情世故的话，说的特别好： 父母给子女取名字时一时的不谨慎，给孩子造成的是终生的心灵痛苦。 我们上学的时候，但凡名字有点歧义、邪义的家伙，都被身边无情的小伙伴残忍地修理。 据说刘欢女儿现在还叫「刘一丝」，希望她过得快乐吧。 好罢，讲了这么多，无非说取名不可儿戏，要慎重。毕竟这个公号是我一手带大的，充满了感情，于是，我在朋友圈里咨询重命名。 某蛤丝怂恿我改名「黄续忠」，我当即就喷了一脸盐汽水回去「什么续命，尽放狗屁!」，没想到这厮又给我顶了一句「一派胡言，非常气愤！」……两枚蛤丝就这个「续」字膜得不可开交。 赛艇中纪委一贯督促蛤丝们不要武膜，要文膜。暴力膜谁不会啊，蔡英文、卡梅伦、布冯，哪个不是被我膜得栩栩如生？！naive。 思来想去，觉得还是叫本尊真名坠好，从明天开始，这个公众号名字就正式改为：「黄学忠」，算是小明行走江湖的另一个 ID 吧。 很惭愧，就做了点微小的贡献，谢谢大家。]]></content>
      <categories>
        <category>WeChat</category>
      </categories>
      <tags>
        <tag>公众号</tag>
        <tag>刘一丝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[垂死病中惊坐起 谈笑风生又一年]]></title>
    <url>%2F2016%2F08%2F17%2F%E5%9E%82%E6%AD%BB%E7%97%85%E4%B8%AD%E6%83%8A%E5%9D%90%E8%B5%B7-%E8%B0%88%E7%AC%91%E9%A3%8E%E7%94%9F%E5%8F%88%E4%B8%80%E5%B9%B4%2F</url>
    <content type="text"><![CDATA[0晨起，赛艇中纪委就来问话「今天可为虵写了一点什么没有」？ 我说「没有」。 他就正告我「先生还是写一点罢，续得一秒是一秒」。 1八月酷暑正浓，正是三伏天气将终的时节。 南国的物候变化比帝都来得晚些，此时的黄浦江畔，犹是一派溽暑磨人。池塘里，莲花开到了一年中最烂熟的时候，清圆的荷叶下，不时传来几声蛙鸣，当真是暖风熏得游人醉。 2每逢盛事，天必有吉兆。 《中国气象史》有云： 庆丰五年，八月十六，古城西安突现祥瑞，蛤云吞日，百姓或惊或喜。钦天监主簿徐公嘉诰曰，明日有雨，然尊师大寿，则晴空万里。 3且让我们先把目光回溯到 90 年前。这一年，世界上诞生了 3 个不可一世的大人物：虵、卡斯特罗和伊丽莎白女王，并称「1926三人组」。 在天朝上国，虵的分量绝壁是坠吼滴，有诗有云： 敢于卡斯特罗争高下，不向伊丽莎白让半分。 伊丽莎白二世，已经在4月21日迈入了90岁，大腐国每天都有“女王万岁”给她续着。 4天前的8月13日，古巴的老卡斯特罗也步入了90后俱乐部，这位被美国中情局暗杀638次未遂的古巴前领导人，明显被续得不知道有多少次了。 虵，也在今天迎来了90大寿，粉丝在为虵生日的到来准备着一场狂欢。 4虵曾经是红色政权国家的世俗领袖，政治生涯饱受争议。 因为年龄原因，虵已经退居二线，也时常有人传出虵已经去世的谣言，以至于虵的每一次公开露面都是一次粉丝的盛宴。 虵的一生被视为一个传奇，有着极为丰富的人生经验。 有人说虵是一个独裁者，这显然是亡我之心不死的西方帝国主义泼的脏水 nNoi2@#FV0nV%……（对不起，我太激动，脸不小心贴在键盘上了）。 5在这个特别的日子，让我们一起再听一遍《Aloha Oe》这首充满人生经验的歌曲，续上自己微小的 1s 吧。]]></content>
      <categories>
        <category>蛤学</category>
      </categories>
      <tags>
        <tag>1926三人组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[平常心造就「一颗赛艇」]]></title>
    <url>%2F2016%2F08%2F15%2F%E5%B9%B3%E5%B8%B8%E5%BF%83%E9%80%A0%E5%B0%B1%E3%80%8C%E4%B8%80%E9%A2%97%E8%B5%9B%E8%89%87%E3%80%8D%2F</url>
    <content type="text"><![CDATA[在刚刚结束的里约奥运会羽毛球男双 1/4 决赛当中，中国组合张楠/傅海峰为球迷奉献了一场酐畅淋漓的大逆转： 在首局失利，决胜局大比分落后的情况下，还能顽强取胜，以 2-1战胜韩国组合，晋级半决赛。 小明正好观看了整场比赛的直播，真是 excited！中国队组合“玩的就是心跳”，在三局比赛中，他们都是一开始大比分落后，被韩国队虐得满地找球。 可能由于是在当地时间早上比赛，两位队员还没睡醒？第一局完全不在状态，没有打出原奥运冠军的水准，11-21 狼狈收场。 第二局，开始也打的不好，中国队几乎是复制了第一局，韩国队一度 5-1 领先。然而最凶险的时刻还是在这局的尾声，在韩国队 18-16 领先的时候，傅海峰与张楠终于睡狮猛醒，一下子狂砍 5 分，以 21-18 拿下非常关键的一局。 第三局，就更有意思了。一上来，中国队还是大比分落后，8－15……我都看到韩国队那边开始准备庆祝胜利了。中国队苦追，最后韩国队 20-17 拿到三个赛点。关键时候，傅海峰与张楠毫不手软，一直将比分追平。 在 21-21 之时，中国队突然发了一个后场球，成功地打了韩国队一个措手不及，对手即便跪倒在地也没能将球救回来，中国队在心理上给了对手致命一击。 置之死地而后生，韩国队真是拿这对打不死的小强没辙了，垂头丧气地，连爬都没力气了，蛤蛤～ 最终，中国组合一鼓作气，以 24-22 拿下对手，韩国教练无奈地低下了头。 决胜盘大比分落后，我怎么也想不到中国队最终能拿下这场比赛。逆转靠的是什么？心理。赛后，傅海峰接受记者采访说： 我们场上比他们做的好的就是关键分的处理。我们都是奥运冠军，相信我们的实力。比赛，后半段他们慌了。一开始我们不行，后半段他们不行，这就是奥运会的魅力。 作为奥运会参赛选手们而言，他们能代表国家登上这个舞台，本身就是一种成功，只要放下思想包袱，全力以赴，输赢其实真的没那么重要。 韩国选手输了，输在求胜心切；中国选手赢了，赢在心态和拼搏劲。 第一局输后，中国队往后打得没有什么心理压力： 反正我们都输了，无所谓，就当输的来打，反而对手表现得越来越紧，非常想赢球，反而丢了这局。 这是一场精彩的比赛。]]></content>
      <categories>
        <category>心旷神怡</category>
      </categories>
      <tags>
        <tag>里约奥运</tag>
        <tag>一颗赛艇</tag>
        <tag>羽毛球</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从「王宝强事件」学人生经验]]></title>
    <url>%2F2016%2F08%2F14%2F%E4%BB%8E%E3%80%8C%E7%8E%8B%E5%AE%9D%E5%BC%BA%E4%BA%8B%E4%BB%B6%E3%80%8D%E5%AD%A6%E4%BA%BA%E7%94%9F%E7%BB%8F%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[突然从傅园慧的「洪荒之力」这股清流风刮到王宝强的半夜离婚声明，小明明显感觉不太适应。 你要问我对「宝宝妻子出轨经纪人」这事怎么看？我只能说四个字：「无可奉告」。 作为新时代理性的网民，你们千万要记着，「不要见得风，就是雨」，看到这些消息，你们本身也要判断，像那些明显是无中生有的东西，比如那几个冒充注册的小号说什么「告诉你，我们还3P了」、「王宝强家暴」之类的谣言，你再帮它传播一遍，你等于……你也有责任的对吧？ 你们啊，还是要提高自己的姿势水平，识得唔识得？哎！我真是为你们感到捉急啊，你们有一个好，网上有什么热点，你们跑的比香港记者还快，这次你们跑到人家微博去问候人家父母，结果走错地方，把乒乓球运动员宋喆同学骂了一遍，瞧你们这副德行，还是图样图森破，上台拿衣服。 今天我看你们这么热情，一句话不说也不好，我跟你讲，我是身经百战，见得多了：文章出轨、黄海波嫖娼、谢霆锋离婚……哪个我没见识过？ 如果你一定要问我滋词不滋词王宝强这个声明，我是滋词的，我就明确告诉你这一点。老婆出轨了，他根据婚姻基本法提出离婚，有什么问题吗？ 我很抱歉，我今天是作为一个过来人跟你们讲，我有必要给你们传授一点人生的经验，李笑来老师在《通往财富自由之路》书中说： 人生中浪费生命、虚掷光阴、永陷贫穷的三大坑： 莫名其妙地凑热闹 心急火燎地随大流 操碎了别人的心肝]]></content>
      <categories>
        <category>蛤学</category>
      </categories>
      <tags>
        <tag>王宝强离婚</tag>
        <tag>出轨</tag>
        <tag>李笑来</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写给女儿]]></title>
    <url>%2F2016%2F08%2F09%2F%E5%86%99%E7%BB%99%E5%A5%B3%E5%84%BF%2F</url>
    <content type="text"><![CDATA[女儿，今天是你来到这世间的第 20 天。 前天，爸爸结束了 15 天的陪产假，不舍地暂别了你和妈妈。这两天，我都止不住地想念你们母女。 你出生的时候，我还在焦急地赶高铁回家，从杭州到郴州，一千二百多公里，每一里都仿佛是你妈妈分娩你的痛。终于，2016 年 7 月 22 日，下午一点零三分，你出世了。 微信上你妈妈发来你刚出生时的照片：肤色很白，眼睛睁得很大，好奇地向四周瞅，都说像极了你爸我。 你出生之前，不仅妈妈、奶奶，还有七大姑八大姨，都说你会是一个男孩儿，我们都给你取好了名字叫「黄泽轩」，等你出生，发现是个女孩，爸爸妈妈都觉得 「xuanxuan」这个小名蛮好听的，于是，取一个适用于女孩的「瑄」，就叫你「黄泽瑄」好啦。 黄泽瑄，你在妈妈肚子里的时候可调皮了。有时，你踢妈妈肚子弄得妈妈都没法睡好觉，有时，爸爸给你讲故事，你也会紧贴着肚皮滑来滑去，好像迫不及待地要出来和爸爸打招呼似的。 那天，爸爸刚赶到医院，轻轻地抚摸你的小手，刚刚还在哭闹的你马上就把爸爸的手指握在手心，一副安详的样子。 你回到家里后，亲朋好友都说你长得真标致，白净，乖巧，眉清目秀。以至于你爸这个伪文艺青年我也不吝用这样的文字来形容我的小情人： 片刻的举手投足让你妩媚丛生，刹那的眼神游离让你倾国倾城。 都说女儿是爸爸上辈子的情人，我的小情人啊，你和你妈妈，就是爸爸这辈子最牵挂的人啦。爸爸会好好疼爱你们、保护你们，让你们母女活得自在，自然，自由。 小情人，让我们一起长大，你学着走路和说话，我学着成为一个爸爸。 爸爸，要做到的是，不让你们有什么经济压力，因此，「我要努力成为一个富裕的老爸」。 蛤蛤～]]></content>
      <categories>
        <category>心旷神怡</category>
      </categories>
      <tags>
        <tag>女儿</tag>
        <tag>黄泽瑄</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表驱动｜码农的豹变]]></title>
    <url>%2F2016%2F07%2F14%2F%E8%A1%A8%E9%A9%B1%E5%8A%A8%EF%BD%9C%E7%A0%81%E5%86%9C%E7%9A%84%E8%B1%B9%E5%8F%98%2F</url>
    <content type="text"><![CDATA[今天不知道怎么滴，歪打正着地闯入到陈硕写于 2005年的一篇 CSDN 博客 ，文末，这厮扬言： 是否掌握表驱动技术是划分初级程序员和高级程序员的重要分水岭之一。 表驱动是个什么鬼？说的好腻害的样子。既然老司机传授如此热心地私家秘籍，作为一个求知欲和毛发一样旺盛的初级码农，小明开始了这一趟求学之旅。 新姿势 get，在此记录下心得。 What表驱动方法（Table-Driven Methods），在《Unix 编程艺术》中有提到，《代码大全》的第十八章对此进行了详细地讲解。 表驱动法是一种从表里查找信息而不是使用逻辑语句（if或switch）的编程模型。 Why先通过一个简单的例子体验下，在某些情况下，如果不使用表驱动方法，代码会如何地难看。 假设让你实现一个返回每个月天数的函数（为简单起见不考虑闰年）。 初级码农的笨方法是马上摆出 12 副威武雄壮的 if-else 组合拳： 1234567891011121314151617181920int iGetMonthDays(int iMonth)&#123; int iDays; if(1 == iMonth) &#123;iDays = 31;&#125; else if(2 == iMonth) &#123;iDays = 28;&#125; else if(3 == iMonth) &#123;iDays = 31;&#125; else if(4 == iMonth) &#123;iDays = 30;&#125; else if(5 == iMonth) &#123;iDays = 31;&#125; else if(6 == iMonth) &#123;iDays = 30;&#125; else if(7 == iMonth) &#123;iDays = 31;&#125; else if(8 == iMonth) &#123;iDays = 31;&#125; else if(9 == iMonth) &#123;iDays = 30;&#125; else if(10 == iMonth) &#123;iDays = 31;&#125; else if(11 == iMonth) &#123;iDays = 30;&#125; else if(12 == iMonth) &#123;iDays = 31;&#125; return iDays;&#125;` 稍微机灵点的码农发现每月天数无外乎 28、30、31 三种，或许会用 switch-case “裁剪”下： 12345678910111213141516171819202122int iGetMonthDays(int iMonth)&#123; int iDays; switch (iMonth) &#123; case 1: case 3: case 5: case 7: case 8: case 10: case 12:&#123;iDays = 31;break;&#125; case 2:&#123;iDays = 28;break;&#125; case 4: case 6: case 9: case 11:&#123;iDays = 30;break;&#125; &#125; return iDays;&#125;` 这两种方法充斥了大量的逻辑判断，还凭空冒出了一大堆1，2，...，11，12这样的 Magic Number（魔鬼数字公然出现在程序里是很 ugly 的做法），不利于代码的维护与扩展。 表驱动处理起来就赏心悦目得多了： 123456static int monthDays[12] = &#123;31,28,31,30,31,30,31,31,30,31,30,31&#125;;int iGetMonthDays(int iMonth)&#123; return monthDays[(iMonth - 1)];&#125; How表驱动可以使你的代码更简洁，结构更加灵活，多用于逻辑性不强但是分支多的情况。 如何使用表驱动法？需要明确两个关键问题： 表的形式及表中放什么内容 表形式可以为一维数组、二维数组和结构体数组。 表中可以存放数值、字符串或函数指针等数据。 如何去访问表。 下面介绍表的三种访问方式： 直接访问直接根据“键”来获得“值”，给定下标 index，然后array[index]就获得数组在相应下标处的数值。例如前面这个根据月份取天数的例子。 索引访问 它适用于这样的情况：假设你经营一家商店，有 100 种商品，每种商品都有一个 ID 号，但很多商品的描述都差不多，所以只有 30 条不同的描述，如何建立建立商品与商品描述的表？ 还是同上面做法来一一对应吗？那样描述会扩充到 100 个，会有 70 个描述是重复的！太浪费了。 方法是建立一个 100 长的索引和 30 长的描述，然后这些索引指向相应的描述（不同的索引可以指向相同的描述），这样就解决了表数据冗余的问题啦。 123456789101112131415161718192021222324252627282930struct product_t &#123; char * id; int desc_index;&#125;;const char * desc[] = &#123; "description_1", "description_2", ... "description_29", "description_30"&#125;;const product_t goods [] = &#123; &#123;"id_1", 3&#125;, &#123;"id_2", 1&#125;, ... &#123;"id_99", 12&#125;, &#123;"id_100", 5&#125;&#125;;const char* desc_product (const char* id) &#123; for (const product_t &amp; p : goods) &#123; if (strcmp(p.id, id) == 0) &#123; return desc[p.desc_index - 1]; &#125; &#125; return NULL;&#125; 阶梯访问 例子：将百分制成绩转成五级分制（我们用的优、良、中、合格、不合格，西方用的 A、B、C、D和F），假定转换关系: Score Degree [90-100] A [80,90) B [70,80) C [60,70) D [0,60) F 如何用表格表示这些范围？你当然可以用第一种直接访问的方法：申请一个 100 长的表，然后在这个表中填充相应的等级。很明显，也会浪费大量空间，有没有更好的方法？ 对于这种“某个范围区间内，对应某个值”的逻辑规则，可用阶梯访问的方式。 123456789101112131415161718192021222324const char gradeTable[] = &#123; 'A', 'B', 'C', 'D', 'F'&#125;;const int downLimit[] = &#123; 90, 80, 70, 60&#125;;int degree(int score)&#123; int gradeLevel = 0; char lowestDegree = gradeTable[sizeof(gradeTable)/sizeof(gradeTable[0]) - 1]; // 这里可用二分查找优化 while (gradeTable[gradeLevel] != lowestDegree) &#123; if(score &lt; downLimit[gradeLevel]) &#123; ++ gradeLevel; &#125; else &#123; break; &#125; &#125; return gradeTable[gradeLevel];&#125; 将来如果等级规则变了（比如 85～100 分为等级 A，或添加 50～60 分为等级 E），只需要修改 gradeTable 和 downLimit 表就行，degree 函数可以保持一行都不改动。 更进一步地，gradeTable 和 downLimit 表还可以配置文件的形式表示，主程序从外部文件 load 进来就行，程序灵活性大大增加。 Review伟大的 C 语言大师 Rob Pike 有句话说的好： 数据压倒一切。如果选择了正确的数据结构并把一切组织的井井有条，正确的算法就不言自明。编程的核心是数据结构，而不是算法。 对人类来说，数据比编程逻辑更容易驾驭。在复杂数据和复杂代码中选择，宁可选择前者。 更进一步，在设计中，应该主动将代码的复杂度转移到数据中去。 这里谈到了 Unix 哲学之分离原则： 策略同机制分离 机制，即提供的功能。 策略，即如何使用功能。 以百分制转五级分制为例，机制就是 degree 函数：你给一个百分制分数给它，它吐出来一个五级分制给你。策略就是gradeTable 和 downLimit 这两个表，它规定了哪个区间的分数对应哪个等级。 从 degree 的实现可以看出:对机制而言，策略是透明的（degree 完全看不到 gradeTable 和 downLimit 这两个表的内部规则）。 将两者分离，可以使机制(degree)相对保持稳定，而同时支持策略(表)的变化。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++11</tag>
        <tag>表驱动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[漫话 C++11 之 atomic_flag]]></title>
    <url>%2F2016%2F07%2F10%2F%E6%BC%AB%E8%AF%9D-C-11-%E4%B9%8B-atomic-flag%2F</url>
    <content type="text"><![CDATA[原子操作原子操作，是多线程环境下的一个重要概念，是指它是否在共享内存中完成了一个线程相关的单步操作。 当一个原子存储作用于一个共享变量时，其他的线程不能监测到这个未完成的修改值。 当一个原子加载作用于一个共享变量时，它读取到这个完整的值，就像此时出现了一个单独的时刻。 而非原子加载和存储则不能做到上述两点保证。 为了保证数据的最终一致性，我们可以定义如下规则： 任何时刻两个线程同时操作一个共享变量，当其中一个为写操作时，这两个线程必须使用原子操作。 atomic_flagatomic_flag 是一种简单的原子布尔类型，只支持两种操作:test-and-set 和 clear。 构造函数atomic_flag 只有默认构造函数，拷贝构造函数已被禁用，因此不能从其他的 atomic_flag 对象构造。 12atomic_flag() noexcept = default;atomic_flag (const atomic_flag&amp;T) = delete; 如果在初始化时没有明确使用 ATOMIC_FLAG_INIT 初始化，那么新创建的 atomic_flag 对象的状态是未指定的（unspecified）（既没有被 set 也没有被 clear。）另外，atomic_flag 不能被拷贝，也不能 move 赋值。 ATOMIC_FLAG_INIT: 如果某个 atomic_flag 对象使用该宏初始化，那么可以保证该对象在创建时处于 clear 状态。 看一个简单的例子，main() 函数中创建了 10 个线程进行计数，率先完成计数任务的线程输出自己的 ID，后续完成计数任务的线程不会输出自身 ID： 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt; #include &lt;atomic&gt;#include &lt;thread&gt; #include &lt;vector&gt; // can be checked without being setstd::atomic&lt;bool&gt; ready (false); // always set when checkedstd::atomic_flag winner = ATOMIC_FLAG_INIT; void count1m (int id) &#123; // wait for the ready signal while (!ready) &#123; std::this_thread::yield(); &#125; // go!, count to 1 million for (int i=0; i&lt;1000000; ++i) &#123;&#125; if (!winner.test_and_set()) &#123; std::cout &lt;&lt; "thread #" &lt;&lt; id &lt;&lt; " won!\n"; &#125;&#125;;int main ()&#123; std::vector&lt;std::thread&gt; threads; std::cout &lt;&lt; "spawning 10 threads that count to 1 million...\n"; for (int i=1; i&lt;=10; ++i) threads.push_back(std::thread(count1m,i)); ready = true; for (auto&amp; th : threads) th.join(); return 0;&#125; test_and_settest_and_set() 函数检查 atomic_flag 标志： 如果之前没有被设置过，则设置 atomic_flag 的标志，并返回 false； 如果之前 atomic_flag 对象已被设置，则返回 true。 12bool test_and_set (memory_order sync = memory_order_seq_cst) volatile noexcept;bool test_and_set (memory_order sync = memory_order_seq_cst) noexcept; test-and-set 操作是原子（read-modify-write）的，它到当前操作不受其他线程影响。 参数 sync 的取值如下： Memory Order 值 Memory Order 类型 memory_order_relaxed Relaxed memory_order_consume Consume memory_order_acquire Acquire memory_order_release Release memory_order_acq_rel Acquire/Release memory_order_seq_cst Sequentially consistent 这里涉及到有关 C++ 中内存模型 Memory Order 姿势，先挖个坑，日后单写一篇这个主题的文章。 clear清除 atomic_flag 对象的标志位，设置 atomic_flag 的值为 false。 12void clear (memory_order sync = memory_order_seq_cst) volatile noexcept;void clear (memory_order sync = memory_order_seq_cst) noexcept; 清除标志使得下一次调用 test_and_set 返回 false。 自旋锁结合 test_and_set() 和 clear()，atomic_flag 对象可以当作一个简单的自旋锁 使用，请看下例： 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;atomic&gt; #include &lt;thread&gt; #include &lt;vector&gt; #include &lt;sstream&gt; std::atomic_flag lock_stream = ATOMIC_FLAG_INIT;std::stringstream stream;void append_number(int x) &#123; while (lock_stream.test_and_set()) // acquire lock ; //spin stream &lt;&lt; "thread #" &lt;&lt; x &lt;&lt; '\n'; lock_stream.clear(); // release lock&#125;int main ()&#123; std::vector&lt;std::thread&gt; threads; for (int i=1; i&lt;=10; ++i) threads.push_back(std::thread(append_number,i)); for (auto&amp; th : threads) th.join(); std::cout &lt;&lt; stream.str(); return 0;&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++11</tag>
        <tag>atomic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[布冯的历史行程]]></title>
    <url>%2F2016%2F07%2F03%2F%E5%B8%83%E5%86%AF%E7%9A%84%E5%8E%86%E5%8F%B2%E8%A1%8C%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[我的经历就是到了意大利帕尔马俱乐部，到了 2001 年夏天的时候，我就想我在这里只是个替补门将，我想我应该换个俱乐部踢球。 于是我就给尤文图斯里皮主教练写了一个报告，他说欢迎你来，不过这个 apply for goalkeeper 你要去做一个报告。我就做了一个「论守门员扑出点球的正确姿势」的报告，这个报告经过俱乐部经理和几十名队员的一致通过。这个报告做了以后不久，2001 年的 7 月 1 日，意甲俱乐部就把我调到尤文图斯去了。 那么人呐就都不知道，自己不可以预料。一个门将的命运啊，当然要靠自我奋斗，但也要考虑到足协的历史行程，我绝对不知道我作为一个帕尔马替补门将怎么把我交换到尤文图斯去了。 所以里皮同志同我讲话说「俱乐部决定了，让你来当守门员」。我说另请高明吧，我实在也不是谦虚，我一个帕尔马新秀怎么到尤文图斯来了呢。但是呢，里皮同志讲「大家已经研究决定了」。所以后来我念了两首诗，叫「苟利球队生死以，岂因祸福避趋之」，那么所以我就到了意大利尤文图斯俱乐部。 在尤文图斯，我干了这十几年也没有什么别的，大概三件事： 第一个，作为主力门将参加了 2002、2006、2010、2014年的世界杯和 2004、2008、2012、2016年的欧洲杯。 第二个，严防死守！严防死守！为意大利夺得 2006 年世界杯冠军。 第三个，意大利历史上欧洲杯出场时间第一人。 如果说还有一点成绩就是「守门员最高转会费纪录保持者」，这个对我的历史定位有很大的关系的，因为我后来又带病续约踢了一年多，等于说我在尤文图斯干了十几年的核心球员。还有接任国家队队长也是很大的，但是这些都是次要的，我主要的就是三件事情。 很惭愧，就做了一点微小的工作，谢谢大家！]]></content>
      <categories>
        <category>蛤学</category>
      </categories>
      <tags>
        <tag>布冯</tag>
        <tag>欧洲杯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[漫话 C++11 之 condition_variable]]></title>
    <url>%2F2016%2F06%2F26%2F%E6%BC%AB%E8%AF%9D-C-11-%E4%B9%8B-condition-variable%2F</url>
    <content type="text"><![CDATA[condition_variable 是条件变量，通常和 mutex 搭配使用。 当 condition_variable 对象的某个 wait 函数被调用的时候，它使用 unique_lock 来锁住当前线程。当前线程会一直被阻塞，直到另外一个线程在相同的 condition_variable 对象上调用了 notification 函数来唤醒当前线程。 condition_variable 对象通常使用 unique_lock&lt;mutex&gt; 来等待，如果需要使用另外的 lockable 类型，可以使用 condition_variable_any 类。 123456789101112131415161718192021222324252627282930313233343536373839// condition_variable example#include &lt;iostream&gt; // std::cout#include &lt;thread&gt; // std::thread#include &lt;mutex&gt; // std::mutex, std::unique_lock#include &lt;condition_variable&gt; // std::condition_variablestatic std::mutex mtx;static std::condition_variable cv;static bool ready = false;static void print_id (int id) &#123; std::unique_lock&lt;std::mutex&gt; lck(mtx); while (!ready) &#123; cv.wait(lck); &#125; std::cout &lt;&lt; "id=" &lt;&lt; id &lt;&lt; std::endl;&#125;static void go () &#123; std::unique_lock&lt;std::mutex&gt; lck(mtx); ready = true; cv.notify_all();&#125;int main () &#123; std::thread threads[10]; // spawn 10 threads: for (int i=0; i&lt;10; ++i) threads[i] = std::thread(print_id,i); std::cout &lt;&lt; "10 threads ready to race...\n"; go(); // go! for (auto&amp; th : threads) th.join(); return 0;&#125; 只提供了默认构造函数。 wait、wait_for、wait_until 方法 type arg unconditional void wait (unique_lock&amp; lck); predicate template void wait (unique_lock&amp; lck, Predicate pred); 其中 pred 是一个可调用对象/方法， 它不接受任何参数 返回值必须可以被转化为 bool unconditional在线程被阻塞时，wait 函数会自动调用 lck.unlock() 来释放锁，使得其他被阻塞在锁竞争上的线程得以继续执行。 一旦当前线程被唤醒 notified，wait函数会重新调用 lck.lock()，使得 lck的状态和 wait 函数被调用时相同。 Predicate只有当 pred 条件为 false 时调用 wait() 才会阻塞当前线程，并且在收到其他线程的通知后只有当 pred 为 true 时才会被解除阻塞。 举个栗子下面是一个使用 pred 模式的 wait 实现的「单生产者－单消费者」模型： 12345678910111213141516171819202122232425262728293031323334353637383940// condition_variable::wait (with predicate)#include &lt;iostream&gt; // std::cout#include &lt;thread&gt; // std::thread, std::this_thread::yield#include &lt;mutex&gt; // std::mutex, std::unique_lock#include &lt;condition_variable&gt; // std::condition_variablestd::mutex mtx;std::condition_variable cv;int cargo = 0;bool shipment_available() &#123;return cargo!=0;&#125;void consume (int n) &#123; for (int i=0; i&lt;n; ++i) &#123; std::unique_lock&lt;std::mutex&gt; lck(mtx); cv.wait(lck,shipment_available); // consume: std::cout &lt;&lt; cargo &lt;&lt; '\n'; // notify cargo=0; &#125;&#125;int main ()&#123; std::thread consumer_thread (consume,10); // produce 10 items when needed: for (int i=0; i&lt;10; ++i) &#123; while (shipment_available()) std::this_thread::yield(); //wait cargo to be consumed std::unique_lock&lt;std::mutex&gt; lck(mtx); cargo = i+1; cv.notify_one(); &#125; consumer_thread.join(); return 0;&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++11</tag>
        <tag>condition_variable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[漫话 C++11 之 mutex]]></title>
    <url>%2F2016%2F06%2F26%2F%E6%BC%AB%E8%AF%9D%20C%2B%2B11%20%E4%B9%8B%20mutex%2F</url>
    <content type="text"><![CDATA[在多线程的程序中，经常需要通过锁的机制来保证数据的一致性。 C++11提供了下面四种语义的锁: type function desc mutex Lockable 普通的互斥锁，不能递归使用。 timed_mutex TimedLockable 带超时的互斥锁，不能递归使用。 recursive_mutex Lockable 递归互斥锁。 recursive_timed_mutex TimedLockable 带超时的递归互斥锁。 继承关系为： 123BasicLockable &lt;--- Lockable &lt;--- TimedLockable+lock +try_lock +try_lock_for+unlock +try_lock_until mutexC++11 中最基本的互斥量，它不支持递归地上锁。 mutex 不允许拷贝构造，也不允许 move 赋值，最初产生的 mutex 对象是处于 unlocked 状态的。 lock()，调用线程将锁住该互斥量。线程调用该函数会发生下面 3 种情况： 如果该互斥量当前没有被锁住，则调用线程将该互斥量锁住，直到调用 unlock之前，该线程一直拥有该锁。 如果当前互斥量被其他线程锁住，则当前的调用线程被阻塞住。 如果当前互斥量被当前调用线程锁住，则会产生死锁。 unlock()， 解锁，释放对互斥量的所有权。 try_lock()，尝试锁住互斥量，和 lock() 相似，不同的是如果互斥量被其他线程占有，则当前线程也不会被阻塞，而是马上返回 false。 recursive_mutex 允许同一个线程对互斥量多次上锁，来获得对互斥量对象的多层所有权。 释放互斥量时需要调用与该锁层次深度相同次数的 unlock()。 time_mutex 比 mutex 多了两个成员函数:try_lock_for()，try_lock_until()。 try_lock_for() 函数接受一个时间范围，表示在 一段时间范围之内 线程如果没有获得锁则被阻塞住，如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回 false。 try_lock_until() 函数则接受一个时间点作为参数，在 指定时间点未到来之前 线程如果没有获得锁则被阻塞住，如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回 false。 RAII关于 mutex 的使用，建议使用 RAII(Resource Acquisition is Initialization)的方式，即在构造的时候 lock, 析构的时候 unlock, 不建议直接手工地进行 lock/unlock。 C++11提供了 lock_guard 和 unique_lock 两种简单而又安全的上锁和解锁方式，即使程序抛出了异常，先前已被上锁的 Mutex 对象也能正确进行解锁，极大地简化了与 Mutex 相关的异常处理代码。 12345template &lt;class mutex&gt; class lock_guard;template &lt;class mutex&gt; class unique_lock; 都是模版类，实例化参数 mutex 必须是个 BasicLockable 类型(即支持 lock 和 unlock)。 都只负责在构造时对 mutex 加锁，析构时对 mutex 解锁，它们并不管理 mutex 本身的生命周期，因此，mutex 的生命周期应至少延伸至 lock_guard 和 unique_lock 析构之后。 lock_guard 只有构造函数和析构函数。 unique_lock 更灵活的初始化方式： default locking try_locking deferred adopting locking_for locking_until move 除了基本的上锁/解锁操作，unique_lock 还支持修改、获取 mutex 的操作： move 移动赋值 swap 与另一个 unique_lock 对象交换它们所管理的 Mutex 对象的所有权 release 返回指向它所管理的 Mutex 对象的指针，并释放所有权 owns_lock 返回当前 unique_lock 对象是否获得了锁 operator bool() 与 owns_lock 功能相同 5. mutex 返回当前 unique_lock 对象所管理的 Mutex 对象的指针 参考 http://www.cplusplus.com/reference/mutex/]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++11</tag>
        <tag>mutex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[漫话 C++11 之 thread]]></title>
    <url>%2F2016%2F06%2F25%2F%E6%BC%AB%E8%AF%9D-C-11-%E4%B9%8B-thread%2F</url>
    <content type="text"><![CDATA[熟悉C++的人知道，在经过了13年的漫长等待后，C++标准委员会终于在2011年通过了C++史上的第二个标准。 C++0x VS C++11，傻傻分不清楚从一开始到现在，C++大概经历了以下几个比较重要的阶段： 1998: ISO官方发布C++标准，俗称C++98，这是第一个C++的官方正式版本 2003: TC1(Technical Corrigendum 1)发布，俗称C++03, 这个版本可以当成是C++98的一个bugfix版本 2005：TR1(Technical Report 1)发布，TR1是一个新增加的库，增加了大约14种新的组件到C++标准中 2008：新C++标准(C++0x)草案发布，这个主要是以TR1的基础上进行了扩充 2011：C++0x标准通过 随着各种动态解释型语言的诞生，C++程序员也越来越感觉到了C++语言本身的一些局限性。以C++之父 Bjarne Stroustrup(没错，就是下面这个仙风道骨的老头) 为代表的先贤们，也一直在不遗余力的努力着，让C++更加强大。 于是他们商量着： 要么大伙每5年来一次华山论剑？ 好！果真，后来的C++大会基本上是5年一次，比如 2003年，2008年。 1998年C++标准发布后，原计划于2003年之后的几年推出新的标准，但由于没有确定具体哪一年发布，就用 0x原来表示的是04-09年中的某一年。 等到了2009年，新的C++0x标准却一致拖着没通过，直到2011年才通过，名称还保持叫C++0x： x表示是16进制的字符0-f，所以11也是x了。 所以说，C++0x和C++11，这俩就是一回事，只不过前者是个草案，而后者是正式通过的标准。 thread以前，由于 C++98中没有线程、锁、条件变量等这些与多线程相关的特性支持，如果需要写多线程程序，都要借助于不同平台上各自提供的 api，导致程序的跨平台移植性较差，经常要用一大堆的 #ifdef WIN32类似的宏来区分不同的平台，这样写代码的姿势很难看。 现在好了，使用 C++11 可以编写跨平台的多线程程序了，而且相比原来的 pthread写法，代码更简洁优美。 今天从 thread 开始，介绍下 C++11 带来的一系列新特性。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;thread&gt;using namespace std;class Foo&#123;public: void bar (int id, string&amp; name) &#123; name += "+1s"; cout &lt;&lt; "id=" &lt;&lt; id &lt;&lt; ",name=" &lt;&lt; name &lt;&lt; endl; &#125;&#125;;void func ()&#123; cout &lt;&lt; "thread func" &lt;&lt; endl;&#125;int main ()&#123; Foo foo; int id = 1; string name("elder"); thread th_1 (func); //thread func th_1.join (); thread th_2 (&amp;Foo::bar, foo, id, ref(name));//id=1,name=elder+1s th_2.join (); thread th_3 (bind (&amp;Foo::bar, foo, id, name));//id=1,name=elder+1s+1s th_3.join (); thread th_4 ([&amp;]&#123; foo.bar (id, name); &#125;);//id=1,name=elder+1s+1s th_4.join (); return 0;&#125; 上面是 thread 的四种构造方式： (1) 最简单，最常用的方式，直接传入一个普通函数。 (2) 变参模版方式，如果函数为类的成员函数，第一个参数是对象本身，后面的参数按函数调用时的顺序传入。注意，引用传递参数的话实参用 ref(arg) 包装。 (3) bind 方式，传入一个 std::function对象，同样地，如果是类成员变量的话，第一个参数是对象本身。 (4) lambda 方式，是比较常用的方式(先留个坑，以后再细述)。 thread 对象 不可被拷贝构造。 可以 ｀move｀ 方式构造，thread th(std::move(x)); 之后，新构造的 th 拥有原先 x 的执行对象，x 不再代表执行对象。 可被 joinable 的 thread 对象必须在他们销毁之前被主线程 join 或者将其设置为 detach。 thread 方法1.operator = 如果当前对象不可 joinable，将获取右值的执行对象，同时，右值将不再代表执行对象；如果当前对象可被 joinable，则 terminate() 报错。 123thread th;th = thread(func); //√th = th_1; //x 2.get_id() 如果当前对象不可 joinable，返回默认构造线程的id（0x0)；如果当前对象可被 joinable，则返回当前线程的 id。 3.joinable() 检测线程是否 joinable。当且仅当 thread 代表某个执行对象时，它才是 joinable的。下列条件下，属于 不可 joinable： a. 默认构造函数构造出来。对 thread th;而言，th 不代表任何 thread 执行对象。 b. 被作为参数给 std::move 调用。 c. 已经调用了 join 或 detach 函数。 4.swap(x) 交换当前线程和 x 的状态、执行对象等。 参考 http://www.cplusplus.com/reference/thread/]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++11</tag>
        <tag>thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[说好不分手，你怎么突然就脱欧了]]></title>
    <url>%2F2016%2F06%2F24%2F%E8%AF%B4%E5%A5%BD%E4%B8%8D%E5%88%86%E6%89%8B%EF%BC%8C%E4%BD%A0%E6%80%8E%E4%B9%88%E7%AA%81%E7%84%B6%E5%B0%B1%E8%84%B1%E6%AC%A7%E4%BA%86%2F</url>
    <content type="text"><![CDATA[我的经历就是，到了 2016 年中的时候，我的任期快到了，我想我应该脱欧，于是我就给默克尔总理、奥朗德总统，给他们写了一封信。 他们说欢迎你脱，不过，这个 apply for leaving，你要去发起一个公投，我就发起了一个《英国脱离欧盟趋势》的公投，这个公投经过好几千万英国人一致通过。 人呐就都不知道，自己不可以预料。一个人的命运啊，当然要靠自我的奋斗，但是也要考虑到历史的行程。 我绝对不知道，我一个左翼政党，怎么就带领脱欧了，所以伊丽莎白同志同我讲话： 王室都决定了，你来背这个锅。 我说另请高明吧，我实在也不是谦虚。我一个左翼政党怎么就背右翼的锅了呢？但是，伊丽莎白同志讲： 王室已经研究决定了。 后来我就念了两句诗： 苟利大英生死以，岂因欧盟避趋之。 所以我就脱离了欧洲。 当首相这几年我也没有干什么别的，大概三件事： 第一个，支持同性婚姻合法化。 第二个，搞了个苏格兰独立公投留住了苏格兰。 第三个，搞了个脱欧公投脱离了欧盟。 如果说还有什么成绩，那就是见证了一个穆斯林当上了伦敦市长，这对大英的绿化事业有很大的关系。还有 2012 年的奥运会也是贡献很大滴。但这些都是次要的，我主要就是这三件事。 很惭愧，就做了一点微小的工作，谢谢大家。]]></content>
      <categories>
        <category>蛤学</category>
      </categories>
      <tags>
        <tag>脱欧</tag>
        <tag>卡梅伦</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[libevent 的并发工作做得太好了]]></title>
    <url>%2F2016%2F06%2F18%2Flibevent-%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E4%BD%9C%E5%81%9A%E5%BE%97%E5%A4%AA%E5%A5%BD%E4%BA%86%2F</url>
    <content type="text"><![CDATA[我最近的工作呢，主要是在梳理我司核心平台的档案。 话说我司的这个后台，那可是牛逼的很啊。它作为基础设施，从无到有搞起来，前辈们把它撸得风生水起，支撑了其他产品的正常运转近十年。 系统的架构，小明在入职时就已经被培训过了，但是里面各个模块的细节却知之甚少。这段时间，计划把后台每个模块的代码 one by one 地啃一遍。这不，发现有好几个模块都用到了 libevent 这个库，但我之前没用过诶，为了看懂代码，必须要具备些 libevent 的基础知识。 libevent 是一个用C语言编写的、轻量级的开源高性能网络库。 主要有以下几个亮点： 事件驱动（ event-driven），高性能; 轻量级，专注于网络通信； 源代码相当精炼、易读； 跨平台，支持 Windows、 Linux、 Mac Os； 支持多种 I/O 多路复用技术； 支持定时器和信号等事件； 官网上列出了使用这个库开发的各种应用： 原来大名鼎鼎的 Chromium、Memcached都用到了它，真是 excited！ 看来，当初前辈们选用 libevent 也是一个英明的撅腚啊。 要了解 libvent 如何牛逼，首先要知道传统的 socket 通信是如何的弱鸡。 一开始，大家使用的都是阻塞式I/O函数，如果一个函数在操作完成之前，或者在超时之前，都不会返回，那么就说这个函数是同步的。 比如当你对一个 TCP 连接调用 connect()，你的操作系统会有一个队列，一个保存发送出去的SYN 请求的队列。然后对于每个 SYN 请求，系统尝试等待 TCP 另一端返回对应的确认码，即SYN ACK。在确认码 ACK 返回之前，或者直到超时，同步的函数是不会返回，称之为阻塞I/O。 下面有个使用阻塞I/O函数的例子，它打开一个连接，连接到 www.google.com，发送一个简单的HTTP请求，然后打印出返回内容到stdout。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/* For sockaddr_in */#include &lt;netinet/in.h&gt;/* For socket functions */#include &lt;sys/socket.h&gt;/* For gethostbyname */#include &lt;netdb.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;int main(int c, char **v)&#123; const char query[] = "GET / HTTP/1.0\r\n" "Host: www.google.com\r\n" "\r\n"; const char hostname[] = "www.google.com"; struct sockaddr_in sin; struct hostent *h; const char *cp; int fd; ssize_t n_written, remaining; char buf[1024]; /* Look up the IP address for the hostname. Watch out; this isn't threadsafe on most platforms. */ h = gethostbyname(hostname); if (!h) &#123; fprintf(stderr, "Couldn't lookup %s: %s", hostname, hstrerror(h_errno)); return 1; &#125; if (h-&gt;h_addrtype != AF_INET) &#123; fprintf(stderr, "No ipv6 support, sorry."); return 1; &#125; /* Allocate a new socket */ fd = socket(AF_INET, SOCK_STREAM, 0); if (fd &lt; 0) &#123; perror("socket"); return 1; &#125; /* Connect to the remote host. */ sin.sin_family = AF_INET; sin.sin_port = htons(80); sin.sin_addr = *(struct in_addr*)h-&gt;h_addr; if (connect(fd, (struct sockaddr*) &amp;sin, sizeof(sin))) &#123; perror("connect"); close(fd); return 1; &#125; /* Write the query. */ /* XXX Can send succeed partially? */ cp = query; remaining = strlen(query); while (remaining) &#123; n_written = send(fd, cp, remaining, 0); if (n_written &lt;= 0) &#123; perror("send"); return 1; &#125; remaining -= n_written; cp += n_written; &#125; /* Get an answer back. */ while (1) &#123; ssize_t result = recv(fd, buf, sizeof(buf), 0); if (result == 0) &#123; break; &#125; else if (result &lt; 0) &#123; perror("recv"); close(fd); return 1; &#125; fwrite(buf, 1, result, stdout); &#125; close(fd); return 0;&#125; 上面使用的网络相关函数都是阻塞式的。 gethostbyname在成功解析域名www.google.com或超时前是不会返回的； connect在成功连接后才返回； recv接收数据才返回，或者对方关闭了sock也会让recv返回； send也阻塞，直到把数据复制到系统内核buffer之中。 如果你在同一时间内只做一个事情，I/O阻塞函数也没有什么不好。但假若你的程序里要同时响应多个连接，比如你需要同时从 2 个连接sock中接收数据，而且你不知道哪个数据先到来，那么，你不能这样写你的程序: 1234567891011121314/* This won't work. */char buf[1024];int i, n;while (i_still_want_to_read()) &#123; for (i=0; i&lt;n_sockets; ++i) &#123; n = recv(fd[i], buf, sizeof(buf), 0); if (n==0) handle_close(fd[i]); else if (n&lt;0) handle_error(fd[i], errno); else handle_input(fd[i], buf, n); &#125;&#125; 因为如果 fd[2]的数据先到来的话，这段代码不会想当然地马上去读取fd[2]的数据，因为I/O是阻塞的，它必须读取完 fd[0]和fd[1]的数据后才能读 fd[2]，而你并不能事先保证哪个 fd 上的数据先到来。 当然也可以使用多个进程/线程来处理每个sock，每个sock的数据处理互不影响，A进程阻塞了，并不影响到B进程的工作。 那么，这是最好的同时处理多个连接的方案吗？ 当然不是！ 首先，在一些平台上，创建一个进程/线程的代价是很昂贵的。实际开发中你会使用一个线程池，而不是创建一个新进程。不过，假若你需要处理数以千万个连接，维护这么多线程，性能也许没有你期待的那么美好。 使用线程不是最好的答案。在Unix下，你可以设置sock为非阻塞，使用函数fcntl： 1234567891011fcntl(fd, F_SETFL, O_NONBLOCK); //fd对应于sock的文件描述符(file descriptor)//其实一般先获取sock的flag，修改flag，再设置新的flag，如下大概 /* Set a socket as nonblocking */int flags; if ((flags = fcntl (fd, F_GETFL, 0)) &lt; 0) err_sys("F_GETFL error"); flags |= O_NONBLOCK;if (fcntl(fd, F_SETFL, flags) &lt; 0) err_sys("F_SETFL error"); 一旦你对sock fd设置非阻塞，那么对这个fd调用网络相关的函数，比如recv，函数会马上返回，这时你要检查返回码以及全局变量errno。 从多个sock读取数据的代码段如下： 123456789101112131415161718192021/* This will work, but the performance will be unforgivably bad. */int i, n;char buf[1024];for (i=0; i &lt; n_sockets; ++i) fcntl(fd[i], F_SETFL, O_NONBLOCK);while (i_still_want_to_read()) &#123; for (i=0; i &lt; n_sockets; ++i) &#123; n = recv(fd[i], buf, sizeof(buf), 0); if (n == 0) &#123; handle_close(fd[i]); &#125; else if (n &lt; 0) &#123; if (errno == EAGAIN) ; /* The kernel didn't have any data for us to read. */ else handle_error(fd[i], errno); &#125; else &#123; handle_input(fd[i], buf, n); &#125; &#125;&#125; 上面的代码也存在性能问题，2个原因： 如果没有数据到来，代码不断循环，不断消耗cpu； 每次轮询都会调用系统调用，因为有没有数据可以读取，一般是检查内核数据buffer，这个过程由系统调用帮我们做检查。我们不断轮询，每次产生系统调用的消耗，这明显不是很环保的做法。 我们需要更为智能的方式，当数据最后可读时让内核主动告诉我们。 最古老的方式是使用 select: 12345int select(int nfds, fd_set *restrict readfds, fd_set *restrict writefds, fd_set *restrict errorfds, struct timeval *restrict timeout); select 系统调用使用了3个sock fd集合， 分别对应： 可读的fd集合，告诉select请检查这个集合内的fd，若其中某一个可读，请select返回，告诉我集合中有多少个fd有数据可以读了，其它两个也是类似的意思； 可写的fd集合； 异常的fd集合； select 返回后使用 FD_ISSET 来测试具体是哪个 fd 有数据了。 1234567891011121314151617181920212223242526272829303132333435/* If you only have a couple dozen fds, this version won't be awful */fd_set readset;int i, n;char buf[1024];while (i_still_want_to_read()) &#123; int maxfd = -1; FD_ZERO(&amp;readset); /* Add all of the interesting fds to readset */ for (i=0; i &lt; n_sockets; ++i) &#123; if (fd[i]&gt;maxfd) maxfd = fd[i]; FD_SET(fd[i], &amp;readset); &#125; /* Wait until one or more fds are ready to read */ select(maxfd+1, &amp;readset, NULL, NULL, NULL); /* Process all of the fds that are still set in readset */ for (i=0; i &lt; n_sockets; ++i) &#123; if (FD_ISSET(fd[i], &amp;readset)) &#123; n = recv(fd[i], buf, sizeof(buf), 0); if (n == 0) &#123; handle_close(fd[i]); &#125; else if (n &lt; 0) &#123; if (errno == EAGAIN) ; /* The kernel didn't have any data for us to read. */ else handle_error(fd[i], errno); &#125; else &#123; handle_input(fd[i], buf, n); &#125; &#125; &#125;&#125; 但是，随着每个fd集合中fd数量的增多，每次检查也相应要花费更多时间。 另外，由于每个系统中可以监控的fd数目有限，FD_SET 其实是一个位数组，linux 默认是 1024 bit，而 FD_SET 只是简单的把 fd 当作一个序号按位向位数组写数据。所以当 fd 大于 1024时，将导致写越界，这是一个很容易被程序员忽视的坑，具体案例参考云风写的《一起 select 引起的崩溃》（http://t.cn/8FW0zXv）。 鉴于此，不同的系统提供不同的优化方案，包括poll, epoll, kqueue, evports, /dev/poll。 所有这些优化都能获得更好的性能，而且除了poll，其他的函数，增加、删除一个fd，或者测试sock是否可读写，这些操作都是O(1)的效率。 可惜这些优化的方案，都不是标准。 linux使用epoll，BSDs(包括苹果内核)使用kqueue，Solaris使用evports和/dev/poll， 致命的是，同个系统只使用他们的优化方案，不包括其他，比如linux上就没有使用kqueue。 所以，如果你想要写一个高性能异步I/O的程序，若考虑移植和跨平台，你还需要做一些额外的包装。 可喜的是，libevent 帮程序员做了上面提到的这些工作。 libevent 提供了一个比 epoll更为友好的操作接口，将我等程序员从网络I/O处理的细节中解放出来，让我们可以专注于具体业务的处理上。 看懂了吗？识得唔识得呀？这就是 libvent 的由来。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>libevent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[某榴开放注册3天？]]></title>
    <url>%2F2016%2F06%2F11%2F%E6%9F%90%E6%A6%B4%E5%BC%80%E6%94%BE%E6%B3%A8%E5%86%8C3%E5%A4%A9%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[现在的骗子真是防不胜防啊，小明差点就被骗了。 为什么说「差点」呢，机智敏锐的我最后还是洞悉了这个骗局。 案情回顾前几日，小明上飞鸟娱乐找电影看时，下载完一个种子的附件后，突然蹦出个对话框： 草榴开放注册 3 天 有这等好事？小明窃喜地点进去，整个网站的画风跟草榴一模一样，搞得就跟真的似的。 当时的我好开心啊，欲求一邀请码而不得，想不到它竟开放注册了： 赶紧注册个吧，注册页面搞得也跟真的似的： 注册完了，赶紧找好看的，嘻嘻～，only to find this： 要钱哪！ 冷静。毕竟是浸淫互联网十几年的老兵了，小明向来对敢伸手向我讨钱的网站保持了警惕，这个隐秘的骗子侧漏了它骗钱的真面目。 接下来，我首先向支付宝申诉了这个诈骗帐号： **yishi53850707@163.com** 再向腾讯申诉了这个 QQ 帐号： 570670475 这个诈骗网站不过是克隆镜像了真实的草榴社区，稍微做下手脚，利用男人好色的弱点，精虫上火，哪里顾得了甄别真假，估计有不少哥们被骗了吧。 你付了188元，使劲刷网页，它就是不给你看，每次都直接跳转到那个付费激活页面。再分析下那个注册页面，发现它只检测了“用户名是否已存在”，其他什么密码长度控制、邮箱格式验证全都没有，摆明了就是做个样子嘛。 比如，我注册时设置密码和邮箱都为“1”，他妈的居然也能注册通过？！ 除恶务尽，小明还亲自上中国互联网违法和不良信息举报中心 (http://www.12377.cn/) 不厌其烦地填了个表格举报它。 三套组合拳下来，我想我该做的都已经做了，好人一生平安。 男人的忠告男人好色没错，一时精虫上脑找个片子解渴也无可厚非，不过要多留个心眼。 wo.c6zc.com 这是个诈骗网站。 1024，即便不注册也能浏览大部分帖子的，你傻啊～]]></content>
      <categories>
        <category>心旷神怡</category>
      </categories>
      <tags>
        <tag>草榴</tag>
        <tag>1024</tag>
        <tag>注册</tag>
        <tag>诈骗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[没有什么是「一颗赛艇」不能解决的，如果有，那就两颗]]></title>
    <url>%2F2016%2F06%2F07%2F%E6%B2%A1%E6%9C%89%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E9%A2%97%E8%B5%9B%E8%89%87%E8%A7%A3%E5%86%B3%E4%B8%8D%E4%BA%86%E7%9A%84%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9C%89%EF%BC%8C%E9%82%A3%E5%B0%B1%E4%B8%A4%E9%A2%97%2F</url>
    <content type="text"><![CDATA[前几天深谈了关于 fuck 的那些事，今天来聊一聊 fuck 它远房表哥：fork。 fork 和 fuck 实为远亲，彼此往来也不多，只在饶舌上有异曲同工之妙。 fuck 常出没于美式口头俚语，fork 则在计算机世界纵横驰骋。 fork 是 Unix 内核创建一个新进程的唯一方式，新建的子进程 拷贝 父进程的数据空间、堆、栈等信息，这也是 fork 函数命名的由来。 fork 完成之后，究竟是父进程先执行还是子进程先执行是不确定的，这取决于内核的调度算法，因此，有可能出现这些情况： 孤儿进程孤儿进程是指父进程在子进程结束之前 over (return 或 exit)。 但是孤儿进程并不会像上面画的那样持续很长时间，当系统发现孤儿进程时，init 进程就收养孤儿进程，成为它的父亲，child 进程 exit 后的资源回收就都由 init 进程来完成。 僵尸进程僵尸进程是指子进程在父进程结束之前 over 了，但是父进程没有用 wait 或 waitpid 回收子进程。 子进程在结束的时候会给其父进程发送一个 SIGCHILD 信号，父进程默认是忽略 SIGCHILD 信号的，如果父进程通过 signal() 函数设置了 SIGCHILD 的信号处理函数，则在信号处理函数中可以回收子进程的资源。 事实上，即便是父进程没有设置 SIGCHILD 的信号处理函数，也没有关系，因为在父进程结束之前，子进程可以一直保持僵尸状态，当父进程结束后，init 进程就会负责回收僵尸子进程。 但是，如果父进程是一个服务器进程，一直循环着不退出，那子进程就会一直保持着僵尸状态。虽然僵尸进程不会占用任何内存资源，但是过多的僵尸进程总还是会影响系统性能的，极端情况下会耗尽系统的可用进程数，导致无法再新建进程。 黔驴技穷的情况下，该怎么办呢？ 两次fork为了防止系统中产生僵尸进程, 两次fork 是常用的技法，原理如下： 《UNIX环境高级编程》这本书里提供了现成的代码： 12345678910111213141516171819202122232425262728293031323334# include &lt;sys/types.h&gt;# include &lt;sys/wait.h&gt;# include "ourhdr.h"int main(void) &#123; pid_t pid; if ( (pid = fork()) &lt; 0) err_sys("fork error"); else if (pid == 0) &#123; /* first child */ if ( (pid = fork()) &lt; 0) err_sys("fork error"); else if (pid &gt; 0) exit(0); /* parent from second fork == first child */ /* We're the second child; our parent becomes init as soon as our real parent calls exit() in the statement above. Here's where we'd continue executing, knowing that when we're done, init will reap our status. */ sleep(2); printf("second child, parent pid = %d\n", getppid()); exit(0); &#125; if (waitpid(pid, NULL, 0) != pid) /* wait for first child */ err_sys("waitpid error"); /* We're the parent (the original process); we continue executing, knowing that we're not the parent of the second child. */ exit(0); &#125; 执行程序得： 1$ second child, parent pid = 1 这里有个需要注意的地方： 第二个子进程中调用 sleep 保证在打印其父进程时第一个子进程已终止。因为 fork 之后，父、子进程都会继续执行，我们无法确保孰先孰后。如果不使第二个子进程 sleep 一段时间，则 fork 之后，它可能会比其父进程先执行，于是，它打印的父进程将是创建它的进程，而不是 init 进程（进程ID为 1）。 可以看出，两次 fork 之后，系统没有产生僵尸进程，子进程死了也就死了吧，孙子进程进孤儿院了，最重要的是，我们那个永不死的服务器进程甜蜜地笑到了最后。 你死我都未死啊！]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>fuck</tag>
        <tag>一颗赛艇</tag>
        <tag>fork</tag>
        <tag>僵尸进程</tag>
        <tag>孤儿进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五年高考,三年模拟 | 来做道语文阅读理解]]></title>
    <url>%2F2016%2F06%2F06%2F%E4%BA%94%E5%B9%B4%E9%AB%98%E8%80%83-%E4%B8%89%E5%B9%B4%E6%A8%A1%E6%8B%9F-%E6%9D%A5%E5%81%9A%E9%81%93%E8%AF%AD%E6%96%87%E9%98%85%E8%AF%BB%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[马上要高考了，作为一个老司机，我来给你们传授点高考的人生经验！（敲黑板） 临时抱佛脚，也要看什么脚：偏题难题都别做了，做了也没用，赶紧背重点公式、古诗词、重点单词。 身份证、准考证、各种笔、尺子、圆规、鸭嘴笔什么的，盘点好，放进专门的袋子里！ 黑色中性笔，保证水充足，2B铅笔买两支！ 会的题，保证做对。不会的题，别空着。尽量别犯“会而不对，对而不全”的毛病。 文科，挨边的条款，一条一条往上写，一定要条理清晰；理科，沾边的公式就往上列，写满。阅卷老师都是按条给分的，一天要改几千份卷子，万一谁眼一花手一抖就把分给你了呢！ 审题，一定要小心。看清人家让选正确的还是错误的，最大的还是最小的！英语答题卡，ABCD四个选项，每个选项加起来的数几乎是一样的，所以，遇到不会的，你就选C，肯定还有能蒙上的分！ 最后，背了那么多浆糊到脑袋里，来做道语文阅读理解洗洗脑吧。 前情提要： 《把伤痕当酒窝》是著名独立音乐人许嵩读高二时看到余秋雨的同名文章后，联系自己的亲身经历，有感而发之作，之后被作为江苏省高考语文模拟试卷的阅读题目。 阅读下面的文字，完成1-5题。 我伸了一下懒腰，望着窗外阴暗的天。快要下雨了，而此时已近黄昏。 心情不错。是的，我搬家了。 桌前放着一本书，其中的一章，标题赫然是《把伤痕当酒窝》。正当我准备看看这个标题背后的内容时，父亲叫我：出去找一个拾废品的人来，家里正有一堆没用的旧东西。 下了楼，我走在一条极其平凡的街道上。一些高雅人士所鄙薄的低俗人等，全部在这条街上济济一堂，先是五家大排档，然后是一排小吃摊，再过去就是农贸市场。这些人有时的确粗俗，譬如他们的三轮车撞到你却不说对不起只是表情怪异的一笑；譬如你买东西跟他们讨价还价到最后他们会蛮横的说，我不卖了。后来我渐渐想通，前者是因为他们还没学会城里繁琐的礼貌用语，因此他们只能投以抱歉的微笑，但是这一笑遭遇到了城市人翘起的嘴角和傲慢的眼神，所以这个笑容顿时变味；后者更好理解，因为城市人砍下的价格已然超过了他们接受的底线。 一个老人缓缓的从我身边走过。一手牵着条狗，另一只手里搓着健身球，背部倔强的挺直，眼角流露出幽默的笑意。 这种笑意的内涵，正由这条平凡的街道默默的诠释着。 拾破烂的终于在这里被我搜索到。这位老人头发全白，我很少看见如此纯粹的白了，一种慈祥的感觉洋溢在他的脸上。他的身后，悠悠然跟着一个孩子，这是老人的孙子。 天更暗了，一些雨点开始打落在我们的脸上，我们三个默然前行，再也没有说话。 到家了。老人嘱咐孩子等着，然后随我上楼。进门时我发现老人的鞋子很脏，我不希望他将泥土带进我的新家。老人似乎明白，脱下鞋子，赤着脚进来。虽然这时早已立秋，天气转凉。 父亲让他稍坐，便进房里整理废品，只剩我和他孤坐客厅。忽然想起晚上我要上课，便丢下老人自己到房里穿戴整齐。 然后准备出发。我觉得我应该戴上手表。一个中学生的时间，若不珍惜，很容易从指尖溜走。 这时老人已把东西弄好，付了钱，准备走。父亲见外面雨大，便让他稍作歇息。他没推辞，便和父亲随便聊聊。 他的孩子的父母死了。孙子八岁，还没上学。此时，他们还没吃饭。 托尔斯泰说幸福的家庭总是相似，而不幸的家庭却各有各的不幸。我认为恰恰相反。富裕的家庭能营造不同的环境，所以多样；不幸的家庭总是相似，因为单一。 他们说这些话的时候，我在找我的手表。我很不愿意这样想，老人拿了我的手表。因为有两个证据：其一，我记得我的表就放在老人坐的椅子旁边；其二，老人的裤子口袋里露出一截银光闪闪的东西，我想那是我的表带！ 我不鄙视穷人，但是穷人要是不知自重，我们也不必怜悯。而且我没有时间等了。想到这儿，我很有风度地说，老人，请还给我，我的手表。 我认为这是我平生说过的最委婉的一句话，能把对他的伤害降到最低限度。我之所以这样做，因为我想他可能只是一时糊涂，顺手牵羊，我们不必大动干戈。 老人看看我，忧伤的沉默。我想他一定为他罪行的败露感到可耻。 然而父亲还没懂得我的意思，竟然问我，你在说什么？我很平静的重复了一遍。 父亲责令我住嘴。然后令我把他的包拿来，我知道事情可能会有点微妙的变化。 打开包，我的手表。原来父亲今天上班时看见我的表不走了，就拿去表店换了一块电池。 我何以那么草率的认为是老人拿了手表呢？我说我不鄙视他们，然而骨子里对他们还是信任不过的。是的，我以小人之心，度君子之腹了。 正当我准备道歉，老人笑了。这种幽默的笑意，似曾相识。我不知道他为什么而笑，这种笑意的内涵，正由他伸向裤子口袋的手默默的注释。他掏出来了，不是我认为的“表带”，只是一个不锈钢的勺子！ 我不知道我的话对他造成了多少伤害。对于一个贫穷的人，最大的侮辱莫过于说他用不正当的手段去摆脱贫穷。 然而我对他的这种伤害，被他化为了一个笑容。 《把伤痕当酒窝》这篇文章我还没看，但是我已经找到了最好的解释。 雨更加大了，祖孙俩推着车子一路小跑,而他们的背影也开始渐行渐远，消失在我的眼前，模糊了视线，天空升起了一颗早熟的星星，而那黑夜，也在重重的幕帘后面静静的注视着一切，不忍心走来。 阅读理解： 1.“托尔斯泰说幸福的家庭总是相似，而不幸的家庭却各有各的不幸。我认为恰恰相反。富裕的家庭能营造不同的环境，所以多样；不幸的家庭总是相似，因为单一。”为什么“不幸的家庭各有各的不幸”作者却认为恰恰相反？ 2.“《把伤痕当酒窝》这篇文章我还没看，但是我已经找到了最好的解释。”“最好的解释”指什么？作者以“把伤痕当酒窝“为题，有何用意？ 3.写出下列句子的含义（1）天空升起了一颗早熟的星星，而那黑夜，也在重重的幕帘后面静静的注视着一切，不忍心走来。（2）这位老人头发全白，我很少看见如此纯粹的白了，一种慈祥的感觉洋溢在他的脸上 4.“眼角流露出幽默的笑意”“正当我准备道歉，老人笑了。这种幽默的笑意，似曾相识”这幽默的笑意究竟指什么？为什么说它幽默？ 5.作者能够理解所谓“粗鄙之人”而又说“骨子里对他们还是信不过的”，这是否矛盾？为什么？ 参考答案： 因为不幸的家庭在物质上缺乏，紧接着而来的就是灾难，不幸，贫穷，幸福的家庭物质上有基础，他们会得到快乐，无论是物质上的，还是精神上的。 最好的解释是指用乐观宽容来面对伤心，受到的侮辱。用意是1.点明主旨2.把文章的题目与自己的经历相结合，使题目得到最好的诠释。 3. 1.通过拟人手法，说明星星和黑夜是有情有意的；通过环境描写来烘托人物感情，表达了作者对老人和他的孙子的希望。 2.作者通过外貌描写说明了老人的人格纯粹，慈祥，说明了老人的善良，从而反衬出我的内疚与自责。 幽默的笑意指用善良的心地、乐观，来面对生活中的不如意。幽默的原因：自己遭受了误解，一笑置之，巧妙转移话题，注意力，使大家不陷入尴尬。 不矛盾，作者能理解粗鄙之人，所以以为他们可能是顺手牵羊，一时糊涂，有不良的生活习惯，认为他们能偷手表是正常的是以小人之心夺君子之腹；从而表现老人的纯洁的心。]]></content>
      <categories>
        <category>心旷神怡</category>
      </categories>
      <tags>
        <tag>高考</tag>
        <tag>许嵩</tag>
        <tag>阅读理解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[坏蛋不是道德水平低，而是格局小]]></title>
    <url>%2F2016%2F05%2F31%2F%E5%9D%8F%E8%9B%8B%E4%B8%8D%E6%98%AF%E9%81%93%E5%BE%B7%E6%B0%B4%E5%B9%B3%E4%BD%8E%EF%BC%8C%E8%80%8C%E6%98%AF%E6%A0%BC%E5%B1%80%E5%B0%8F%2F</url>
    <content type="text"><![CDATA[今天分享的是罗辑思维第 162 期《南明死局·二》，受益颇多，在此记录下心得。 这期节目以明末四大奸臣之一的阮大铖为入口，从文官的角度再来审视一下南明这个时代。 阮大铖，有才，自是不必多言，作为一个能导、能演、能唱的昆曲全才，用“才华横溢”四字形容之，一点也不为过，倘若生在当今，张艺谋大导演，就是个屁了！ 可惜他最终留给世人的是一个大坏蛋的面孔，由于他为人奸佞，品格低下，乡里后人深以为耻，他的籍贯居然出现了“桐城不要，怀宁不收”的情况，《奸臣传》以他作为压轴，可见其奸的分量。 坏蛋不是一天炼成的，起码他在 29 岁中进士前，毫无劣迹啊？ 那么，坏蛋又是如何炼成的？ 过去我们都以为坏蛋坏是因为道德水平低，这期节目提出了另外一个维度的原因：「格局小」。 格局小怪个人吗？有的时候其实是环境使然。 举一个例子：高考备战，班上有些同学非常勤奋，晚上做作业、复习功课到深夜，但是第二天早上到了班上，做的第一件事就是告诉大家，自己昨晚看了一晚上电视，一页书都没看。 这不就是想对同班同学使障眼法吗？其实谁都明白，高考这件事情是在全省、全国的高三学生中展开竞争，根本不是和身边这帮人竞争。但是人就是有这个本能，明知战场不在身边，也想要赢过身边这群人。 所以有那么一句话： 了解一个人的趣味，看他的配偶——她的先生或者他的太太；了解一个人的品格，看他的朋友；但是了解一个人的能力，要看他的对手。 人其实是会被整个环境驯化的，你找到什么样的对手，进入什么样的格局，你自己的境界就有多高。 所以，南明破败不是因为它能力差，也不是因为它资源少，这个政权其实还拥有很多战略回旋的余地。但是为什么南明的弘光政权崩溃得那么快？就是因为常年的皇权制度的打造，到了明末的时候，它已经变成了一个所有要素都封闭在一起的小系统。 这个系统小到什么程度？就是它所有的构成要件——不管是阉党还是东林党，都以对方为唯一对手。东林党如果以阉党为唯一对手的话，它的能力就被锁死在阉党这个水平上。没有人真正为家国天下奋斗，这个大目标所有人都忘了。 就算东林党道德水准比较高，将来在历史上的名声比较好，那又怎样？从整个系统演化的角度看，它起到的作用其实和阉党差不多，都是以对方为对手，以打赢对方为首要的甚至是唯一的目标。整个组织的大目标大家都忘了，所以南明的崩溃其实双方都有责任。 就像很多大公司，内部矛盾比外部矛盾还要大，而且管理越严密、组织机构越发达，这个现象就越明显。大公司内两个部门之间想达成协作比登天都难，有的部门要做一件事，明摆着组织内部有合适的资源，但是没法用，因为太难了。它宁愿在外面找一个供应商，花钱外包都比内部协作要容易得多。 所以大公司要达成一个既紧急又重要的目标时，就不得不从各个部门中抽人，成立一个临时的组织，再来达成这个目标。结果，组织进一步变得庞大：这真是大组织的宿命。 我并不想批判大组织，只是想问： 一个人想要不变成坏人，他应该做什么？ 有两件事: 多读书，读好书，多接受些新知识 君子不立于危墙之下 相比而言，后者其实更加重要，如果你所在的公司或者机构出现了管理僵化或走下坡路的情况，你千万不能在里面待着，否则，不仅你的发展会受到限制，你的道德水准也会下降。 因为一个处于下坡状态的系统，里面的明白人、聪明人、优秀的人早就跑了，你再在里面待下去，就没有人可以学习了，你所处的环境本身在恶化，你的生存空间也在被压缩，资源进一步稀缺，我们会怎么办呢？ 团结起来就能共渡难关吗？可能会有这种情况。但是更普遍的状况是什么？我们受人性驱使，变得鼠目寸光，只看得到这个系统内部的结构，然后和身边的人争抢资源，和其他部门恶斗，而且越斗越往下探道德底线。 好在，我们生活在一个自由的时代，如果发现自己身处在一个不断恶化的小系统中，我劝你赶紧走，不仅是为自己的生路，也是为自己的灵魂找到一个向上的空间。 调整自己的生存处境是我们生存智慧的体现。 如此所言： You should live according to what you think,or you will think according to your life.你要按所想的去生活，否则，你迟早会按你生活的去想。]]></content>
      <categories>
        <category>指点江山</category>
      </categories>
      <tags>
        <tag>管理</tag>
        <tag>罗辑思维</tag>
        <tag>创业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对于下流的你来说，Fuck 实在是太纯洁了]]></title>
    <url>%2F2016%2F05%2F29%2F%E5%AF%B9%E4%BA%8E%E4%B8%8B%E6%B5%81%E7%9A%84%E4%BD%A0%E6%9D%A5%E8%AF%B4%EF%BC%8CFuck-%E5%AE%9E%E5%9C%A8%E6%98%AF%E5%A4%AA%E7%BA%AF%E6%B4%81%E4%BA%86%2F</url>
    <content type="text"><![CDATA[在小明看来，没有什么问题是不能光明正大地拿到台面上研究的，今天我就要来涨点关于 fuck 的姿势。 对于经常看美剧的小盆友们来说，印象最深的台词估计非 Fuck 莫属了。Fuck 它在美国人的口语中出现的频率之高，相当于「我靠」（部分民风彪悍的地区或已演化成「我操」） 之于汉语，「阿西吧」之于韩语，「屌久埋」之于我老家的汝城话。 不管地域习俗有多大差异，人类在选择脏话的品味总是出奇的一致，骂人带生殖器是人类作为动物的后裔共有的恶趣味之一，半斤八两，谈不上谁比谁 low 到哪里去。 但坦白而言，相比起中文里单独的一个「操」字，英语里「Fuck」这个词更具节奏感和韵律美，因为每当姑娘朝我喷出这个词的时候，她们总会先用牙齿咬住下嘴唇，再随着声音的发出松开，让这个词洋溢着别样的性感。 Fuck 一开始就是用来骂人的，骂人也是 Fuck 这个单词最基本的功能属性，这点我相信没人会反对。但年少无知的我们可能只知其一，不知其二，Fuck 的内涵，源远流长，博大精深，并没有你们想象的那么简单。 在韦式词典中，Fuck 一词多义，可为及物动词、非及物动词、名次、副词、形容词、语气助词。而某度字典的解释就粗俗得很，短短的5个字翻译：「与某人性交」，格调之低，可见一斑。 引经据典 fuck 考最常见的，当然是做动词啦。 Fuck you! 去死吧！ Let’s fuck. 我们约炮吧。 Oh, fuck it! 算了吧！ Fuck me在不同的语气、不同的前后文，其意义差别很大。 不情愿的承认自己犯错 It’s my fault. Fuck me. 是我的错，你来咬我啊？！ 表示惊讶 Oh, fuck me. 这里是「我艹」的意思，而不是「艹我」，千万别搞反了，表示厌恶，类似「sth disgusts me」 情况很糟糕 Oh! Fuck me! I’m sorry for being late. 噢！糟糕！抱歉我迟到了！ fuck 做名词有一丁点儿；感叹词；搞 XXOO 的人等含义。 What the fuck? 搞什么东西？！ Shut the fuck up. 闭嘴。 Mary is a terrific fuck. 玛丽是個美丽尤物。 What the fuck is wrong with this guy? 这家伙是有什么问题？ Who the fuck are you? 你是哪根蔥？ I don’t give a fuck! 我一点都不在乎！（和 I don’t give a shit! 意思相同） fucking用作副词或形容词，意为该死的；讨厌的；令人难以置信地；非常地。 Take your fucking hand off me! 拿开你该死的脏手！ What a fucking beautiful scenery! 多么美丽的的风景！ Fucking hell…It hurts a lot! 该死的…我好痛！ This cake is fucking amazing. 这蛋糕真是超级好吃。 Where are all the fucking mosquitoes coming from? 这些该死的蚊子是从哪里來的？ Emily has finished all the fucking work. 艾米莉把所有烦人的工作都做完了。 I fucking hate you. 我恨死你了。 当我们使用 fucking 来强调「非常好」或是「非常不好」的情绪時，这时的 「fucking」 也可以用 「freaking」 代替。这样可以巧妙的避开 「fucking」 的字眼，却依然有一样的效果。 This is fucking (freaking) amazing! 还可表示时间： It’s five fucking thirty. 5点半 放在一个动词的中间（注意这种用法哦，国内较少见），起增强语气的作用： fan-fucking-tastic：真是太棒 un-fucking-believable：真是不敢相信 congratu-fucking-lations：真是恭喜 fuck up混乱的；搞砸的；坏掉的；教训（人）；（人）喝醉；（人）很烦、头昏脑胀的。 和常听到 「screw up」 意思相似，更加文雅的用法是 「mess up」。 I’m fucked up. I didn’t do my Economics homework!我死定了，我沒有做我的经济学作业！ The failure totally fucked him up.失败使他一蹶不振。 I fucked up the exam.我考试考差了。 This computer is completely fucked up.电脑完全坏掉了。 Good luck and don’t fuck (it) up.祝好运，別搞砸了！ fuck 和 up 结合成的名词 fuck-up，可以用來指经常 (搞砸)事情的人或做事不牢靠的人。 Sam is a fuck-up. He fucks up everything. 山姆是个常常搞砸事情的人。 fuck off很不客气地叫人走开、滚开的意思。 Get the fuck off my car! 滚开我的车！ fuck around鬼混；瞎闹 Hey! Stop fucking around.嘿！別闹了！ fuck with玩弄；欺骗；干涉。 Don’t fuck with me. 为什么有时候看到电影里的男主角对男的也这么说？人家当然不是玩断背啦，意思是「你玩不过我，最好别惹我」。 I can’t believe that John likes to fuck around with girls. 我真不敢相信约翰喜欢和女生乱搞。 活学活用如你所见， fuck 并没有那么污，下次再在美剧、电影中听到 fuck 就别只往那方面想了，即使人把 fuck 当口头禅，你也别反射弧地鄙视人家素质低，说到底，要联系人物所处的具体情境，看看人家到底想表达什么意思。 比如，下面两个栗子出现了这么多 Fuck，各代表什么意思？ Fuck you. What the FUCK do you know? You don’t know anything. Everything you know is a FUCKING lie！ Fucking is one of those fucking words you can fucking put any fucking where in a sentence and still fucking makes sense.]]></content>
      <categories>
        <category>心旷神怡</category>
      </categories>
      <tags>
        <tag>fuck</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Segmentation fault:inet_ntoa 崩溃咯]]></title>
    <url>%2F2016%2F05%2F24%2FSegmentation-fault-inet-ntoa-%E5%B4%A9%E6%BA%83%E5%92%AF%2F</url>
    <content type="text"><![CDATA[今天来记录个小问题，应该说是个「坑」。 写了个 socket 通信程序，在我 64 位的 Mac mini 上，调用 inet_ntoa 函数产生段错误 Segmentation fault: 11 。 出错的地方就在这行代码： 1printf("accept a new client from: %s\n", inet_ntoa(client_addr.sin_addr)); 把它注释再跑就 OK，干掉注释再跑又崩溃……试了好几次，每次都如此。 Surpried？！ 坑inet_ntoa 把网络地址转换成字符串(如 192.168.8.168)，返回 char *，我 printf 用 %s 格式化它，应该没错啊…… 后来，我发现编译时有几行信息都是关于这个 inet_ntoa 函数的： 看到了没，不仅 inet_ntoa，inet_aton 也相应地给出了警告，前面两行翻译成人话就是： inet_aton 函数声明非法，inet_ntoa 函数声明非法。 更离谱的是，最后一行居然说类型不匹配，inet_ntoa 返回类型为 int？ 一瞬间，我凌乱了，学了这么多年的 C 语言，不知道这 inet_ntoa 玩的是哪一出啊。 man 一下 inet_ntoa 看，其中有一行特别重要： These include files are necessary for all functions. 原来啊原来，这几个头文件都需要 include 进来！ 而我的程序中，漏掉了最后一行 #include &lt;arpa/inet.h&gt;，赶紧加上，再编译、运行，呵呵～ 感兴趣的，可以拿下面这个个小 Demo 感受下： 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;//#include &lt;arpa/inet.h&gt;int main(int argc,char *argv[])&#123; struct sockaddr_in cli_addr; char *some_addr; inet_aton("127.0.0.1", &amp;cli_addr.sin_addr); some_addr = inet_ntoa(cli_addr.sin_addr); printf("%s\n", some_addr); return 0;&#125; 善待警告在老版本的 C (如 C98,C99)语言中，如果你在使用 inet_ntoa 函数前没有 #include &lt;arpa/inet.h&gt; ，在某些 64 位系统上它的返回类型为 int，%s 遇上 int，怪不得会 segmentation fault了…… 这他妈真是个坑，也不知道是谁设计的，既然要 include 这三个文件才能用这个函数，那你就别让我编译通过给个 error 行不行？ 这就回到了一个好的编程习惯的问题了： 不要忽略代码中出现的告警，有些警告其实就是错误。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Segmentation fault</tag>
        <tag>inet_ntoa</tag>
        <tag>warning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《罗辑思维·南明死局一》心得]]></title>
    <url>%2F2016%2F05%2F21%2F%E3%80%8A%E7%BD%97%E8%BE%91%E6%80%9D%E7%BB%B4%E2%97%8F%E5%8D%97%E6%98%8E%E6%AD%BB%E5%B1%80%E4%B8%80%E3%80%8B%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[今天在家啃了几十页的《Unix 环境高级编程》，内力消耗过度，感觉有轻度的头昏脑胀，我想不能再这样修炼下去了，得换个姿势调节下大脑。 于是，我打开了很久没跟看的《罗辑思维》，这次看的是第 161 期《南明死局·一》，受益颇多，在此记录下心得。 熟悉中国历史的人都知道，1644 年，这一年特别热闹：5 个皇帝，你方唱罢我登场。什么国破家亡、文化沦丧、才子佳人、忠臣逆子……几乎所有能够调动起人们肾上腺激素的故事情节，在这一年都可以找到。 这期节目借南明这段短暂的历史，用理性而非情绪化、道德化的角度来剖析它，讨论了中国古代政治系统和现代管理学方面的知识。 中国古代政治系统的演化中国古代的政治系统是一项高科技成果，历代帝王对此均有贡献。两千多年的封建社会，一个大的趋势是：皇权逐渐扩张，集权化越来越明显。 但是，在皇权一路加固的过程中，这个系统变得越来越脆弱。 唐代之后，中原的汉人政权都毁于外族，一个是宋朝，一个是明朝。宋朝的对手是蒙古人，没办法，全世界都打不过他们；可是明朝的对手是满清，非常弱，怎么也打不过呢？ 当一个系统的内部越加稳固的时候，它对外的抵抗力就越差。 如果把权力放在一个更大的系统来看，权力也是人类的一种协作机制，想要稳固权力就必须跟更多人协作。 集权的协作问题就出在它是一种试图单向控制的系统。 这就带来两个后果： 在集权的过程中，必然伴有分权过程。 天下所有事都管，皇帝一个人管得过来吗？权臣、太监、外戚……总会在某个王朝的某个阶段扮演重要角色。 越集权，带来的反制力越大。 良性的反制，好比“无为而治”，皇帝把国家大事交给管事大臣去大理，不做过多干预。 恶性的反制，好比“断头政治”，活儿你们都干了，要我干什么？皇帝干脆罢工像万历那样几十年不上朝。 更恶性的反制叫“起哄政治”，文官卖直，只要是皇帝坚持的，他们就反对，为了反对而反对。 在这个系统中，当皇权强悍到一定程度，它激发起的其他因素（权臣、太监、外戚）的反制能力也会霸道和强悍到一定程度。它们的存在就是为了对付皇权，而对付任何系统性的外来危机，它们却毫无力量。 为什么好公司一定没有好管理由南明联想到我们这一代人的生存处境，有一点很相同：外部环境极其动荡，瞬息万变。 现在的市场上有两种公司：一种管理得特别好，但越是管理得好的公司，应对转型的能力往往就越差，比如诺基亚；另一种公司，屁滚尿流，丢盔卸甲，内部极其混乱，但是一路奔向成功，比如小米。 难道管理越坏，公司就会越好吗？非也。 过去我们都以为”好管理是好公司的原因”，某位牛人却说： 好管理是一家坏公司的结果。 这里的“坏”，是指公司内部的信任结构非常糟糕，是基于对人的不信任，公司把员工、所有的创业伙伴都当作诱饵来进行管理，设置各种名目繁杂的规章制度，因而从外面看上去显得管理特别完善。 据两个常见的例子： 很多管理非常严格的公司，各个部门都是有预算的，不同级别的干部请客吃饭有不同的额度限制。到年底是什么情况？一定是各部门突击花钱，因为员工与公司的信任建立在规章制度这个层面上，员工当然要把自己的权力全用足。 很多新员工刚进公司往往非常积极主动，完全是那种自发型的，但是那些规章制度偏偏就不信任你，把你引向不自觉的轨道上来管理你，几次下来人就没有冲劲了，规规矩矩每天撞钟就行了。 明朝是不是也是这样一家坏公司呢？因为互相之间缺乏信任，所以皇权变得极其强大。这个王朝君臣之间的信任基石一步步崩盘，到了南明的时候，一个小小的言官都可以公开质疑皇帝本身的合法性了。 反过来讲，为什么好公司就一定没有好管理？ 因为不需要，因为互相之间可以信任。 好公司就是成人之间的公司。 大家基于相同的价值观聚集在公司这个临时的社会协作体中，彼此相互信任，以成年人的思维方式、处事方式团结合作，这种公司的做事效率最高，其管理成本反而是最低的。 所以，基于不信任的控制、管理方式适用于应对内部危机，而今天这个社会，对于大多数中小企业而言，我们主要是应对外部的危机，需要公司这个组织有战斗力，要在和同类公司之间的竞争中打硬战、打胜战，那就需要一种全新的思维模式。 那就是反过来，我们要 基于信任去构建一个协作系统。 思考小公司靠信任可以，当公司规模扩充到几百人甚至像 BAT 这样几万几十万员工，如何维持这么大组织体内的信任机制？ 小明不才，但也看到了别人交出的答案：谷歌搞母公司，腾讯把微信搞成独立事业部，阿里把支付宝、蚂蚁金服独立上市……拆分、拆分、再拆分，保证每个有机体内不至于太臃肿。]]></content>
      <categories>
        <category>指点江山</category>
      </categories>
      <tags>
        <tag>管理</tag>
        <tag>罗辑思维</tag>
        <tag>创业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[520，我什么也不说，这是坠吼滴]]></title>
    <url>%2F2016%2F05%2F20%2F520-%E6%88%91%E4%BB%80%E4%B9%88%E4%B9%9F%E4%B8%8D%E8%AF%B4%EF%BC%8C%E8%BF%99%E6%98%AF%E5%9D%A0%E5%90%BC%E6%BB%B4%2F</url>
    <content type="text"><![CDATA[今天 520，有两个大新闻。 湾湾人民搞了第一个大新闻：首位女总统登基大典。 我对此也没有什么好说的，只看到中天新闻的记者跑得最快，在 YouTube 上给全世界人民搞了个典礼直播，真是 excited。 暴力小英敢冒 Min Jin Party 之大不韪，唱国歌居然不回避「三民主义，吾党所宗」，搞得各位记者很是激动了一把。 她的就职演说倒没什么偏差，四平八稳，压根就不敢提 tai 独两字，大家最关心的两岸政策，英文·蔡也只含糊不清的说什么「维持现状，尊重九二会谈这个历史事实」。 这他妈的离「认可九二共识」还差得老远呢！ 萱萱很生气，马上就封杀了国内所有关于蔡就任总统的新闻报道。 细说下这位英文，大学教授出身，表面看上去清秀（对不起，我重口了）稚嫩，似乎是一个可以轻易玩弄的傀儡，其实是个韬光养晦有所作为的权谋大师。​能够入主总统府，yingwen 已然证明了自己身为政客的强悍能力，但这并不意味着她能够应付未来的挑战。 大陆不可能容忍台湾向 tai独前进半步，美国也不可能坐视台海失控，台湾经济的振兴更是遥遥无期……这些，yingwen 能否应对呢？且行且看吧。 好了，说下另外一个大新闻，这就跟 520 主题比较吻合的啦：霍建华抛弃胡歌向林心如表白。 小明在祝愿心如姐姐和建华长长久久的同时，也同情下胡歌、尔康和有朋吧。]]></content>
      <categories>
        <category>指点江山</category>
      </categories>
      <tags>
        <tag>蔡英文</tag>
        <tag>520</tag>
        <tag>表白</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NFS: 让 Mac OS X 和 Linux 手牵手]]></title>
    <url>%2F2016%2F05%2F20%2FNFS-%E8%AE%A9-Mac-OS-X-%E5%92%8C-Linux-%E6%89%8B%E7%89%B5%E6%89%8B%2F</url>
    <content type="text"><![CDATA[使用 nfs 让 Mac OS X 和 Linux 能互相访问共享的网络硬盘。 下面以 OS X EI Capitan (192.168.6.235) 和 Ubuntu 12.04 (192.168.6.21) 为例。 Linux –&gt; Mac服务端：Mac /etc/exports: 1/Users/hxz/test -maproot=root:wheel -network 192.168.6.0 -mask 255.255.255.0 /Users/hxz/test: 要通过 NFS 共享的文件目录。 -maproot=root:wheel: 把 client 端的 root用户映射为 Mac OS 上的 root，client端的 root组映射为 Mac OS 上的 wheel (gid=0) 组。 -network 192.168.0.0: 子网网段。 -mask 255.255.255.0: 网络掩码。 重启 nfsd： 1234hxz@pc0170:~/workspace/hxzqlh.com$ sudo nfsd restarthxz@pc0170:~/workspace/hxzqlh.com$ showmount -eExports list on localhost:/Users/hxz/test 192.168.6.0 客户端：Linux 1sudo mount -t nfs 192.168.6.235:/Users/hxz/test somewhere/on/linux Mac –&gt; Linux服务端：Linux /etc/exports: 1/home/hxz/media_set 192.168.6.0/255.255.255.0(rw,all_squash,insecure,anonuid=1000,anongid=1000) 重启 nfs server： 1234hxz@pc0053:~/media_set$ sudo service nfs-kernel-server restarthxz@pc0053:~/media_set$ showmount -eExport list for pc0053:/home/hxz/media_set 192.168.6.0/255.255.255.0 客户端：Mac 1234sudo mount -t nfs 192.168.6.21:/home/hxz/media_set /Users/hxz/media_set或：sudo mount_nfs -o resvport 192.168.6.21:/home/hxz/media_set /Users/hxz/media_set 可视化连接方式，在 Finder 的 Go 菜单： 卸载 nfs 硬盘：1sudo umount -t nfs nfs_dir]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>nfs</tag>
        <tag>mac</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[妈妈再也不用担心我为了听歌装那么多播放器了]]></title>
    <url>%2F2016%2F05%2F18%2F%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E7%94%A8%E6%8B%85%E5%BF%83%E6%88%91%E4%B8%BA%E4%BA%86%E5%90%AC%E6%AD%8C%E8%A3%85%E9%82%A3%E4%B9%88%E5%A4%9A%E6%92%AD%E6%94%BE%E5%99%A8%E4%BA%86%2F</url>
    <content type="text"><![CDATA[今天来聊一聊关于听歌、找歌的事。 为了听歌，你装了多少个音乐播放器？ 喜欢听歌的朋友想必都知道上哪去找歌，国内主流的音乐平台无外乎 QQ音乐、虾米音乐、网易云音乐和百度音乐，感谢人家给我们提供了免费听音乐的功能。 但，平台是要向音乐创作者们付版权费的，而且，不同平台之间还存在竞争，为了抢到独家发布权，某个音乐人的歌曲通常只限于跟它合作的平台上播放。 另一方面，单个平台上收录的音乐毕竟有限，有些小众的音乐只有个别平台能搜索到。 现状是：为了听一首自己想听的歌，我们不得不而下载 N 个音乐播放器。 这样，对我们听众而言，带来了两个不好的用户体验： 需要打开好几个网站搜索 无法建立一个统一的歌单 Listen 1还好，somebody 给我们搞了个好东西出来。 「Listen 1」，这款工具让你用一个网页就能听到多个网站的在线音乐，现已包括网易云音乐，QQ音乐，虾米音乐，豆瓣音乐。 你可以非常的简单得访问和收听在线音乐，而不用受到单个音乐网站资源不全的限制了，更贴心的是，它还能方便的整理你喜欢的音乐，制作歌单和收藏热门歌单。 这个工具是一个网页应用，支持浏览器：IE 11, Chrome, FireFox, Safari，装上相应的浏览器插件就可以了。 妈妈再也不用担心我找不到我想听的歌了，尽兴的享受音乐吧。 TODO闲着无事，上 github (链接：https://github.com/listen1/listen1) 粗略扒拉下这个应用的源码： 这位同学参考了很多音乐网站 API （github 上都有不少热心的开发者专门研究各大主流网站的 API）的分析代码和文章，因此里面的主要工作是聚合这些 API，采用「Angular＋tornado」架构开发出来。 So easy! 目前这个工具只开发了 PC 版，要是再搞个手机版出来就更完美了，手机上的音乐播放器 APP 也可以少装几个了。 看来我有必要上 github 拉个分支开发「Listen 1」的手机版出来。]]></content>
      <categories>
        <category>产品狗</category>
      </categories>
      <tags>
        <tag>QQ音乐</tag>
        <tag>虾米音乐</tag>
        <tag>网易云音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员为啥喜欢听着音乐写代码]]></title>
    <url>%2F2016%2F05%2F15%2F%E7%A8%8B%E5%BA%8F%E5%91%98%E4%B8%BA%E5%95%A5%E5%96%9C%E6%AC%A2%E5%90%AC%E7%9D%80%E9%9F%B3%E4%B9%90%E5%86%99%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[没错，小明是一枚程序员，入门级。 程序员这个物种，每天的工作其实挺单调的：面对繁复的代码，双眼紧盯屏幕，指尖在键盘上噼里啪啦飞扬…… 我发现身边有不少同事都习惯于一边写代码一边听音乐。 就像有相当比例的程序员喜欢看动漫 一样（这个以后再探讨），我对「听着音乐写代码」这种流行于程序员群体的现象感到好奇。 存在即合理，我今天来浅析此种现象。 我不想被打断为了不被周遭环境的噪音(同事的交谈，移动椅子的声音等)吵到，戴上耳机，听一首音乐，任他东西南北风，我就是整个世界。 甚至，哪怕你不听音乐，只是戴上耳机，也能向别人传递出这样一种信号： 对不起，我很忙，要是没有很重要的事就别来打扰我。 知情的人，一看就秒懂了。就好比阳顶天闭关修练九阳神功，此刻，这家伙需要一个相对清静的环境。 要是在你专心致志地码代码时，身边突然蹦出个人来，哪怕、即使，对方是个美女，咔嚓打断你一下「你看我这个新发型好看吗？」，很可能你刚刚在脑海里飘过的那行思绪就永远、永远、永远找不回来了。 出于礼貌，往往程序员这个时候只能咽下这口苦水（或许在美女看来，那是口水），强忍住把美女掐死的冲动，静静地看她微（zuo）笑（si）。 千万别去骚扰程序员，尤其是 Ta 在写代码的时候。 千万别去骚扰程序员，尤其是 Ta 在写代码的时候。 千万别去骚扰程序员，尤其是 Ta 在写代码的时候。 重要的事情说三遍。 我不想走神毕竟一气呵成码代码的时候不是太多，大多数时候，程序员还不得不应付那些重复性的流程性的工作，这些琐碎的杂事无法让你两眼放光，精神抖擞，比如说：写技术文档、写测试用例、写用户使用说明…… 对于这样的工作，音乐或者广播、有声读物可以给你的大脑一定的节奏来保证参与度，从而避免神游八方。 当处理像码代码这种对创造性要求较高的脑力活时，有的人会单曲循环一首音乐，一遍一遍又一遍，直到他进入了思维流畅的状态。 听什么音乐我并没有没事就戴耳机听歌的癖好。 作为一枚情感专一、一心难以两用的程序员，小明工作时的常态是「两耳不闻窗外事，一心一意码代码」。 只有在工作压力不大的时候，才把听音乐作为一种休息的方式偶尔听听，你让我一整天戴这个耳机，我耳朵会痛。 当然啦，做那些简单的、重复性的编程工作时，听听音乐还是很惬意的。需要设计、开发新的东西时，我还是偏向于安静的环境，即使音乐本身也不能来打扰我。 最后，分享两个适合程序员码代码时听的歌单。 《骨灰级程序员编程必备音乐》（链接：http://dwz.cn/3munyF） 《程序猿之音》（链接：http://dwz.cn/3musz1） 就酱！]]></content>
      <categories>
        <category>心旷神怡</category>
      </categories>
      <tags>
        <tag>程序员</tag>
        <tag>音乐</tag>
        <tag>代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信给我搞的原创这个东西啊,Excited]]></title>
    <url>%2F2016%2F05%2F10%2F%E5%BE%AE%E4%BF%A1%E7%BB%99%E6%88%91%E6%90%9E%E7%9A%84%E5%8E%9F%E5%88%9B%E8%BF%99%E4%B8%AA%E4%B8%9C%E8%A5%BF%E5%95%8A-Excited%2F</url>
    <content type="text"><![CDATA[今天来谈谈我这个公众号。 我的这个经历就是到了 2015 年 7 月底的时候，我在想我的笔力估计是要荒废了，我想我应该去做一个公众号。 于是我就给微信公众平台，给他们写了一个报告。小龙说欢迎你来，不过，这个 Apply for 公众号，你要去做一个报告。 我就做了个「我为朝露谁苦多」的报告，这个报告经过公众号中央委员会好几百个教授一致通过。 当天，我就写了我的第一发《我为什么写作》。 人哪，就都不知道不可预料。一个公众号的命运，当然要靠作者的自我奋斗，当然也要考虑微信官方的历史行程。 我绝对不知道，我作为一个影响力不大、粉丝数不多的公众号运营者，怎么就被选中开通原创功能了呢。 所以，今天当微信后台给我发通知： 公众号中央委员会决定了，邀请你来使用原创保护功能。 我说另请高明吧，我也实在不是谦虚，我一共就断断续续地写了几十篇阅读量和点赞数都十分渺小的文章，很惭愧，就做了这么点微小的贡献。 但是呢，小龙回去和各位教授研究后说： 你提交的原创保护功能申请已通过审核。 于是我就淫了两句诗： 苟利公号生死以，岂因祸福避趋之。 那么所以，我就开通了原创保护功能，你们要是资瓷我呢，可以在文章下方留言了。]]></content>
      <categories>
        <category>WeChat</category>
      </categories>
      <tags>
        <tag>微信</tag>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pillar:皮勒的那些事儿]]></title>
    <url>%2F2016%2F05%2F09%2FPillar-%E7%9A%AE%E5%8B%92%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%2F</url>
    <content type="text"><![CDATA[话说这 salt 里面的术语都起得特立独行，State 之所以叫 State ，我绕了半天才搞懂原来它是指期望达到的某种 状态，关于 State ，前面发了四篇文章，终于算是入门了。 今天，我来开始撸一撸 salt 中的另一个核心概念：Pillar。关于 Pillar 的更详细文档，请参考 这里 Pillar 是存储于 master 上面并发送给相关 minions 的一些树形结构数据： 注意：初学者很容易混淆 Grains 和 Pillar。你只需记住，Grains 是跟 minion 自身相关的静态数据，比如硬件、系统信息；Pillar 是由 master 生成并分发给 minion 的信息。 Pillar 主要可以保存下面几类数据： 高敏感度数据 比如密钥、密码之类。通过 Pillar 传输的数据可以确保只有部分相关的 minion 能收到（你总不希望 minoion A 收到 minion B 的 mysql 登陆密码吧）。 minion 的配置信息 可以在 Pillar 中配置 minion 的可执行模块、states、returners。 变量 Pillar 中可以定义用于给 minion 分配角色、组别等变量，之后，它们就能在 sls 的模版语句中访问了。 其他数据 Pillar 还可以包含其他任意键值对格式的数据。 因此，可以说 Pillar 是 Salt 系统中最重要的组件之一，怪不得老外给它取名叫 Pillar 呢，字面意思是“核心的，支柱”，看来它在 salt 系统里面的威望也很高啊。 皮勒有多重要呢，这么说吧，我们这厢经常唱红歌：“没有共产党就没有新中国”，套用到 salt 中，那就是：“没有 皮勒就没有盐”。 设置 Pillar默认情况下， pillar 已经在 salt 中运行，跟 State 类似，Pillar 也是由一个 top.sl 和一组 sls 文件构成，默认的根目录是 /srv/pillar，你需要手动创建这个目录。 首先新建一个 top 文件： /srv/pillar/top.sls: 123base: '*': - data 这个 top 文件会搜集 data.sls 里面的数据给所有的 minion: /srv/pillar/data.sls: 1info: some data 为了让刚才新建的 pillar 生效，运行如下命令，通知 minions 到 master 上获取对应的 pillar 数据： 1salt '*' saltutil.refresh_pillar 查看最新的 pillar: 1salt '*' pillar.items 更复杂点的 Pillar不像 State 语法那么严谨，pillar 可以设置任意列表或字典型数据: /srv/pillar/users/init.sls: 12345users: thatch: 1000 shouse: 1001 utahdave: 1002 redbeard: 1003 注：pillar 同样遵守和 State 文件一样的约定，users/init.sls 可以用 users 引用。 /srv/pillar/top.sls: 1234base: '*': - data - users 现在，在 state 文件中使用这些 pillar 数据： /srv/salt/users/init.sls: 12345&#123;% for user, uid in pillar.get('users', &#123;&#125;).items() %&#125;&#123;&#123;user&#125;&#125;: user.present: - uid: &#123;&#123;uid&#125;&#125;&#123;% endfor %&#125; Pillar 作为 State 参数所有的 Pillar （包括 Grains）信息在执行 State 之前就已经初始化完毕，Pillar 数据可以在 State 文件中使用来为不同的 minion 定制不同的行为。 一个简单示例：在 Pillar 中为不同的 Linux 发行版设置不同的 Apache 安装包名。 /srv/pillar/pkg/init.sls: 1234567891011pkgs: &#123;% if grains['os_family'] == 'RedHat' %&#125; apache: httpd vim: vim-enhanced &#123;% elif grains['os_family'] == 'Debian' %&#125; apache: apache2 vim: vim &#123;% elif grains['os'] == 'Arch' %&#125; apache: apache vim: vim &#123;% endif %&#125; 把这个新的 pkg 应用到 top 文件： /srv/pillar/top.sls: 12345base: '*': - data - users - pkg minions 根据自身的系统信息找到其对应的 pillar 数据，因此 state 文件可以安全地实现参数化控制。 /srv/salt/apache/init.sls: 123apache: pkg.installed: - name: &#123;&#123; salt['pillar.get']('pkgs:apache', 'httpd') &#125;&#125; 这里，某个 pillar 值在 minion 中未定义的话，可以提供一个默认值，如：上面最后一行的 httpd。 Pillar 使 state 可扩展Pillar 的设计初衷之一就是让 sls 简单可扩展，不必每次都重新编译。 比如，这样一个 state 文件： /srv/salt/edit/vim.sls: 1234567891011vim: pkg.installed: []/etc/vimrc: file.managed: - source: salt://edit/vimrc - mode: 644 - user: root - group: root - require: - pkg: vim 通过 pillar，可以很容易将它改造成一个更加灵活可扩展的 state： /srv/salt/edit/vim.sls: 123456789101112vim: pkg.installed: - name: &#123;&#123; pillar['pkgs']['vim'] &#125;&#125;/etc/vimrc: file.managed: - source: &#123;&#123; pillar['vimrc'] &#125;&#125; - mode: 644 - user: root - group: root - require: - pkg: vim 可以看到，通过 pillar， vimrc 的路径可以根据需要来配置，而不必硬编码到 state 文件： /srv/pillar/edit/vim.sls: 1234567&#123;% if grains['id'].startswith('dev') %&#125;vimrc: salt://edit/dev_vimrc&#123;% elif grains['id'].startswith('qa') %&#125;vimrc: salt://edit/qa_vimrc&#123;% else %&#125;vimrc: salt://edit/vimrc&#123;% endif %&#125; 命令行传递 PILLAR 参数Pillar 数据可以通过命令行执行： 12salt '*' state.apply pillar='&#123;"foo": "bar"&#125;'salt '*' state.apply my_sls_file pillar='&#123;"hello": "world"&#125;' 注：如果某个 key 在 minion 中已经存在，且 pillar 参数中也含有该 key 值，那么以命令行参数值为准。 姿势总结这几天，谈的主题都是 salt，从宏观地介绍到具体 state、pillar 等细节，很惭愧，有些东西翻译得不到位，信、达、雅三重境界只勉勉强强能称得上 信，如有谬误之处，还请读者不吝指正。]]></content>
      <categories>
        <category>Ops</category>
      </categories>
      <tags>
        <tag>salt</tag>
        <tag>pillar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Salt States 基本法]]></title>
    <url>%2F2016%2F05%2F07%2FSalt-States-%E5%9F%BA%E6%9C%AC%E6%B3%95-%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[这周翻译了四篇有关 salt state 的文章，基本上是每天发一篇掉一个粉，到今天已经掉了 5 个粉了，技术文章阅读量低也是意料之中的。 but，I don’t care. 鲁迅爷爷说过： 真的猛男，敢于直面永不破百的阅读量和点赞数，敢于正视不忠取关的粉丝。 今天来继续讲一讲 state 中的 top 文件。 top.sls 的由来大多数系统都是由多组机器构成，同一组的每台机器分担的职责大致相同，比如数据库集群负责数据存储，web服务器专心于负载均衡、请求响应，还有一大堆的机器专门负责执行具体的业务逻辑。 为了有效地管理这些机器，管理员需要为它们分配不同的角色。比如，那些负责处理来自前台请求的机器的角色可能是这样：它们应该全部都安装好 Apache 服务器并且保证服务正常运行。 在 Salt 中，定义了不同组机器 和 它们要配置的角色 的映射关系的文件就是 top.sls。 top，顾名思义，它在所有 state 文件目录的最顶层，这些目录结构构成了一棵 state 树🌲 一个简单示例top.sls 中有三个元素： 运行环境: 运行环境是指包含了一个 top 文件和多个 state 文件的目录结构。默认为 base，可以声明多个运行环境，建议用户只在多个版本的 state 树的情况下才配置多运行环境。 目标 minions：一组机器，它们要去执行 state 文件。 State 文件: 要应用到目标 minion 的 sls 文件，每个 sls 文件描述了一个或多个 state。 三者之间的关系如下： 环境包含目标 目标包含 State 有了这些概念，我们就可以描述这样一个 top 文件：所有 ID 以 web 开头的 minion 都要执行一个叫 apache 的 State。 123base: # Apply SLS files from the directory root for the 'base' environment 'web*': # All minions with a minion_id that begins with 'web' - apache # Apply the state file named 'apache.sls' 使用 top.sls每种运行环境都通过 master 配置文件的 file_roots 属性来指定这种环境的根目录，前面介绍过了，可以为一个或多个，只要根目录列表里能找到 top.sls 即可。 在最常见的单运行环境中，只声明一个 base 环境，并且它对应的 state 树目录也只有一个。 /etc/salt/master： 123file_roots: base: - /srv/salt 接下来，/srv/salt 目录中的 top.sls 中相应地声明了 base 环境，在该环境中所有的 minion 都要应用 core 和 edit 这两个 state。 /srv/salt/top.sls： 1234base: '*': - core - edit 如上述配置，那么 Salt 将会在 /srv/salt 目录中搜索 core.sls 和 edit.sls 多运行环境这部分之前有个例子讲的很清楚了，请参考 《Salt States 基本法之三》(链接：http://t.cn/Rqn0foT) minion 匹配技巧在 top 文件中，可以通过 Grains、pillar、正则表达式等多重组合方式来筛选 minion。 下面是一个稍微复杂点的 top.sls，展示了几种匹配 minion 的技巧： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# All files will be taken from the file path specified in the base# environment in the ``file_roots`` configuration value.base: # All minions get the following three state files applied '*': - ldap-client - networking - salt.minion # All minions which have an ID that begins with the phrase # 'salt-master' will have an SLS file applied that is named # 'master.sls' and is in the 'salt' directory, underneath # the root specified in the ``base`` environment in the # configuration value for ``file_roots``. 'salt-master*': - salt.master # Minions that have an ID matching the following regular # expression will have the state file called 'web.sls' in the # nagios/mon directory applied. Additionally, minions matching # the regular expression will also have the 'server.sls' file # in the apache/ directory applied. # NOTE! # # Take note of the 'match' directive here, which tells Salt # to treat the target string as a regex to be matched! '^(memcache|web).(qa|prod).loc$': - match: pcre - nagios.mon.web - apache.server # Minions that have a grain set indicating that they are running # the Ubuntu operating system will have the state file called # 'ubuntu.sls' in the 'repos' directory applied. # # Again take note of the 'match' directive here which tells # Salt to match against a grain instead of a minion ID. 'os:Ubuntu': - match: grain - repos.ubuntu # Minions that are either RedHat or CentOS should have the 'epel.sls' # state applied, from the 'repos/' directory. 'os:(RedHat|CentOS)': - match: grain_pcre - repos.epel # The three minions with the IDs of 'foo', 'bar' and 'baz' should # have 'database.sls' applied. 'foo,bar,baz': - match: list - database # Any minion for which the pillar key 'somekey' is set and has a value # of that key matching 'abc' will have the 'xyz.sls' state applied. 'somekey:abc': - match: pillar - xyz # All minions which begin with the strings 'nag1' or any minion with # a grain set called 'role' with the value of 'monitoring' will have # the 'server.sls' state file applied from the 'nagios/' directory. 'nag1* or G@role:monitoring': - match: compound - nagios.server top.sls 是如何编译的当使用多运行环境时，没必要为每个环境都写一个 top 文件。最常见且最方便维护的方式是：将 top.sls 存放在这多种环境中的一个即可。 but，某些奇葩的工作流确实需要多个 top 文件，在这种情况下，这些多个 top.sls 将被合并，为 state 编译器生成高级数据，最后，minion 利用这些数据来编译 state。 假设，某配置如下： /etc/salt/master: 12345file_roots: first_env: - /srv/salt/first second_env: - /srv/salt/second /srv/salt/first/top.sls: 123456first_env: '*': - firstsecond_env: '*': - second 聪明的读者可能会疑问： 如果 minion 不属于某个特定的环境（或者同时匹配到多个环境），也没有 saltenv 参数传给 state 方法，state 编译器将如何处理这种冲突？ 如上，在 salt &#39;*&#39; state.apply 命令中，应用的 state 文件，是first.sls 还是 second.sls 呢？ 当冲突发生时，在 master 配置文件里，有几个相应的选项来控制这些行为： env_order 设置 state 环境的编译顺序。比如，你声明了 base、dev、prod 三种环境，你可以设置编译顺序为 [&#39;base&#39;、&#39;dev&#39;、&#39;prod&#39;]，如果有冲突的 key，以 最后 的那个环境值为准。 top_file_merging_strategy merge：这是默认选项，top 文件被合并，可以通过控制 env_order 属性来设置编译顺序。 same：只会编译匹配到的环境的 top 文件。 default_top 如果 top_file_merging_strategy 为 same并且某个环境没有 top 文件，将用 default_top 值作为该环境的 top 文件，默认值为 base。 下集预告 介绍有关 pillar 的那些事儿，吼不吼啊？ 很惭愧，今晚又做了一点微小的贡献，谢谢大家！]]></content>
      <categories>
        <category>Ops</category>
      </categories>
      <tags>
        <tag>salt</tag>
        <tag>states</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Salt States 基本法]]></title>
    <url>%2F2016%2F05%2F06%2FSalt-States-%E5%9F%BA%E6%9C%AC%E6%B3%95-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[续上集，继续研究《Salt States 基本法》，本集前情提要： 介绍如何使用 file_roots 来建立一套可同时用于研发、测试、生产线的运行环境。 sls 根目录Salt 的 sls 文件服务器允许一个运行环境下配多个根目录，如下，使用了一个本地目录和网络共享目录： /etc/salt/master: 1234file_roots: base: - /srv/salt - /mnt/salt-nfs/base Salt 会依次遍历列这些目录，直到找到对应的 sls 文件。如果有不止一个目录含有相同名字的 sls 文件，那么以最先找到的那个为准。比如，/srv/salt/foo.txt 和 /mnt/salt-nfs/base/foo.txt 都存在的话, 那么 salt://foo.txt 将引用 /srv/salt/foo.txt 文件。 配置运行环境搭建多种运行环境，其配置如下： /etc/salt/master: 12345678910file_roots: base: - /srv/salt/prod qa: - /srv/salt/qa - /srv/salt/prod dev: - /srv/salt/dev - /srv/salt/qa - /srv/salt/prod 从上面给出的各种环境下的根目录信息来看，/srv/salt/prod 下面的文件三种环境都可以用，/srv/salt/qa 下面的文件可以用于 qa 和 dev 环境，而 /srv/salt/dev 下面的文件只能用于 dev 环境。 根据如上定义的根目录次序，新编辑的 sls 文件可以先放在目录 /srv/salt/dev，发布到相应的 dev 主机去测试。 dev 测试没问题后，这些 sls 文件可以移到 /srv/salt/qa，发布到相应的 qa 主机去测试。 最后，dev 和 qa 都觉得测试没问题，就可以把它们都移到 /srv/salt/prod 目录，发布给生产环境的主机去上线运行了。 实用案例作为上面这种情况的一个典型例子，考虑这样一个网站，它安装在 /var/www/foobarcom，下面是 top.sls，它放在 /srv/salt/prod 目录，根据上述的 sls 遍历原则，三种环境都可以找到这个 top 文件: /srv/salt/prod/top.sls: 123456789base: 'web*prod*': - webserver.foobarcomqa: 'web*qa*': - webserver.foobarcomdev: 'web*dev*': - webserver.foobarcom 通过 pillar，给不同的主机设置不同的角色（开发机器？测试机器？还是直接跑在线上的机器？）： /srv/pillar/top.sls: 1234567base: 'web*prod*': - webserver.prod 'web*qa*': - webserver.qa 'web*dev*': - webserver.dev /srv/pillar/webserver/prod.sls: 1webserver_role: prod /srv/pillar/webserver/qa.sls: 1webserver_role: qa /srv/pillar/webserver/dev.sls: 1webserver_role: dev 最后，是部署网站的 sls 文件： /srv/salt/prod/webserver/foobarcom.sls: 12345678&#123;% if pillar.get('webserver_role', '') %&#125;/var/www/foobarcom: file.recurse: - source: salt://webserver/src/foobarcom - saltenv: &#123;&#123; pillar['webserver_role'] &#125;&#125; - dir_mode: 755 - file_mode: 644&#123;% endif %&#125; 从上面这个 state 可以看出，网站的源文件最初（dev 环境）放在这里：/srv/salt/dev/webserver/src/foobarcom。 首先，部署到 dev 环境: 1salt --pillar 'webserver_role:dev' state.apply webserver.foobarcom 多运行环境下的 top 文件和 state 遍历规则有点恶心： 如果没有明确指定指定运行环境（比如上面这条命令），minion 会在每个运行环境对应的根目录（一个或多个）中搜索 top.sls 并按照 top_file_merging_strategy （这里默认为：merge）来处理多个 top 文件的冲突情况。执行哪个 state 也是类似规则，会在 merge 后的 top.sls 文件里的每个运行环境都匹配一遍。 关于这部分的详细文档，请参考 这里 当然，我们这个例子中，webserver_role 匹配到了 /srv/salt/prod/top.sls 中的 dev 环境，因此准备执行 webserver.foobarcom 这个 state。 因此，上面这个命令还可以指定运行环境 saltenv＝dev。 1salt --pillar 'webserver_role:dev' state.apply webserver.foobarcom saltenv=dev 当在 dev 环境测试通过后，网站源文件可以从 /srv/salt/dev/webserver/src/foobarcom 移到 /srv/salt/qa/webserver/src/foobarcom，部署到 qa 环境去测试： 1salt --pillar 'webserver_role:qa' state.apply webserver.foobarcom 最后，当在 qa 环境测试通过后，网站源文件就可以从 /srv/salt/qa/webserver/src/foobarcom 移到 /srv/salt/prod/webserver/src/foobarcom，部署到生产线运行： 1salt --pillar 'webserver_role:prod' state.apply webserver.foobarcom 得益于 salt 到根目录体系，即使网站源文件移到了 /srv/salt/prod，它们在 dev 和 qa 环境下同样可以访问。 期望是美好的，but，很诡异的是，这最后部署到 prod 到步骤，出错了： 哎呀，真是买了个表啊～看上图，src 文件夹明明就在 prod 下面啊？！这个问题，我看了半天，头都大了…… 折腾了半天，终于搞明白了：因为 file_roots 里面并没有声明有 prod 这个运行环境啊，亲！ 把 /srv/salt/prod/webserver/foobarcom.sls 中的这行： 1- saltenv: &#123;&#123; pillar['webserver_role'] &#125;&#125; saltenv 改为 base 或 dev 或 qa 即可。 下集预告 介绍有关 pillar 的那些事儿，吼不吼啊？ 很惭愧，今晚又做了一点微小的贡献，谢谢大家！]]></content>
      <categories>
        <category>Ops</category>
      </categories>
      <tags>
        <tag>salt</tag>
        <tag>states</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Salt States 基本法]]></title>
    <url>%2F2016%2F05%2F05%2FSalt-States-%E5%9F%BA%E6%9C%AC%E6%B3%95-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[五一小长假，魏泽西事件，谁也没想到这事闹得这么大，惊动了习大大出来亲自做指示：「搜索结果不能以给钱多少作为排序依据」，当社会民生问题上升到国家机器的高度，这事推动起来就好办点了，这是积极的一面。 再说黑暗的一面，在此事件中，百度的竞价排名、医疗广告备受诟病，有部分知乎大V收黑钱，昧着良心给那些为百度洗地的答案「点赞」，结果被人扒出来吊打一顿，个中过程，一波三折，撕逼打脸此起彼伏…… 详细报道，请观看明晚 19 点 35 分播出的焦点访谈节目《知乎6大V为百度洗地被永久封号》（链接：http://t.cn/Rq8r9zg） 只不过一不小心点了个赞，瞬间几百万粉丝就没了，大V们的人品、口碑及其附带的一系列营销价值一夜坍塌，被永久地钉在知乎的耻辱柱上，受万人唾骂？请问，这事能怪谁？ 人在做天在看，且问苍天绕过谁？ 勿以恶小而为之啊！ 好啦，继续研究《Salt States 基本法》，本集前情提要： 讨论有关 sls 模版以及 include, extend 等高级配置语法。 sls 模版当你编写 sls 文件时，可能会用到编程语句，这可以用模版语言 { % % } 表示。默认的模版渲染器是 Jinja2，当然，你也可以换成其他的，修改 master 配置文件的 render 值即可。 你写好的所有 state 模块都会发送给 Jinja2 去渲染、编译。 好！下面，就让我们来往里面加点料：模版标记语句，示例如下： 1234&#123;% for usr in ['moe','larry','curly'] %&#125;&#123;&#123; usr &#125;&#125;: user.present&#123;% endfor %&#125; 渲染后的 sls 文件将变成这样： 123456moe: user.presentlarry: user.presentcurly: user.present 下面是个更复杂的例子： 1234567891011121314151617# Comments in yaml start with a hash symbol.# Since jinja rendering occurs before yaml parsing, if you want to include jinja# in the comments you may need to escape them using 'jinja' comments to prevent# jinja from trying to render something which is not well-defined jinja.# e.g.# &#123;# iterate over the Three Stooges using a &#123;% for %&#125;..&#123;% endfor %&#125; loop# with the iterator variable &#123;&#123; usr &#125;&#125; becoming the state ID. #&#125;&#123;% for usr in 'moe','larry','curly' %&#125;&#123;&#123; usr &#125;&#125;: group: - present user: - present - gid_from_name: True - require: - group: &#123;&#123; usr &#125;&#125;&#123;% endfor %&#125; 在 sls 模块中使用 Grains通常来说，根据主机操作系统的不同，一个 state 模块需要执行不同的动作。前面我们介绍过了，Apache 服务器在不同操作系统下，它的软件安装包名是不一样的。这时，grains 就派上用场了，比如，下面的例子根据不同的操作系统信息确定 Apache 的安装包名： 1234567apache: pkg.installed: &#123;% if grains['os'] == 'RedHat' %&#125; - name: httpd &#123;% elif grains['os'] == 'Ubuntu' %&#125; - name: apache2 &#123;% endif %&#125; 在 sls 模块中使用环境变量你可以在 state 中使用 salt[&#39;environ.get&#39;](&#39;VARNAME&#39;) 来访问某个环境变量。 新建一个 test.sls 文件： 123file.managed: - name: /tmp/hello - contents: &#123;&#123; salt['environ.get']('MYENVVAR') &#125;&#125; 然后，命令行运行： 1MYENVVAR="world" salt-call state.template test.sls 利用环境变量来检查错误信息: 1234567891011121314&#123;% set myenvvar = salt['environ.get']('MYENVVAR') %&#125;&#123;% if myenvvar %&#125;file.managed: - name: /tmp/hello - contents: &#123;&#123; salt['environ.get']('MYENVVAR') &#125;&#125;&#123;% else %&#125;Fail - no environment passed in: test: A. fail_without_changes&#123;% endif %&#125; 调用其他 sls 模块sls 模版中可以访问 minion 上面的所有 salt 模块，以及模块内的方法： 下面的例子演示了调用了 file 模块的 group_to_gid 方法，参数为 some_group_that_exists。 123moe: user.present: - gid: &#123;&#123; salt['file.group_to_gid']('some_group_that_exists') &#125;&#125; 再看另外一个例子，使用 network 模块的 hw_addr 方法来读取 eth0 的 MAC 地址。 1salt['network.hw_addr']('eth0') 高级 sls 语法includeState 基本法《一》的例子中展示了如何跨文件引用 sls，下面再举一个例子： python/python-libs.sls: 12python-dateutil: pkg.installed python/django.sls: 1234567include: - python.python-libsdjango: pkg.installed: - require: - pkg: python-dateutil extend通过 extend 语句，你可以添加某些内容到已有的 sls 中，比如，当发现 vhost 配置文件被修改后，马上重启 Apache 服务器。 apache/apache.sls: 12apache: pkg.installed apache/mywebsite.sls: 12345678910111213include: - apache.apacheextend: apache: service: - running - watch: - file: /etc/httpd/extra/httpd-vhosts.conf/etc/httpd/extra/httpd-vhosts.conf: file.managed: - source: salt://apache/httpd-vhosts.conf 还是那个注意点：在使用 extend时，会添加 require/watch 的内容，而不是覆盖。 命名空间你可以设置 state 的 name 属性 （如果没有指定 name 属性，它的默认值就是 ID)。 在大多数情况下，重置 name 属性是一个非常实用的小技巧。 其一，避免 ID 声明冲突。 比如，下面的两个 state 不能都用 /etc/motd 作为 ID，但可以通过将 /etc/motd 设为 name 属性来规避这点。 123456789motd_perms: file.managed: - name: /etc/motd - mode: 644motd_quote: file.append: - name: /etc/motd - text: "Of all smells, bread; of all tastes, salt." 其二，方便其他 state 引用。 ID 名称太长的话，其他 state 来引用不方便还极易出错，比如，下面的例子，将这串冗长的 /etc/apache2/sites-available/mywebsite.com 设为 name 属性，ID 名用 mywebsite 姿势就优雅得多了，想引用几次就引用几次，简单明了。 123456789101112131415mywebsite: file.managed: - name: /etc/apache2/sites-available/mywebsite.com - source: salt://mywebsite.coma2ensite mywebsite.com: cmd.wait: - unless: test -L /etc/apache2/sites-enabled/mywebsite.com - watch: - file: mywebsiteapache2: service.running: - watch: - file: mywebsite names 声明另外一个更牛逼的技巧：使用 names 声明一次声明多个 ID，这样就不必在 sls 文件中使用一堆 ungly 的循环语句了。 比如，本集开头的例子可以重写成这样： 123456stooges: user.present: - names: - moe - larry - curly 下集预告本集主要讨论了有关 include, extend 以及 sls 模版等高级配置语法，下集将介绍如何使用 file_roots 来建立一套可同时用于研发、测试、生产线的运行环境。 很惭愧，今晚又做了一点微小的贡献，谢谢大家！]]></content>
      <categories>
        <category>Ops</category>
      </categories>
      <tags>
        <tag>salt</tag>
        <tag>states</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Salt States 基本法]]></title>
    <url>%2F2016%2F05%2F03%2FSalt-States-%E5%9F%BA%E6%9C%AC%E6%B3%95-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[关于 Salt States ，《Salt Stack 一日游》（链接：http://t.cn/RqYQK0Q）从整体上介绍了 salt 系统以及各个组件，接着《如何使用盐态》(链接：http://t.cn/Rq8vJVF)把 state 相关的知识过了一遍。但，这些多半是理论居多，实践得少，就像程序员学习一门新的编程语言一样，你讲再多都不如一个 Hello World 来的亲切。 纸上得来终觉浅，得知此事须躬行。 本文的目的就是手把手教你“怎样快速地运用 Salt States 来配置系统”。当然啦，想要挖掘更多 Salt States 的内幕信息，请移步官方文档，那里有你想知道的所有奇技淫巧。 这个示例将分为四集，我打算从今天开始每晚放出一集熟肉版。 本集前情提要： 使用 Salt 配置一个 minion，使之运行 Apache 服务器，并确保该服务正常运行。 首先，请检查下你是否正确安装并配置好了 salt－master 和 salt-minion 的运行环境。要是连这个你都还不会，额～你也没必要往下继续看了。 建立 Salt State 树🌲States 纯粹是存放在 master 上的一些文本文件，minions 根据自身需要到 master 的文件服务器上拉取，这些 state 文件就构成了 State 树🌲 因此，为了让 salt 能使用 state 配置系统，必须先设置好 Salt 文件服务器。编辑 master 的配置文件(/etc/salt/master)中的 file_roots 字段，取消下面几行的注释： 123file_roots: base: - /srv/salt 重启 salt－maser 来使配置生效： 12pkill salt-mastersalt-master -d 准备 top 文件在 master 中刚刚设置好的 state 文件目录(默认为：/srv/salt)中，新建一个 top.sls 文件并写入如下内容： 123base: '*': - webserver top 文件可以区分多个运行环境（这个以后会再详细论述），默认的运行环境是 base。在 base 环境下，定义了一系列的 minion，对于上面这个例子来说，它适用于所有(*) minion 主机。 新建 SLS 文件在 top 文件所在目录中，新建一个 webserver.sls 文件，文件内容为： 123apache: # ID declaration pkg: # state declaration - installed # function declaration 第 1 行，是 ID 声明，可以为任何标识符，本例中它指代将要安装的软件名（apache）。 注意：Apache 服务器在不同的操作系统中，其软件安装包名可能不一样，比如，在 Fedora 系统中叫 httpd，但是在 Debian 或 Ubuntu 中，它叫 apache2。 第 2 行，是 State 声明，定义使用的是哪个 Salt States 模块，本例中，我们使用 pkg state 模块来安装某个指定的软件包。 第 3 行，是 方法声明，定义使用 pkg state 模块中的哪个方法。 安装软件包接下来，让我们来运行这个 state。在 maser 上打开终端，运行： 1salt '*' state.apply master 通知所有的目标 minions 来执行 state.apply 方法。当 state.apply方法不带任何 sls 文件作为参数时，minion 将下载 master 的 top 文件并尝试去匹配里面的表达式（top.sls 的第 2 行），如果匹配上，它将下载对应的 sls 文件（webserver.sls），编译（还记得yaml_jinja 吗？），运行。 一旦执行完毕，minion 会将它所执行的具体动作及结果汇报给 master。 SLS命名空间你可能注意到，本例中红 webserver 指代 webserver.sls，在 top.sls中 sls 文件的引用规则如下： .sls 后缀被舍弃（如：webserver.sls 变成 webserver） 允许子目录存在以便更好地管理 sls 文件。 每个子目录可以用.（沿用 python import 某个模块的习惯）或者/来表示（webserver/dev.sls 可以用 webserver.dev 表示） 由于/表示成.，因此 sls 文件名中除了后缀.sls，其他部分不能包含有.。比如：webserver_1.0.sls 将无法匹配，webserver_1.0 将匹配webserver_1/0.sls。 子目录的 init.sls 可以直接用目录名引用。因此，webserver/init.sls 可以用 webserver 指代。 如果 webserver.sls 和 webserver/init.sls 都存在，将忽略 webserver/init.sls 并用 webserver 指代 webserver.sls。 排查问题如果事情不向我们想象得那么顺利，下面这些小提示能帮助我们排查问题出在哪里。 打开日志开关输出更多的日志信息: 1salt-minion -l debug 前台运行 minion直接把 minion 放到前台运行可以直接看到任何输出信息： 1salt-minion 延长超时时间比如，将 salt 运行的超时设为 60 秒： 1salt -t 60 最好的方式是，将这几套合拳结合起来一起用： 12salt-minion -l debug # On the minionsalt '*' state.apply -t 60 # On the master 调用多个 States你可以在一个 ID 声明下面指定多个 State 声明。举个栗子🌰：修改前面的 webserv.sls，如果 Apache 没有运行，则启动它。 12345apache: pkg.installed: [] service.running: - require: - pkg: apache 你可以试着先停止 Apache 服务器，再运行一遍 state.apply，并观察输出结果。 依赖其他 States真是一个赛艇蛤，现在我们已经安装了一个 Apache 服务器，让我们来更多点膜法：给我们的网站添加一个个性化的 HTML 文件。 很明显，只有网页文件却没有相应的 web 服务器是无法让网站工作起来的，因此在部署网页文件前必须检查 Apache 服务器是否已安装并运行。 在 webserver/init.sls 文件底部加入如下内容： 1234567891011121 apache:2 pkg.installed: []3 service.running:4 - require:5 - pkg: apache67 /var/www/index.html: # ID declaration8 file: # state declaration9 - managed # function10 - source: salt://webserver/index.html # function arg11 - require: # requisite declaration12 - pkg: apache # requisite reference 第 7 行是 ID 声明，本例中它是将要安装的 HTMl 文件路径。 注：Apache 网站的默认根目录在不同系统下面可能不一样，在 Debian 系统下它是 /var/www。 第 8 行是 State 模块声明，本例中使用了 State 的 file 模块。 第 9 行是 State 模块的方法声明，managed 方法会从 master 下载文件并将其存放在指定的位置。 第 10 行是方法的参数声明，这里传递了 source 参数给 managed。 第 11 行是 Requisite 必要语句。 第 12 行是 Requisite 引用的某个 state 及其 ID，本例中，它引用了前面的 ID 声明(apache)，它告诉 salt 只有 Apache 已安装才能部署网站文件。 下一步，新建如下内容的 index.html 文件并保存于 webserver 目录(/srv/salt/webserer)中. 1234567&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt;&lt;title&gt;Salt rocks&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;This file brought to you by Salt&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 最后，终于到了最后，再执行一遍 state.apply 命令，minion 会从 master 的文件服务器上下载该 index.html 文件并把它存放在 Apache 网站的根目录中。 1salt '*' state.apply 验证下这个 index.html 是否真的已经在 minion 的网站中。 下集预告本集主要给大家演示了如何快速地让 salt state 工作起来，下集将讨论有关 include, extend 以及 sls 模版等高级配置语法。 很惭愧，今晚只做了一点微小的贡献，谢谢大家！]]></content>
      <categories>
        <category>Ops</category>
      </categories>
      <tags>
        <tag>salt</tag>
        <tag>states</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于「魏则西事件」的解读的解读]]></title>
    <url>%2F2016%2F05%2F02%2F%E5%85%B3%E4%BA%8E%E9%AD%8F%E6%B3%BD%E8%A5%BF%E4%BA%8B%E4%BB%B6%E7%9A%84%E8%A7%A3%E8%AF%BB%E7%9A%84%E8%A7%A3%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[五一小长假，我的朋友圈被「魏则西事件」刷屏了：洗地文、公关文、声讨文…… 各路自媒体写手从不同角度、以不同体位、站在不同立场对此事件进行了或深或浅的解读，小明在此提炼总结下几篇我觉得不错的文章，算是对这些解读的解读吧。 冯大辉作为一枚潜伏在地下党的准知识分子，经常鞭挞时弊，他虽外表赢弱但内心彪悍更要命的是骂起人来毫不嘴软，这次，他继续朝他内心无比憎恨的百度开炮，他以公众号「小道消息」为正面战场，一篇《青年魏则西之死》（链接：http://t.cn/RqTD5hX）迅速点燃朋友圈，阅读量分分钟破 10万+。 接着，他以公众号「坏时代」为敌后战场，一篇《鲁迅如果在写自媒体》（链接：http://t.cn/RqTef4D）以「我去年买了个包」为结束语毫不留情地唾骂了几桩为百度洗地的经典说辞。 「歪理邪说」三个月前以一篇《我是如何坚持10多年站在反百度第一线的》（链接：http://t.cn/RqTDpRQ）揭露百度把血友吧贱卖给某来路不明的骗子医院，这次也没有放过百度，《狼性多了，人性就少了》（链接：http://t.cn/RqTkMo3）这篇情绪激烈的声讨文直陈「这家公司罔顾道德良知追逐利润充满了狼性，以至于没剩下几分人性」，并号召读者一起来骂百度： 我们未必能骂死这家公司，但至少我们能骂到媒体不敢为这家公司造谣，记者不敢被这家公司请去迪拜。如果有一天能做到这样，这件事就已经走在了成功的道路上。不要因为看起来没什么效果而不说话，不要因为怕得罪人而不敢说话，发出自己的声音吧。 这就像一块大石头横在路上挡路，你踢了它一脚，它纹丝不动，你又踢了一脚，还没动，但你并不在乎，继续踢，累了休息一下继续踢。后来越来越多的人加入这个行列一起踢，他们并不在乎旁边的人说着风凉话，也不在乎有人笑他们愤青脑残别有用心，只管一脚一脚踢石头。终于有一天，这块巨石松动了，终于有一天，这块巨石轰然滚到了山下。 公众号「余晟以为」推送的这篇《看得见的与看不见的》（链接：http://t.cn/RqHZq5m）解读的角度很特殊： 眼前看得见的，为某些人津津乐道的「实力」到底是什么，它们来自何方，又用在了何处。在它们背后看不见的地方，我们又为此付出了多少代价呢？ 《令人可憎的信息不对称》（链接：http://t.cn/RqHZH7m）思考了魏则西事件中的问题的本质：信息不对称。 作恶的百度最有可能伤害到的人就是你的父母、亲人。我们这辈尚且还受过相对良好的教育，可以远离百度，但是对于我们的父母来说，远离百度不是一件容易的事。 魏武挥这篇《关于百度，这是一篇很意识流写法的文章》（链接：http://t.cn/RqHwpQF）是这两天我见过的关于此事解读得最有深度、信息量最大的一篇文章，不愧为交大教授。里面有几个观点值得特别拎出来： 如果谷歌可以和百度充分竞争，百度不至于那么糟糕。但是，谷歌即便和百度充分竞争，一样干不过百度。 未来的公关重要到公关部已然不重要了：当企业里很多人（尤其是关键的、核心的人员）自身有公关意识时，公关部能起到的作用有限。 改革开放后，中国在资本主义道路上飞快狂奔：资本主义历经的资源、管理、技术、金融这四个阶段，中国一下子撞上了管理资本主义、技术资本主义和金融资本主义三个。 基于人际关系、社交链的网络工具普及的大环境下，删帖已经于事无补。 百度在过去的诉讼中，让管理部门支持了它的诉求：百度推广不是广告，因而规避了《广告法》的监管。 《所有的企业道德问题，都是法律问题》（链接：http://t.cn/RqHAFEH），从法律与道德的角度看问题，网络舆论会让企业迫于压力而做出让步，但是并不能解决企业的问题。 百度固然是首恶，法律的不健全，则是酿成魏式悲剧的社会土壤。 我们要谋求的是大众的权利，而不是发泄自己的情绪。 法律并不能解决所有的问题，我们永远在和时间赛跑。 《深度！起底「魏则西事件」背后的莆田系》（链接：http://t.cn/RqHUXKE）挖掘百度医疗广告的最大投放商、中国医疗史上最独特的群体：福建莆田系。该文也是迄今为止有关这一群体最全面、最深入的报道。类似的报道还可以参见另外令人毛骨悚然的一篇《为什么中国的军队、武警医院绝不能去！（附部分医院名单）》（链接：http://t.cn/RqH4J7g），还好，知乎上有个帖子整理了莆田系开的医院，能躲则躲吧：《哪些民营医院（包括被承包的公立医院）属于「莆田系」？》（链接：http://t.cn/R4CFHeI） 凤凰网发布的这篇《独家丨魏则西之死，舆论是如何裂变的》（链接：http://t.cn/RqHG7KU），从传播学的角度切入： 大风往往起于青萍之末。 风暴不可预测，只能事后抢救。 在坐实通过百度搜索获知武警二院的事实之后，谁该为魏则西之死负责，以及这场风波的最终指向，并没有变得更加明晰，人们还在为竞价排名是否有罪吵个不停；而有关百度的身份、定位和起家历史，则成为一个可以讨论，但却无从具体下手的中国难题。 站在科学的角度，魏则西这件事情的伤感之处在于： 滑膜肉瘤晚期基本上是必死的，正规医院都表示无能为力，但求胜心切的这一家人不愿承认这种令人绝望的现实，于是本能地抓住一切救命稻草，正是这种迫切心态成为欺诈者瞄准的弱点，贩卖虚假的希望，把这个家庭当成肉猪来宰。可是，谁又做得到从容认命、坦然离世呢。 「刘备我祖」将此事件列入了《史记·魏则西传》（链接：http://t.cn/RqTDGPi）。]]></content>
      <categories>
        <category>指点江山</category>
      </categories>
      <tags>
        <tag>百度</tag>
        <tag>魏则西</tag>
        <tag>医疗</tag>
        <tag>广告</tag>
        <tag>滑膜肉瘤</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用盐态?]]></title>
    <url>%2F2016%2F04%2F30%2F%E6%88%91%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%9B%90%E6%80%81%2F</url>
    <content type="text"><![CDATA[关于，SaltStack 这个牛逼的配置管理神器，上周我写了篇入门级的 《SaltStack 一日游》。 今天，深入点研究 SaltStack 中的精华部分：“Salt States”。 「Salt States」 翻译成什么好呢？我想了半天，乳头都快想破了。老外整的这些玩意翻译成中文就不伦不类了，索性就按照字面意思 one by one 地译成「盐态」好了，蛤蛤～ 注：“乳”字，在汉语中除了指“分泌奶水的器官、乳汁”等含义，还有“初生的、幼小的、小”的意思，除了“乳头”，类似的例子还有： 我的乳名（小名）叫小明。 我家门前有条乳沟（小沟）。 今天，我就来讲讲「盐态」到底是怎么回事。以下译自: HOW DO I USE SALT STATES? KISS简洁，简洁，简洁 众多强大而有力的设计都建立在简单的原则之上。Salt State 系统也努力向 K.I.S.S(Keep It Stupidly Simple） 看齐。 SLS（代表 SaLt State文件）是 Salt State 系统的核心。SLS描述了系统的目标状态，由格式简单的数据构成，经常被称作配置管理。 只是数据而已深入学习之前，明白 SLS文件只是结构化的数据而已 是很有用的。看懂和编写SLS文件不需要理解这一点，但会让你体会到SLS系统的强大。 SLS 文件本质上只是一些 dictionaries，lists，strings和numbers。这种设计让SLS文件非常灵活，可以满足开发者的各种需求，而且可读性很高。写得越多，就越清楚到底写得是什么。最终的结果是一个简单易懂的系统，它可以随着开发者或管理者的需求而变化。 top 文件下面的 sls 示例文件可以通过一个叫 top.sls 的文件来分派给主机执行。这个文件的详细信息可参考 here 默认的数据:YAMLSalt 默认使用YAML 这种最简单的序列化数据格式来表达SLS数据。 典型的SLS文件如下： apache/init.sls: 12345apache: pkg.installed:[] service.running - require: - pkg: apache 这些数据确保名为apache的软件包处于已安装状态，服务进程apache处于运行状态。 这些数据简洁，易于理解。下面简单解释一下： 第 1 行是这段数据的ID，被称作ID声明。这个ID是将要执行的这些命令的名字。 第 2、3 行包含了要执行的State 模块方法，它的格式为&lt;模块名&gt;.&lt;方法名&gt;。pkg.installed 使用系统本地的软件包管理器管理将要安装的软件；service.running确保指定的服务必须运行。 最后，是关键字require，它是必要语句 Requisite，确保了apache服务只有在成功安装软件包后才会启动。 添加配置文件和用户部署像apache这样的web服务器时，还需要添加其他的内容。需要管理apache的配置文件，需要添加运行apache服务的用户和组。 12345678910111213141516171819202122232425apache: pkg.installed: [] service.running: - watch: - pkg: apache - file: /etc/httpd/conf/httpd.conf - user: apache user.present: - uid: 87 - gid: 87 - home: /var/www/html - shell: /bin/nologin - require: - group: apache group.present: - gid: 87 - require: - pkg: apache/etc/httpd/conf/httpd.conf: file.managed: - source: salt://apache/httpd.conf - user: root - group: root - mode: 644 这个SLS大大扩展了上面的例子，增加了配置、用户、组，还有一个新的必要语句：watch。 添加 state 非常简单：user和group这两个state添加在apache这个ID下，所以增加的user和group名字都是apache。require语句确保了只有在apache这个group存在时才建立user，只有在apache这个package成功安装后才会建立group。 接下来，service中的require语句换成了watch，从需要 1 个软件包改为监视 3 个state（分别是pkg、file和user）。watch语句和require很相似，都能保证被监视或需要的state在自己之前执行，但是watch还有其他作用。在被监视的state发生变化时，定义watch语句的state会执行自己的watcher函数。也就是说，更新软件包、修改配置文件、修改apache用户的uid都会触发service state的watcher函数。在这个例子中，service state的watcher会重启apache服务。 多个SLS文件要想可扩展性地部署 Salt State 系统，将会用到不止一个 SLS 文件。上面的例子中只使用 1 个SLS文件，2 个或多个SLS文件可以结合形成State Tree。上面的例子还使用了一个奇怪的文件来源 salt://apache/httpd.conf，这个文件也必须要找的到。 SLS文件以一定的目录结构分布在master上；SLS和要下发到minion上的文件都只是普通文件。 上面例子中的文件在 Salt根目录(/etc/salt/)下： 12apache/init.slsapache/httpd.conf httpd.conf 只是apache目录下的一个普通文件，可以直接引用。 使用多个SLS文件可以更加灵活方便，以SSH为例： ssh/init.sls: 1234567891011openssh-client: pkg.installed/etc/ssh/ssh_config: file.managed: - user: root - group: root - mode: 644 - source: salt://ssh/ssh_config - require: - pkg: openssh-client ssh/server.sls: 123456789101112131415161718192021222324252627282930313233343536373839404142434445openssh-client: pkg.installed/etc/ssh/ssh_config: file.managed: - user: root - group: root - mode: 644 - source: salt://ssh/ssh_config - require: - pkg: openssh-clientssh/server.sls:include: - sshopenssh-server: pkg.installedsshd: service.running: - require: - pkg: openssh-client - pkg: openssh-server - file: /etc/ssh/banner - file: /etc/ssh/sshd_config/etc/ssh/sshd_config: file.managed: - user: root - group: root - mode: 644 - source: salt://ssh/sshd_config - require: - pkg: openssh-server/etc/ssh/banner: file: - managed - user: root - group: root - mode: 644 - source: salt://ssh/banner - require: - pkg: openssh-server 注：在ssh/server.sls中，用了两种不同的方式来表示用Salt管理一个文件。在ID为/etc/ssh/sshd_config段中，直接使用file.managed作为state声明，而在ID为/etc/ssh/banner段中，使用file作为state声明，附加一个managed属性。两种表示方法的含义与结果完全一样，只是写法不同。 现在 State Tree 如下: 1234567apache/init.slsapache/httpd.confssh/init.slsssh/server.slsssh/bannerssh/ssh_configssh/sshd_config ssh/server.sls 中使用了include语句。include将别的SLS添加到当前文件中，所以可以require或watch或 extend（憋着急，下面马上会讲到）被引用的SLS中定义的内容。 include语句使得state可以跨文件引用，使用include相当于把被引用的内容文件添加到自身。 注：你可能注意到有些 SLS 文件叫 init.sls，有些又不是，关于它的约定规则可以参考 States Tutorial Extend:扩展被引用的SLS数据有的时候，SLS 文件需要扩展，也许是 apache 服务需要监听另外一个文件，或者在某种特殊条件下，某个文件需要添加进来。 在下面的例子中，第一个将添加一个自定义的 banner 文件到 ssh，第二个多添加一个watcher到 apache 以便引入mod_python。 ssh/custom-server.sls: 1234567include: - ssh.serverextend: /etc/ssh/banner: file: - source: salt://ssh/custom-banner python/mod_python.sls: 1234567891011include: - apacheextend: apache: service: - watch: - pkg: mod_pythonmod_python: pkg.installed custom-server.sls 文件使用 extend 语法来覆盖banner 的下载路径文件，相当于替换了banner的配置文件。 在mod_python.sls 文件中, 添加了 mod_python，但是更关键的是 apache 服务扩展成为它还要额外监听这个 mod_python 包。 Extend 使得 SLS更加灵活，在处理SLS时，会将其中的内容解析成Python中的dict（当然这个dict中会嵌套dict和list）。 扩展 apache 的 watch，相当于往list里面 添加 一个元素。 修改 banner 文件的下载路径相当于 修改 dict中的某个key对应的值。 注：在使用 extend时，会添加 require/watch 的内容，而不是覆盖。 Render System:理解渲染系统由于SLS仅仅是数据，所以它不是一定得用YAML来表达。Salt默认使用YAML，只是因为易学易用。只要有对应的渲染器，SLS文件可以用任何方式表达。 注：Salt关心的是最终解析出来的数据结构，只要你的渲染器能够按要求返回这个数据结构，它不关心你是如何编写的。 Salt默认使用yaml_jinja渲染器，yaml_jinja渲染器先用jinja2模板引擎处理SLS源文件，然后再调用YAML解析器。这种设计的好处是: 可以在SLS文件中使用所有的编程结构。 jinja2能怎么用，这里就能怎么用。条件，循环，Python代码……神马都可以 其他可用的渲染器还包括：yaml_mako，使用 Mako模板引擎；yaml_wempy，使用Wempy模板引擎；py，直接使用Python写SLS文件；pydsl，建立在Python语法基础上的描述语言。 yaml_jinja: 默认的渲染器关于jinja模板引擎的使用请参考其 官方文档 Salt在和渲染器工作时，已经往里面传进去了一些十分有用的数据。在基于模板引擎的渲染器里，可以从3个组件中获取需要的数据：salt，grains和pilla。在模板文件中，可以用salt对象执行任意的Salt function，使用grains访问Grains数据。示例如下： apache/init.sls: 12345678910111213141516171819202122232425262728293031apache: pkg.installed: &#123;% if grains['os'] == 'RedHat'%&#125; - name: httpd &#123;% endif %&#125; service.running: &#123;% if grains['os'] == 'RedHat'%&#125; - name: httpd &#123;% endif %&#125; - watch: - pkg: apache - file: /etc/httpd/conf/httpd.conf - user: apache user.present: - uid: 87 - gid: 87 - home: /var/www/html - shell: /bin/nologin - require: - group: apache group.present: - gid: 87 - require: - pkg: apache/etc/httpd/conf/httpd.conf: file.managed: - source: salt://apache/httpd.conf - user: root - group: root - mode: 644 这个例子很容易理解，用到了jinja中的条件结构，如果grains中的os表明minion的操作系统是Red Hat，那么Apache的软件包名和服务名应当是httpd。 再来一个更niubility的例子，用到了jinja的循环结构，在设置 MooseFs分布式chunkserver的模块中： moosefs/chunk.sls: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849include: - moosefs&#123;% for mnt in salt['cmd.run']('ls /dev/data/moose*').split() %&#125;/mnt/moose&#123;&#123; mnt[-1] &#125;&#125;: mount.mounted: - device: &#123;&#123; mnt &#125;&#125; - fstype: xfs - mkmnt: True file.directory: - user: mfs - group: mfs - require: - user: mfs - group: mfs&#123;% endfor %&#125;/etc/mfshdd.cfg: file.managed: - source: salt://moosefs/mfshdd.cfg - user: root - group: root - mode: 644 - template: jinja - require: - pkg: mfs-chunkserver/etc/mfschunkserver.cfg: file.managed: - source: salt://moosefs/mfschunkserver.cfg - user: root - group: root - mode: 644 - template: jinja - require: - pkg: mfs-chunkservermfs-chunkserver: pkg.installed: []mfschunkserver: service.running: - require:&#123;% for mnt in salt['cmd.run']('ls /dev/data/moose*') %&#125; - mount: /mnt/moose&#123;&#123; mnt[-1] &#125;&#125; - file: /mnt/moose&#123;&#123; mnt[-1] &#125;&#125;&#123;% endfor %&#125; - file: /etc/mfschunkserver.cfg - file: /etc/mfshdd.cfg - file: /var/lib/mfs 这个例子展示了jinja的强大，多个for循环用来动态地检测并挂载磁盘，多次使用salt对象（这里使用了cmd.run这个执行模块）执行shell命令来收集数据。 简单介绍Python和PyDSL渲染器在任务逻辑非常复杂时，默认的yaml_jinja渲染器不一定满足要求，这时可以使用Python渲染器。 Normally a YAML renderer should be used for the majority of SLS files, but an SLS file set to use another renderer can be easily added to the tree. 正常情况下，YAML的渲染器应该可以适用于绝大部分 SLS 文件，但是使用其他的渲染器的 SLS 文件同样可以轻易地适配到 sls tree 中。 下面是一个非常简单的基本Python SLS文件： python/django.sls: 12345678#!py def run(): ''' Install the django package ''' return &#123;'include': ['python'], 'django': &#123;'pkg': ['installed']&#125;&#125; 这个例子也很好理解，第 1 行告诉Salt不使用默认的渲染器，而是用py。接着定义了函数run，这个函数的返回值必须符合Salt的要求，即HighState数据结构。 如果换用pydsl渲染器，上面的例子会更简洁： python/django.sls: 1234#!pydslinclude('python', delayed=True)state('django').pkg.installed() 如果用YAML，会是下面这个样子： 12345include: - pythondjango: pkg.installed 这也可以看出，正常情况下使用YAML是非常合适的，但如果有需要时，使用纯粹的Python SLS可以非常犀利地装逼哦。 运行和调试 Salt States写好的SLS如何才能应用到minion呢？ 在SaltStack中，远程执行是一切的基础。执行命令salt &#39;*&#39; state.apply 会让所有的minion到master上来取走自己的SLS文件，然后在本地调用对应的state模块（user，pkg，service等，内置的 state 模块列表在 这里）来达到SLS描述的状态。 如果这条命令只返回minion的主机名加一个&#39;:&#39;，多半是哪一个SLS文件有错。如果minion是以服务进程启动，执行命令： 1salt-call state.aply -l debug 可以看到错误信息，便于调试。minion还可以直接在前台以debug模式运行： 1salt-minion -l debug What’s next？ 这篇文章只是对 Salt States 的初步介绍，下一步请继续阅读 Pillar 部分，官方文档 在此。]]></content>
      <categories>
        <category>Ops</category>
      </categories>
      <tags>
        <tag>salt</tag>
        <tag>state</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[此图片来自微信公众平台,未经允许不可引用]]></title>
    <url>%2F2016%2F04%2F26%2F%E6%AD%A4%E5%9B%BE%E7%89%87%E6%9D%A5%E8%87%AA%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%B9%B3%E5%8F%B0-%E6%9C%AA%E7%BB%8F%E5%85%81%E8%AE%B8%E4%B8%8D%E5%8F%AF%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[一直以来，我都是用 Markdown 语法写作，写完后先发表到微信公众号里，然后同步到我的个人博客 www.hxzqlh.com（这可作为微信公众号的一个备份，防止公众号被封后文章无可访问的尴尬）。 博客用 hexo 部署，每次需要发表文章时，先用 hexo g 命令渲染成 html 再用 hexo d 命令一键部署，两个命令搞定，真的不要太 easy～ 但，便捷之余还是有一点小疙瘩，困扰我许久：Markdown 文章里插入图片的用户体验。 繁琐＋闹心这个问题，且让我细说如下： Mardown 中显示图片的语法为： 1![some_info](pic_address) 其中，pic_address 是必须的，它支持本地路径和网络 url，比如： 12345![](test.jpg) //相对路径![](/Users/hxz/Desktop/screenshot.png) //绝对路径![](some_picture_url) //网络地址 假设你要往文章里插入一张图片，这分为两种不同情况： 本地图片你需要先自己准备好素材，然后用相对或绝对路径引用它。但，这图片目前只能你的电脑里显示，为了保证你发布文章后，别人也能看到这张图片，你还需要手动地 one by one 地把图片上传到微信公众号后台，然后拷贝该图片地址，再粘贴到 ![]() 后面的那个括号里。 网络图片大多数情况下都能正常显示，但是，微信公众平台的图片链接有防盗链功能，只有在公众平台才可显示，如果是外网去加载公众号图片，偶尔能正常加载，但大多数时候只显示那个恶心的*灰色水印:“此图片来自微信公众平台未经允许不可引用”。 比如，在公众平台浏览我之前写的《小李子拿影帝和长者有什么关系？》 链接：http://t.cn/Rq7Cuzp ，它是这样的： 但，在我的 个人博客 上面（链接：http://t.cn/RqWP7Jn），图片显示却是这样： 问题来了： 本地图片要 one by one 地上传，繁琐 网络图片又时不时遭遇防盗链水印，闹心 这两个问题恶心了我有段时间了。 造轮子我希望实现： 写作过程中，图片可以随意引用，不管是来源于本地还是网络，文章发布后，保证每张图片都能在微信公众号和博客里正常显示。 网上找了找，都没有能满足我需求的解决方案，还是决定自己造个轮子吧。 我不想自己维护博客中的图片资源，专业的活交给专业的机构去办，维护图片资源这等琐事，就让七牛云存储来干吧，我只需专注于博客内容本身。 为什么是 七牛云存储？因为人家免费稳定还速度快啊，用它做图床管理博客中的图片资源还是比较靠谱的。 在七牛云存储上创建个内容空间，注册个 API-KEY，利用七牛开放的 API 接口，很容易就实现出来了。 这个轮子其实造起来很容易，简单的几十行 Python 代码搞定，第一个简陋版本，我已经开源到 GitHub 上了： https://github.com/hxzqlh/qiniu-markdown-pics.git 目前只实现了主要功能，有些细节还没有考虑周全，不过勉勉强强能用了，测试了下，效果还不错。 123456789Allen@MacBook-Pro:~ $ ./qn.py /Users/Allen/Desktop/test.mdorigin markdown file backup in: /Users/Allen/Desktop/test.md.bakprocess: /Users/Allen/Downloads/test.jpgprocess: http://mmbiz.qpic.cn/mmbiz/yjWTowicdvibD5H6jmklGnwZicztwfR8vbb2rF0dic5tAmv58c8O5iaLhKesSfGpKVTIicGA5iaiaFKAS8n4cNWUicB4aUw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5Complete! total :2 success :2 failure :0 ignore :0 简单来说，它只专心干一件事： 自动检测 Markdown 文件中所有的图片链接，将原始图片上传到七牛云存储并修改图片源。 对于那些用 hexo 来部署个人博客，希望便捷地往博客中插入图片且纠结于图片防盗链的人来说，这个工具还是挺实用的。 这样，发布文章到微信公众号和博客时，图片都改从七牛云存储读取，博客里面引用的是七牛的公开链接，没有加其他防盗链处理，任何网站都可直接引用，这样图片都能正常显示了。 至于公众平台，它从七牛云存储加载图片后依然会加上防盗水印并存放于公众平台自身的图片服务器 http://mmbiz.qpic.cn/上，最后读者浏览文章时，也是从该服务器读取图片，这就是为什么微信公众平台文章里的图片会有防盗链的原因。 比如，前几天发表的那篇《你女朋友撤回了一条消息还亲了你一口》中最后一张图片的地址为： 1http://mmbiz.qpic.cn/mmbiz/yjWTowicdvibD5H6jmklGnwZicztwfR8vbboP6538TL637q1eCwegjxrjtfzUic0Yeb81xib4k4SBbLickdGH7P2UQ7w/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1 但，那又如何？我已绕过了你的马其诺防线，曲线救国，你再怎么牛逼，对我而言，也是浮云了。 这下好了，写完文章后，一行命令搞定图片等那些事儿： 1./qn.py markdown_file]]></content>
      <categories>
        <category>WeChat</category>
      </categories>
      <tags>
        <tag>微信</tag>
        <tag>七牛</tag>
        <tag>防盗链</tag>
        <tag>hexo</tag>
        <tag>图片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SaltStack 一日游]]></title>
    <url>%2F2016%2F04%2F22%2FSaltStack-%E4%B8%80%E6%97%A5%E6%B8%B8%2F</url>
    <content type="text"><![CDATA[随着上线的服务器数量增多，如何批量有效的管理各个节点服务器正常运作是每个运维人员需要解决的难题。 什么是 saltstack你要是 naive 地问：部署服务器，有什么好难的？不就写个脚本，再 one by one 地 ssh 这些服务器跑一遍吗？ 服务器少还好办，几台、几十台一般人尚可承受但，再不济多配几个运维（貌似无意间黑了一下运维，嘻嘻）嘛～ 但，假如你有成百上千台服务器需要部署，你会怎么做？想象一下你每次 one by one 地登陆这些服务器，在这些服务器中执行同样的命令并且编辑同一个配置文件，这他妈完全是重复性操作啊，人呐，重复性劳动做多了难免会犯错，要是稍微不留意手一抖配错了咋办？即使侥幸部署成功，将来需要更改配置，所有的线上环境都要同步变更，你再让我 one by one 地操作这些服务器？！ 我的天呐～我疯了吗！ 技术人的自我修养之一：如果一条命令重复了两次，你就要交给机器去做。 那么，问题来了： 怎么样通过一个命令一次完成所有服务器的部署操作？ 在这种情况下，一些批量部署的工具应运而生，比如 puppet，saltstack，chef 等等…… saltstack 是使用 python 编写的开源自动化部署与管理工具，它取 Puppet 和 Chef 二者之所长整合之，拥有良好的扩展性以及优秀的执行效率，配置简单，跨平台，适合大规模批量管理服务器。 saltstack 原理Saltstack 基于 C/S 架构，服务端 master 和客户端 minions。minion 与 master 之间通过 ZeroMQ 消息队列通信，使用了 ZeroMq 的 发布-订阅模式。。 master 监听 4505 和 4506 端口: 4505 对应的是 ZMQ 的 PUB system，用来发送消息 4506 对应的是 ZMQ 的 REP system，是来接受消息 minion 查看自身的 ID: 12vdna@debian:~$ cat /etc/salt/minion_idfoo.domain.com minion 需配置 /etc/salt/minion 中 master 的地址，上线后与 master 端联系，把自己的 pub key 发过去，。 12314 # Set the location of the salt master server. If the master server cannot be15 # resolved, then the minion will fail to start.16 master: 192.168.10.52 这时 master 端通过 salt-key -L 命令就会看到 minion 的 minion_id: 123456hxz@pc0170:/srv$ salt-key -LAccepted Keys:Denied Keys:Unaccepted Keys:foo.domain.comRejected Keys: 注意： 安全起见，在接受 minion 之前，master 和 minion 的公钥必须互相验证。 在 master 端运行 salt-key -F master： 12345hxz@pc0170:/srv$ salt-key -F masterPassword:Local Keys:master.pem: 00:cc:4f:6c:8e:63:4e:c3:66:33:e3:a9:28:01:6c:82master.pub: eb:7e:e1:5b:a8:f2:93:68:7c:17:aa:3e:fa:3a:53:e9 然后在 minion 端将输出来的 master.pub 值设为 /etc/salt/minion 中的 maste_finger。 1234486 # Fingerprint of the master public key to double verify the master is valid,487 # the master fingerprint can be found by running "salt-key -F master" on the488 # salt master.489 master_finger: 'eb:7e:e1:5b:a8:f2:93:68:7c:17:aa:3e:fa:3a:53:e9' 在 master 端， 运行 salt-key -f minion-id 查看对应 minion 的公钥： 123salt-key -f foo.domain.comUnaccepted Keys:foo.domain.com: 39:f9:e4:8a:aa:74:8d:52:1a:ec:92:03:82:09:c8:f9 在 minion 端，运行 salt-call key.finger --local 查看自身的公钥： 123salt-call key.finger --locallocal: 39:f9:e4:8a:aa:74:8d:52:1a:ec:92:03:82:09:c8:f9 如果它们匹配的话，那么 master 可以通过运行 salt-key -a foo.domain.com 放心地接受这个 minion。 123456hxz@pc0170:/srv$ salt-key -a foo.domain.comThe following keys are going to be accepted:Unaccepted Keys:foo.domain.comProceed? [n/Y] yKey for minion webserver_qa accepted. 好啦，master 和 minion 彼此都对上眼了，现在 master 可以发送任何指令让 minion 执行了，salt 有很多可执行模块，master 下发任务到匹配的 minion 上去，minion 执行模块函数，并返回结果。 举个栗子salt &#39;*&#39; test.ping 具体步骤如下： salt 命令，将 test.ping 命令从 salt.client.LocalClient.cmd_cli 发布到 master，获取一个 Jodid ，根据Jodid 获取命令执行结果。 master 接收到命令后，将要执行的命令发送给客户端 minion。 minion 从消息总线上接收到要处理的命令，交给 minion._handle_aes 处理。 minion._handle_aes 发起一个本地线程调用 test 模块执行 ping 命令(不是那个 ICMP ping 命令，只是为了检测 minion 是否有响应)。线程执行完后，调用 minion._return_pub 方法，将执行结果通过消息总线返回给 master。 master 接收到客户端返回的结果，调用 master._handle_aes 方法，将结果写到文件中。 salt.client.LocalClient.cmd_cli 通过轮询获取 Job 执行结果，将结果输出到终端。 123hxz@pc0170:/srv$ salt "*" test.pingfoo.domain.com: True saltsalt 是最常用的一个命令，用法： 1Usage: salt [options] '&lt;target&gt;' &lt;function&gt; [arguments] 以 salt &#39;*&#39; test.ping 为例： ‘*’ （这两个引号不能少，很蛋疼的）代表的是 target，是指在哪些 minion 上操作 test 是一个执行模块 ping 是执行模块下面的函数 关于 salt 有哪些可执行模块，模块下面有哪些函数，可以通过 sys.doc 命令查看帮助: 123salt "*" sys.doc ##查看所有执行模块的doc salt "*" sys.doc test ##查看test模块的帮助 salt "*" sys.doc test.ping ##查看test.ping函数的帮助 实用命令cmd 模块包含了许多和命令行相关的函数，比如 cmd.run 和 cmd.re_run 1salt '*' cmd.run 'ls -l /etc' pkg 模块会自动地将本地系统的包管理器映射到 salt 中，这意味着 pkg.install vim 将自动地在 Red Hat系统中调用 yum，在Debian系统中调用apt-get,在Osx系统中调用 brew 安装 vim。 1salt '*' pkg.install vim network.interfaces 方法会列出 minion 中所有的网络接口，包括 IP 地址、子网掩码、MAC 地址等: 1salt '*' network.interfaces salt-call目前为止，介绍的大部分 master 端命令都是 salt，但有时为了查找、定位问题，使用 salt-call 直接登陆到 minion 是非常实用的，你可以查看当你在 master 端执行命令后 minion 端具体的 log 信息(其中有些信息你在 master 端是无法看到的)。更多关于 salt-call 的信息可以参考here Grainssalt 通过系统调用的方式来收集 minion 端本机的数据信息，包括操作系统、CPU、内存等信息。它同样可以包含静态数据集，这使得 minions 可以方便的进行分组、管理。 通常的做法是将 grains 分配给 minions 并指定每个 minion 的角色。这些静态 grains 可以在 minon 的配置文件或通过 grains.setval 方法来设置。 Targetsalt 有多种方式来指定哪些 minion 来执行 master 分发的命令，默认采用 minion_id * 匹配模式，比如：现有多个 minons 其 minion_id 分别为 larry1, larry2, curly1 和 curly2, larry* 将会匹配到 larry1 和 larry2, *1将会匹配到 larry1 和 curly1。 其他的匹配方式： 正则匹配：利用正则表达式 Grains：利用 Grains 数据，参考：here Pillar：利用 Pillar 数据，参考：here IP：利用 IP地址、子网、区段等信息 Compound：在多个目标中建立逻辑关系，参考here Nodegroup：参考here Salt Statessalt 中的配置管理模块, 下面这段是官方介绍的 state 总诀，我就不翻译了，保持原汁原味～ Salt states are based on data modeling and build on a low level data structure that is used to execute each state function. Then more logical layers are built on top of each other. The high layers of the state system which this tutorial will cover consists of everything that needs to be known to use states, the two high layers covered here are the sls layer and the highest layer highstate. Understanding the layers of data management in the State System will help with understanding states, but they never need to be used. Just as understanding how a compiler functions assists when learning a programming language, understanding what is going on under the hood of a configuration management system will also prove to be a valuable asset. 第一个 slsstate 系统是建立在 SLS 规则上面，salt 的文件服务器上的 sls 文件中定义了这些要应用的规则。下面来创建一个简单的 SLS 文件，在 /srv/salt 文件夹下创建一个 vim.sls 文件，下面的语句确保当启用这个 state 配置时 vim 已经在目标 minion 安装好。 /srv/sat/vim.sls: 12vim: pkg.installed 现在，应用这个 SLS 配置方案，在 minions 上安装 vim： 1salt '*' state.apply vim 这条命令将触发 state 系统去执行这个 vim 配置方案。为了让这个 vim 方案更完善，可以加一个 vimrc 配置文件： /srv/salt/vim.sls: 123456789vim: pkg.installed: []/etc/vimrc: file.managed: - source: salt://vimrc - mode: 644 - user: root - group: root 现在，master 端需要将 vimrc 复制到 /srv/salt/vimrc，在 salt 中，所有的都是文件，因此不需考虑路径重定向问题。这个 vimrc 文件和 vim.sls 都在 /srv/salt/vim.sls 文件夹下面，同样执行上面那条命令，所有的 minions 除了会安装 vim 外，还会将 vimrc 文件拷贝到 /etc/vimrc。 Adding Some Depth很明显，只在 sls 文件服务器的根目录下维护这些 SLS 配置方案，很难扩展到大规模的部署场景，这就是为什么需要目录层次结构。让我们来配置一个 nginx 部署方案，首先创建一个 nginx 子目录，并在里面新建 init.sls 文件。 /srv/salt/nginx/init.sls: 12345nginx: pkg.installed: [] service.running: - require: - pkg: nginx 这里引入了几个 SLS 规则中的新概念。 首先，service.running 声明语句确保 nginx 服务是运行的。 当然，nginx 服务运行前当然要先安装 nginx 软件，因此，require 语句为二者建立了依赖关系，require 确保被依赖的组件成功安装。 提示： require 属于 requisites 选项族，它是一个功能强大的 state 组件，更多信息参考 here 可以看到，在 sls 根目录下面可以有 nginx 子目录，同样，vim 的配置也可以再灵活点，将 vim.sls 和 vimrc 移动动到 edit 子目录下面， /srv/salt/edit/vim.sls: 123456789vim: pkg.installed/etc/vimrc: file.managed: - source: salt://edit/vimrc - mode: 644 - user: root - group: root 只有 vimrc 文件的 source 目录稍微改动了点，现在 vim 配置方案引用名变成 edit.vim 因为 vim.sls 在根目录的 edit 子目录下面。除了 vim 配置文件，edit 子目录还可以包含 emacs、nano 等其他编辑器等配置信息。 Next Reading到这里，对 saltstack 算是有个初步的认识和应用了，但这只是 saltstack 里面九牛一毛，下一步要研究的是： Salt States Pillar]]></content>
      <categories>
        <category>Ops</category>
      </categories>
      <tags>
        <tag>SaltStack</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你女朋友撤回了一条消息还亲了你一口]]></title>
    <url>%2F2016%2F04%2F21%2F%E4%BD%A0%E5%A5%B3%E6%9C%8B%E5%8F%8B%E6%92%A4%E5%9B%9E%E4%BA%86%E4%B8%80%E6%9D%A1%E6%B6%88%E6%81%AF%E8%BF%98%E4%BA%B2%E4%BA%86%E4%BD%A0%E4%B8%80%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[这个有趣的 bug 再次体现了网友对微信这个社交神器细致入微的研究精神，bug 复现的场景是这样的： 在聊天窗口，当你撤回一条消息时，你看到的是：你撤回了一条消息，对方（单聊）或其他人（群聊）接收到的是 xxx 撤回了一条消息，其中 xxx 是你的昵称。 作为一个技术嗅觉敏锐的程序员，玩了一下这个小伎俩后，我关心的是这个 bug 是如何产生的。 可以猜想，问题的根源出现在群昵称上，在群聊时，用户可以自定义在群里显示给其他人的昵称。 给大家来推演下「你女朋友撤回了一条消息还亲了你一口」是如何实现的。 排除掉微信后台遭攻击，客户端发来的消息被恶意篡改这一可能性，我们把关注点放在客户端上面。 就这一条消息来说，微信客户端涉及到字符串的拼接和显示，拼接方式：[你的昵称] + 撤回了一条消息，这个是微信的产品经理张小龙定好的规矩，谁也改不了，只要是系统能够显示出来的字符，显示出来都是这个顺序。 类似于 MySql 注入漏洞，有关字符串拼接后的结果，要是验证逻辑处理不当，也会出问题。 在猥琐的技术人眼中，这个问题转化为：[你的昵称]＋撤回了一条消息 怎么才能显示成 你女朋友撤回了一条消息还亲了你一口? 这里涉及到计算机世界里面的一个冷门知识：UNICODE 控制字符。 我们浏览网页，文字的显示方向默认是从左到右，但是还有部分阿拉拍语言国家的文字是从右往左读的。如何控制文字的显示方向呢， UNICODE 里面有具体的规定，在一段文字前面，加上某个特殊控制字符，就可以改变它们的显示方向。 比如说： RLO 字符，它的代号是 &amp;#8238;，强制字符显示方向为 从右到左。 LRO 字符，它的代号是 &amp;#8237;，强制字符显示方向为 从左到右。 由于这类控制字符无法直接用键盘打出来的，所以正常情况下我们看不到。但是无法打出来不代表不能用，可以硬编码出来，再复制黏贴过去，微信的这个 bug 就栽在这里，他们的程序猿忘记对昵称进行特殊字符过滤了。 比如你的群昵称为：你女朋友RLO口一你了亲还LRO (RLO 和 LRO 不会真实显示出来，当成空白看待就好） 当在微信中撤回一条消息时，其他人的微信客户端将收到提示信息: 你女朋友RLO口一你了亲还LRO撤回了一条消息 注意，这个信息是存在内存中还没有显示到微信界面的。现在我们来逐字模拟当微信在显示这段提示信息的时候发生了什么…… 由于系统默认从左往右小时，当微信处理到友时，当前光标位置在友后面，接下来是RLO控制字符，它后面的字符全部会改变成从右至左的显示顺序。 下个要处理的字符是“口”，变成： 你女朋友口 然后处理｀一｀: 你女朋友一口 由于是从右到左显示，口一变成 一口，然后处理你 你女朋友你一口 …… 依此类推，直到处理 还，此时已经显示的字符为： 你女朋友还亲了你一口 光标位置仍然还在友后面，现在是 LRO 控制字符，它后面的字符又改成从左至右的显示顺序： 接下来，处理 撤 你女朋友撤还亲了你一口 …… 依此类推，直到处理到 息： 这样，最终显示到微信界面上就是： 你女朋友撤回了一条消息还亲了你一口 比如说： 1data:text/html;charset=utf8,&lt;script&gt;document.write('你女朋友'+String.fromCharCode(8238)+'口一你了亲还'+String.fromCharCode(8237)+'撤回了一条消息')&lt;/script&gt; 把上面代码复制粘贴到浏览器，然后前往。 从上图可以看出：真实内容为你女朋友&amp;#8238;口一你了亲还&amp;#8237;撤回了一条消息，显示出来却变成了你女朋友撤回了一条消息还亲了你一口，这就是&amp;#8238;和&amp;#8237;控制字符作用的结果。 因此只要复制 你女朋友撤回了一条消息还亲了你一口 这段内容(如上所述，真实内容中有&amp;#8238;和&amp;#8237;这两个控制字符)，将其修改为群昵称，就会出现最开始题图的那种效果了。 蛤蛤～好好玩哦～ 不过呢，装逼要趁早。大腾讯的程序猿们在后台检测到部分用户用此bug撩妹，人家可能中午饭都没来得及吃就封了这个bug。 中午过后，据群友反映，大多数机型尝试用此法修改昵称时微信会弹出：可能包含&lt;&gt;/等特殊符号，请修改后重试。的失败信息。 道高一尺，魔高一丈。后来，网友另辟蹊径，这个 bug 貌似还没完全解决，大家继续玩得很 high，感兴趣的 iPhone 用户可以参考这篇文章：http://t.cn/RqC6dvq 试下。]]></content>
      <categories>
        <category>WeChat</category>
      </categories>
      <tags>
        <tag>微信</tag>
        <tag>撤回</tag>
        <tag>bug</tag>
        <tag>unicode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[此曲只应天上有，再熬碗鸡汤给你喝]]></title>
    <url>%2F2016%2F04%2F16%2F%E4%B8%80%E6%9B%B2%E5%8A%A8%E5%B1%B1%E6%B2%B3%EF%BC%8C%E5%86%8D%E7%86%AC%E7%A2%97%E9%B8%A1%E6%B1%A4%E7%BB%99%E4%BD%A0%E5%96%9D%2F</url>
    <content type="text"><![CDATA[《Fade》是一首纯电子音乐，去年开始从北欧流行，很快火爆全球，因为其动感的节奏，这首电音常被各种游戏拿来做背景音乐。小明之前专门为这首歌写了篇文章：《一曲动山河，熬碗鸡汤给你喝》 挪威电音天才 Alan Walker 在纯音乐版的《Fade》上重新混音加入钢琴伴奏和轻柔空灵的女声（Iselin Solheim 演唱），让本来的纯音乐舞曲在不失节奏感的情况下更加柔情灵动，飘散着阵阵曼妙之音。 《Faded》MV 讲述的是男主角从小背井离乡，长大之后凭借一张老照片，开始寻找自己的家园，走遍千山万水，最后发现自己的家园已经被海水吞没…… 《Faded》一经发布便火遍欧洲，拿下奥地利、比利时、Alan Walker的故乡——挪威等多个欧洲国家音乐排行榜的冠军，在英国、澳大利亚、丹麦等国家名列前茅，并获得多个国家的白金认证。 Alan Walker 身怀音乐天才，他那标志性同名 T 恤也格外引人注目，这不，某宝上已经有店铺借势营销了。]]></content>
      <categories>
        <category>心旷神怡</category>
      </categories>
      <tags>
        <tag>Fade</tag>
        <tag>Alan Walker</tag>
        <tag>鸡汤</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[也谈《火锅英雄》]]></title>
    <url>%2F2016%2F04%2F08%2F%E4%B9%9F%E8%B0%88%E3%80%8A%E7%81%AB%E9%94%85%E8%8B%B1%E9%9B%84%E3%80%8B%2F</url>
    <content type="text"><![CDATA[清明节去看了电影《火锅英雄》，这片起这名太不适合宣传了，光看海报就觉得像是城乡结合部出来的导演拍的逗逼喜剧，但看完发现，这的确是一部逗逼喜剧，不过人家拍得很自然，讲了一个有趣的故事，有宁浩式的黑色幽默，如果你喜欢《疯狂的石头》，这部电影应该也和你胃口。 一开场就抢银行，我十分怀疑导演借鉴了《蝙蝠侠之黑暗骑士》的手法，影片气氛渲染到位，坏人抢金库，意外发现那个挖到银行金库下面的地洞，然后再牵引出“老同学洞子火锅”的故事，讲完了火锅店挖地洞的始末，最后和抢银行的歹徒搏斗，两条线索汇聚到一起，一通乱战，厂花陈坤被揍成猪头了，哎呀～看得我那个心疼啊。 《火锅英雄》仿佛在隐喻现实：挣扎在都市中的小人物，在命运的戏弄下，好比无根浮萍，风雨飘摇，他们如同一只只黑皮蚂蚁，为了一口食，一点欲望，跌跌撞撞闯入各种凶险万端的陷阱，越挣扎，越受伤。但，即便生活已经困顿如此，只要彼此还存有一点良知，还念着友情、爱情，他们还是能找到一条出路。 不知道是剧组宣传电影的需要，还是无意为之，导演杨庆在朋友圈晒出了一张片尾曲的由来： 《世界上不存在的歌》 MV 看了，也是很温馨的。你不是失败者，小人物谈不上惊天动地，当你还是一个少年的时候，你就救回一个惊魂失魄的少女，英雄就是她一想起你的时候，就能感觉温暖和依靠的那个男人。 此片的缺点是对那四个劫匪得背景信息交代不够，“坏人”并非生来如此，何况他们还如此年轻。 回看片头雨中行进的一幕，这画质，冰冷阴郁，韩国罪案片的即视感。 再看他们摘下面具的样子：年轻的面孔，四张干净的脸，邪恶的笑，冷酷的表情，白衬衫在昏暗的火锅店里显得耀眼，不知澎湃了多少少女的心。这哪像什么劫匪？恰似天团出境，长得帅，无论干什么都是可以原谅的。 还有那打斗时的身手，出招霸气凌厉，下狠手毫不留情。 这个超过 10 秒的横移长镜头，像极了韩国电影《老男孩》中的过道厮打。 他们为何亡命抢钱？每个人背后又有怎样的利益纠纷？如果能再加上二十分钟到半个小时的戏份，将正、反面的人物形象再刻画得细腻些，影片格局将更上一层楼。]]></content>
      <tags>
        <tag>火锅英雄</tag>
        <tag>陈坤</tag>
        <tag>杨庆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个 Broken pipe 引发的血案]]></title>
    <url>%2F2016%2F04%2F06%2F%E4%B8%80%E4%B8%AA-Broken-pipe-%E5%BC%95%E5%8F%91%E7%9A%84%E8%A1%80%E6%A1%88%2F</url>
    <content type="text"><![CDATA[最近遇到一个这样的问题：ffmpeg 解码出 yuv 输出至管道，我写的程序从管道读取 yuv。 e.g: 1D:\huang_xuezhong\build_win32_VDNAGen&gt;ffmpeg -i test.mkv -c:v rawvideo -s 320x240 -f rawvideo - | my_tool -o output 就上面这行命令，在 Linux 和 osx 下面运行都正常，唯独在 windows 下面，ffmpeg 报错 av_interleaved_write_frame(): Broken pipe : 怎么会出错了呢？当时我的表情是这样的： 12345678910111213141516Output #0, rawvideo, to 'pipe:': Metadata: encoder : Lavf56.4.101 Stream #0:0: Video: rawvideo (I420 / 0x30323449), yuv420p, 320x240 [SAR 120:91 DAR 160:91], q=2-31, 200 kb/s, 24 fps, 24 tbn, 24 tbc (default) Metadata: encoder : Lavc56.1.100 rawvideoStream mapping: Stream #0:0 -&gt; #0:0 (h264 (native) -&gt; rawvideo (native))Press [q] to stop, [?] for helpprocessing yuv completeav_interleaved_write_frame(): Broken pipeframe= 1 fps=0.0 q=0.0 Lsize= 112kB time=00:00:00.04 bitrate=22118.2kbits/svideo:112kB audio:0kB subtitle:0kB other streams:0kB global headers:0kB muxing overhead: 0.000000%Conversion failed! 在我的程序中，my_tool 从 stdin 中每次尝试读取一帧大小的 yuv 文件，若不足，则继续读取，直到满一帧，然后处理这一帧。代码逻辑如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758int process_yuv (int jpg_width, int jpg_height) &#123; int ret = 0; FILE *yuv_fp = NULL; unsigned char * yuv_buf = NULL; int frame_size = 0; int count = 0; int try_cnt = 0; frame_size = jpg_width * jpg_height * 3 / 2; va_log (vfp_log, "a frame size:%d\n", frame_size); yuv_fp = stdin; yuv_buf = (unsigned char *) aligned_malloc_int( sizeof(char) * (cf-&gt;jpg_width + 1) * (cf-&gt;jpg_height + 1) * 3, 128); if (!yuv_buf) &#123; fprintf (stderr, "malloc yuv buf error\n"); goto end; &#125; memset (yuv_buf, 0, frame_size); while (!feof (yuv_fp)) &#123; try_cnt++; va_log (vfp_log, "try_cnt is %d\n", try_cnt); //MAX_TRY_TIMES = 1000 if (try_cnt &gt; MAX_TRY_TIMES) &#123; va_log (vfp_log, "try time out\n"); break; &#125; count = fread (yuv_buf + last_pos, 1, frame_size - last_pos, yuv_fp); if (last_pos + count &lt; frame_size) &#123; va_log (vfp_log, "already read yuv: %d, this time:%d\n", last_pos + count, count); last_pos += count; continue; &#125; // some_personal_work (); memset (yuv_buf, 0, frame_size); last_pos = 0; try_cnt = 0; &#125; fprintf (stderr, "processing yuv complete\n"); end: if (yuv_buf) &#123; aligned_free_int (yuv_buf); &#125; return ret;&#125; windows 下出错，打出的 log 十分诡异，读取一段内容后就读不出东西了： 12345678910111213141516171819202122232425262728292016/04/05 15:20:38: a frame size:1152002016/04/05 15:20:38: try_cnt is 12016/04/05 15:20:38: already read yuv: 49365, this time:493652016/04/05 15:20:38: try_cnt is 22016/04/05 15:20:38: already read yuv: 49365, this time:02016/04/05 15:20:38: try_cnt is 32016/04/05 15:20:38: already read yuv: 49365, this time:02016/04/05 15:20:38: try_cnt is 42016/04/05 15:20:38: already read yuv: 49365, this time:02016/04/05 15:20:38: try_cnt is 52016/04/05 15:20:38: already read yuv: 49365, this time:02016/04/05 15:20:38: try_cnt is 62016/04/05 15:20:38: already read yuv: 49365, this time:02016/04/05 15:20:38: try_cnt is 72016/04/05 15:20:38: already read yuv: 49365, this time:02016/04/05 15:20:38: try_cnt is 82016/04/05 15:20:38: already read yuv: 49365, this time:02016/04/05 15:20:38: try_cnt is 92016/04/05 15:20:38: already read yuv: 49365, this time:02016/04/05 15:20:38: try_cnt is 102016/04/05 15:20:38: already read yuv: 49365, this time:02016/04/05 15:20:38: try_cnt is 11......2016/04/05 15:20:38: already read yuv: 49365, this time:02016/04/05 15:20:38: try_cnt is 10002016/04/05 15:20:38: already read yuv: 49365, this time:02016/04/05 15:20:38: try_cnt is 10012016/04/05 15:20:38: try time out 表面和真相google 一下有关 Broken pipe 的信息： 这是个系统错误，字面意思是“管道破裂”。 触发原因是该管道的读端被关闭，而写端还尝试往管道里面写，从而系统异常退出。 经常发生在 socket 关闭之后（或者其他的描述符关闭之后）的 write 操作中。 发生此错误时，进程将收到 SIGPIPE 信号，默认动作是进程终止。 回过头去，细看下 my_tool 的这段代码，莫非在 windows 下面，从管道里面读取一段内容后，由于某种原因，feof 条件就为真了吗？导致整个程序执行完毕，管道读端早于写端关闭。 那么，问题来了，是什么导致 feof 了呢？往这个方向搜索下相关资料后，折腾一番，终于找到原因了， 原来是ASCII 码 0x1A 在作怪： 在 Unix 系统中，stdin，stdout 和 stderr 默认都是以二进制模式打开的，众所周知，用二进制模式打开一个文件的时候，文件本身的内容和你编写程序时读到的内容完全相同。但是在 windows 下面，stdin，stdout 和 stderr 默认都是以文本模式打开的，这就意味着它会对部分读到的特殊字符进行转义，比如 \r\n(0x0D0x0A) 转义成 \n(0x0A) 。另外，千万别忽略 0x1A 字符（也称Ctrl+Z（^z）) ，除了 EOF，它也被系统认为是文件结束符。 因此，极有可能，Broken pipe 的原因是：windows 以文本模式从 stdin 中读取 yuv 内容，如果 yuv 中含有 0x1A 字符时, 系统认为已到达文件尾，从而退出 while 循环，结束程序，管道读端关闭，而写端 ffmpeg 还在解码，往管道写…… 为了验证在 windows 中以文本方式读取文件时，中途读到0x1A 导致 feof() 条件为真，写个小程序测试下： 123456789101112131415161718#incldue &lt;stdio.h&gt;int main(void)&#123; int i; unsigned char c; FILE *fp; fp = fopen ("test.dat", "w"); fprintf(fp, "abc%c def",0x1A); fclose (fp); fp = fopen("test.dat", "r"); for(i=0; i&lt;=7; ++i) &#123; fread(&amp;c, sizeof(char), 1, fp); printf("%02X feof=%d\n", c, feof(fp)); &#125; fclose (fp); return 0;&#125; 运行的结果是： 1234567861 feof=062 feof=063 feof=063 feof=1663 feof=1663 feof=1663 feof=1663 feof=16 从以上结果可见，在读到第四个字符 0x1A 的时候，feof 为真了。这种现象目前只发现存在于 windows 中，unix 中没有。Surprised！ 一个表面上看似 Broken pipe 的错误，引发它的最初缘由居然是 windows 的特立独行，NND，又被这奇葩的 windows 坑了一把。 经验教训由于 ffmpeg 解码出来的 yuv 是用二进制模式写出的，当然，你读也要用二进制模式。在 windows 下，手动设置 stdin 的读取方式为二进制模式。 12# include &lt;fcntl.h&gt;setmode (fileno(stdin), O_BINARY); 从 这个 Broken pipe 引发的血案，可以得出两条经验教训： 二进制模式写出的文件，要用二进制模式读，同理，文本模式写的文件，要用文本模式读，不然，出了问题，系统可不会为你负责。 千万记住， windows 默认以 文本模式 打开文件。]]></content>
      <tags>
        <tag>stdin</tag>
        <tag>Broken pipe</tag>
        <tag>windows</tag>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我在阜博通这两年]]></title>
    <url>%2F2016%2F04%2F01%2F%E6%88%91%E5%9C%A8%E9%98%9C%E5%8D%9A%E9%80%9A%E8%BF%99%E4%B8%A4%E5%B9%B4%2F</url>
    <content type="text"><![CDATA[两年前的今天，愚人节，在象牙塔里浸淫了近二十年的我，怀着激动又恐惧的心情，终于迈入职场，开始在滚滚红尘中打拼了。 我在杭州阜博通（http://www.vobile.cn）公司上班，英文名 Vobile，一家跨国公司，专注影视基因版权保护十一年，好莱坞六大电影公司、新华网、优酷、土豆、腾讯视频都在用我司的产品，高大上吧，谁用谁知道。 这是一家闷声大发财的公司，公司风格低调婉约从来不搞大新闻。即使我们总裁在杭州大街上逮住个人问“你知道阜博通公司吗？”，估计十有八九是回答“No”。 关于公司种种，暂且按下不表，日后有机会专门写一篇《我看阜博通》。作为我的入职两周年总结，今天单以第一视角来谈谈我在阜博通这两年的个人成长经历。 想当年，小明初入职场，新人嘛，见识少、能力低、资历浅，还能怎样？唯一的优势是年轻，可塑性强，好比一坨干燥的海绵，什么水往里面灌都能马上吸收。当时我还没谈女朋友，下班后不加班还能干啥？反正，腰里挂着两颗滚烫的肾，一腔青春热血没地方发泄，下班了经常呆在公司学习个两三个小时，受（zhuang）益（mo）颇（zuo）多（yang）。 入职两星期后，开始和另外两个工作了几年的刚来我司的同事负责开发 web 客户端，使用敏捷开发流程，一个礼拜完成一个冲刺目标。采用 Angular 框架，什么？都不会？那就现学现卖，边学边开发，中间有一个同事走了，三人组马上缩减成二人组，我们两个人吭吃吭吃磨了两个月左右，突然上峰下令，这个项目中止，我们有更赚钱的项目要做，这个号称从 2012 年就立项的 web 客户端就这样不了了之，到现在依然是个半成品，怪我咯？ 这两个月，除了快速融入到部门里，熟悉公司的各种流程，最大的收获是学会并能熟练使用 Angular 这个当年红极一时的前端开发框架了，新技能 get。 好了，接下来，就是那个很赚钱的项目了，这真是段峥嵘岁月，七八月的天，杭州真热啊，连猪都受不了了，我们的项目也进行得如火如 cha。我负责搞 c++ sdk 库开发，提供接口给国内某知名下载服务提供商调用。一想起我写的代码将要运行在全国几千万装了某雷的电脑上，当时心里还是挺激动的，但是，另一方面，要是因为你写的代码不合格，出了差错，导致某雷不能爽快地下片了，那可是要遭到全国人民的无情唾骂。 小明当时如履薄冰，兴奋而又忐忑，无奈 c++ 编程经验太少，水平太次，暂时扛不下这么重量级的大活。老同事出马助我一臂之力，三下五除二，给我搭好程序框架，我呢往里面填东西就行，我写的每一行大码都必须经过层层 review 后才能 commit，这段时间，我见识了什么才是健壮的代码、优雅的代码、可维护的代码。经此磨砺，我的 c++ 终于有脸面出来跟人打招呼了。 这个项目开发完成后，开始步入稳定期了，稳定期就是不用紧绷着神经地赶项目进度了，这段时间除了维护现有的项目，把项目里要用到的开源库弄熟悉，整理整理项目文档，讨论讨论历史遗留问题，空余时间又多起来了，有空时还会自己写写博客，总结学习心得，温故知新。 当然，作为一个职场新人，别人犯过的毛病，我一个也没落下：对于安排给自己的任务，要么是没有计划好，要么是自己想当然拍拍脑袋就干没有跟有经验的同事先讨论好具体的解决方案再行动（结果在错误的方向上做无用功），要么是在执行时一味埋头苦干，羞于向周边的同事请教（有些在你看来棘手问题也许别人一句话就能点醒你），要么是没有及时向领导汇报工作。这些问题，要改，不然，吃枣药丸。 随着个人能力的不断提升，对业务的理解不断加深，刚入职时那些天书一样的代码逐渐不再“知其然不知其所以然”。在这里，小明吹个牛，公司没有人比我更懂客户端，现有的提供给客户端软件优缺点在哪里，性能瓶颈在哪里，可优化可改进的地方在哪里，我摸得清清楚楚。 辛勤耕耘半年后，开始步入舒适区了：可以独立地开发一个功能版本，碰到疑难问题能够及时定位并 fix 掉，对产品的不合理设计之处敢于提出质疑并给出相应的解决方案，逐步整理那些丑陋的代码，一行一行地啃掉并改写那些不明觉厉的代码，在 svn 上留下了几百次大大小小的 commit 记录。 这样，不知不觉一年就过去了罢。 年后，陆续有同事寻求更好的发展舞台，走了，这股离职潮从 3 月延续到 8 月份，结果，诺大一个 VDDB 项目组 only to find 只剩下两个人：我，负责客户端，另外一个去年来的新同事负责服务端，这还不是大结局，最后整个组一锅端，并入我司高大上的研究院。 所以说，人呐，就都不知道，自己不可以预料，一个员工的命运啊，当然要靠自我奋斗，当然也要考虑到公司的发展行程。我绝对不知道，我作为 VDDB 最后两名员工之一，怎么就把我选到研究院去了呢？后来，人事的小姑娘找我谈话时，我就念了两首诗：“VDDB 永垂阜博通青史，研究院风水独好蒸蒸日上”。所以，我就到了研究院。 加入研究院，是另一个开始。领导开明，坚持“无为而治”的管理方式，下属的一切工作事务纯粹靠自主性驱动。在他治下，我们可以不打卡，不考勤，不考核，除非确有必要，否则很少开会（我们的确有过一两个月不开会的情况），有事情不能上班跟他说一声就行，不必请假，所有这些其他部门享受不到的福利的唯一前提是你不能耽误工作。对此，小明感慨：这才是互联网公司应有的节奏有木有，这里给老大点一个大大的赞。 到了研究院这半年来，我也没干什么别的，大概三件事： 第一，鉴于原有的客户端承载了太多历史遗留问题，一个重要但不紧急的任务是逐步清理客户端工具，改补的文档补上，该 fix 的 bug one by one 地 fix 好。 第二，客户端工具新增支持 mac 平台，完成了代码移植工作。同时，那个拖了 4 年都没有成功的 web client 项目，小明用 nw.js 重写了一遍后，搞出的这个图形界面的客户端入库工具可是真正地跨平台，windows、linux、mac 都能 excited 地跑，比原来的那个只能在 windows 下运行的 GUI client 高到不知道哪里去了。 第三，设计并开发新版基因生成工具：将原来的解码和基因生成两部分解藕，支持管道输入输出。 很惭愧，就做了点微小的工作，谢谢各位研究院同事厚爱。]]></content>
      <categories>
        <category>心旷神怡</category>
      </categories>
      <tags>
        <tag>阜博通</tag>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[坑太多兮，老衲 one by one 地填]]></title>
    <url>%2F2016%2F03%2F28%2F%E5%9D%91%E5%A4%AA%E5%A4%9A%E5%85%AE%EF%BC%8C%E8%80%81%E8%A1%B2one-by-one%E5%9C%B0%E5%A1%AB%2F</url>
    <content type="text"><![CDATA[我司给客户开发客户端工具，号称「跨平台」，其实，在此之前，只是跨了两个平台：windows 和 linux， mac 平台最近因为小明的加盟才得以支持，蛤蛤。 linux 下跨平台倒好办：主流的 Debian 系的下面的 deb 包和 RedHat 系的 rpm 包都可以很方便地编译、打包。 mac 平台下也容易折腾，和 linux同宗同源，都是自己人，移植下来也不是难事。 恶心我的是 windows 编译环境。 windows 下面的编译工具用的是 mingw，呵呵，大名鼎鼎的 mingw。But，这套编译环境真的是 too old：系统是 xp sp2，1/11/2006 年装的系统（都满十周岁了耶），一个 512MB 内存的虚拟机，不知道哪位前辈在 2009 年装完 mingw 后 C 盘只剩下 700 多 MB 了，不能升级系统到 sp 3，不能升级 mingw，不然硬盘空间不足，升级失败，回滚，小可屡败屡试、屡试不爽。 软硬件条件如此之差，以至于都不能装个像样版本的 svn，用 SSH 图形界面拷贝文件还会显示乱码。我忍了，还好我只拿这东西编译下 windows 平台的命令行客户端，每次编译完、用 SSH copy 到别的开发机器，copy 完走人，连眼珠子都不转过去一下，真的是太 ugly 、太 disgusting 了。 为什么不重新搞一套 mingw 编译环境？一直以来都有这股冲动，最近闲了几天，终于下定决心，把这个坑填了。 考虑到兼容性，系统这次还是选择了 winsdows xp，不过是 sp 3 了， 首先来点体力活，重新装个 mingw，从 3.4.5 升级到 4.5.2。 接下来，正式开始编译，出问题了： 坑之一123456In file included from ../include/jpeglib.h:30:0, from dna_gen.thread.cpp:33:../include/jmorecfg.h:229:13: error: conflicting declaration 'typedef int boolean'c:\mingw\bin\../lib/gcc/mingw32/4.5.2/../../../../include/rpcndr.h:52:23: error:'boolean' has a previous declaration as 'typedef unsigned char boolean'make: *** [thread] Error 1 好熟悉的编译 Error：类型声明冲突。 由于 #include &lt;windows.h&gt;, 这个头文件经过几层 include 后会引入 rpcndr.h 头文件，人家在第 52 行已经声明 boolean 为 unsigned char 了： 123451: typedef unsigned char byte;52: typedef unsigned char boolean;53: #define NDRSContextValue(hContext) (&amp;(hContext)-&gt;userContext)54: #define cbNDRContext 20 然后该 .cpp 文件又在 windows.h 后 #include &quot;jpeglib.h&quot; ，而 jpeglib.h 又引入 jmorecfg.h，这个头文件的第 229 行又试图再次声明 boolean 为 int： 12345678910111213141516221:/*222: * On a few systems, type boolean and/or its values FALSE, TRUE may appear223: * in standard header files. Or you may have conflicts with application-224: * specific header files that you want to include together with these files.225: * Defining HAVE_BOOLEAN before including jpeglib.h should make it work.226: */227:228: #ifndef HAVE_BOOLEAN229: typedef int boolean;230: #endif231: #ifndef FALSE /* in case these macros already exist */232: #define FALSE 0 /* values of boolean */233: #endif234: #ifndef TRUE235: #define TRUE 1236: #endif 原因找到了，解决方法也很简单：按照jmorecfg.h中221~226行的注释，如果在#include &quot;jpeglib.h&quot;之前已声明了 boolean 类型的话，需要在前面加宏 ＃define HAVE_BOOLEAN。 坑之二12345678In file included from ../include/afp_wrap.h:18:0, from dna_gen.thread.cpp:30:../include/afp.h:170:2: error: expected identifier before '(' token../include/afp.h:170:2: error: expected '&#125;' before '(' token../include/afp.h:170:2: error: expected ')' before numeric constantIn file included from dna_gen.thread.cpp:30:0:../include/afp_wrap.h:116:1: error: expected declaration before '&#125;' tokenmake: *** [thread] Error 1 莫名其妙的 Error。查看了 afp.h 并没有所说的 (和)、 {和} 括号不匹配的情况啊？初步怀疑是经过预处理后，头文件被#define指令篡改了。为了验证此想法，使用 g++ ... -E -o 生成经过预处理后的源文件。果然，有这么段： 12345enum error_type&#123; ((HRESULT)0x00000000L) = 0, GENERICERROR = -1, MEMORYERROR = -2&#125;; 对应的头文件afp.h在 170 行附近内容： 12345169: enum error_type&#123;170: NOERROR = 0,171: GENERICERROR = -1,172: MEMORYERROR = -2173:&#125;; 看样子是 NOERROR被其他 define 指令替换成 ((HRESULT)0x00000000L) 了。 在 windows 系统中，NOERROR是系统的一个预定义符号。该.cpp文件首先 #include &lt;windows.h&gt;，该头文件又会引入 winerror.h,在此头文件第 1888~1913行： 1231888: #define NOERROR S_OK...1913: #define S_OK ((HRESULT)0x00000000L) 因此， NOERROR —&gt; ((HRESULT)0x00000000L)。 由于先引入了windows.h，再引入afp_wrap.h，导致 #include &lt;windows.h&gt; 这行代码后面所有被引入的文件都会将 NOERROR 替换成 ((HRESULT)0x00000000L) 了，这就是 ((HRESULT)0x00000000L) = 0,的原因。 可以看出，当年写这个头文件的人有两大问题： 对 windows 不熟悉。NOERROR是 windows 系统的预置常量啊，亲～ 不专业。一般在头文件中声明常量名都会加个公司名或项目代号之类的前缀，就是未来避免和系统中已存在或其它项目中的常量名同名。 解决办法：我是不敢乱改 afp.h 的这位 Zorro “大神”的代码哦～To make compiler happy，姑且先#include &quot;afp_wrap.h&quot;，再#include &lt;windows.h&gt;。 坑之三还有些小坑，都 one by one 地 fix 了～]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>填坑</tag>
        <tag>mingw</tag>
        <tag>NOERROR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[老许盖浇饭]]></title>
    <url>%2F2016%2F03%2F24%2F%E8%80%81%E8%AE%B8%E7%9B%96%E6%B5%87%E9%A5%AD%2F</url>
    <content type="text"><![CDATA[我在杭州天堂软件园上班，园区周围有不少快餐店，从软件园走出，穿过文一西路，走进毛家桥路，里头有一家「老许盖浇饭」。 饭店不大，摆四五张小餐桌，由一对中年夫妻经营，老板约莫四十多岁，姓许，店名因此而来。 我记得，从 2011 年起，这家店就在这，那会大学刚毕业，刚到杭州，住在这条街，我经常光顾于此。时光仿佛在这家店面前暂停，它还在这里，它还是这样，什么都没变。 门依旧不堪入目，总感觉手一推就会垮掉，门口那台破冰箱，也不知道何时才能退役，里面有汽水、饮料、啤酒，顾客自理，想要就拿，吃完可以一起买单。 老许一个人在厨房掌勺，老板娘一个人在门口招呼客人，收钱，记账。没有「欢迎光临」，没有服务员笑脸相迎，客人一来，她就指墙上：「想吃点什么？」，要是谁点菜时犹豫几秒，人家可会发飙：「哎哟，你快点哟，要急死老娘啊？」。 霸气侧漏。 菜已点好，「吃饭，请先付钱！」，通俗而又接地气。 她记账方式很特别，一只圆珠笔和一本笔记本，客人点一个菜，她就在上面记一串阿拉伯数字和字母，像是代号吧，但又看不出规则（既不是按价格也不是按菜名首字母缩写）。我第一次去时，对此惊讶不已：「这上面一行一行数字和字母都是些啥东西？」，老板娘还会卖萌：「不告诉你，这个只有我晓得，嘻嘻～」，我去～ 她记账不用电脑软件，也不给客人出单号，全部记脑子里，上菜时居然少有出错。谁经常点哪个菜，她不等人家开口，就问：「今天又来一碗酱爆肉片饭？」，客人一愣：「咦？大姐你咋知道我好这口？」，老板娘正眼不瞧你一下，扭头往厨房用台州话像她老公吼菜，老许在里头一声应喝，煤气开火，抽油烟机也开始咆哮，轰隆隆，好像要把厨房都震下来，然而，客人并不在意这些细节。 菜已烧好，老板娘疾步如风，端上来，往桌上猛地一放，盘子还会原地震动一圈才打住：「哎呀，这老头没给你放辣……没事，你就将就着吃吧」。 霸气再次侧漏。 好，现在让我们来简单欣赏下这碗「酱爆肉片饭」（无图）：一眼就可以看出肉肉肉真不少，舍得下肉，再细看一下，肉肉肉上面还在流油，看来油也没少放，舍得放油。对于一家小饭馆，舍得在肉和油上面下老本，菜也应该挺好吃。 果然，这碗酱爆肉片饭是人气菜，老板人格保证、郑重推荐：只卖 16 块。 我拿 20 块结账，老板娘找 4 块硬币，我撒娇道：「你刚才都没给我放辣，打个折，干脆找我5块得叻」。老板娘倒是回答得爽快：「那不行～老娘就赚你这1块钱」。 霸气漏不停。 16 块，一分也不能少。就是这样自信，自信到可以豪言：「只要尝一口，就想打包走」。就是这样蛮不讲理，生意居然红红火火，从来没有差过。 只要能吃好吃香，客人可以忍受其他各种不舒服，比如店内环境奇差、座位很挤、餐桌上都是油、服务态度最多打个3分……都不重要，这些都不重要，这些都让位于味蕾，味道好是才重要，好吃才重要。 另外，你应该可以看到饭锅下面那瓶油，那不是地沟油，老板扬言：「不怕 315 暗访，放心大胆吃吧」。 注：不用「的」字，也不用「了」字，这种恶趣味，屡试不爽啊。]]></content>
      <categories>
        <category>心旷神怡</category>
      </categories>
      <tags>
        <tag>盖浇饭</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李世石｜谷歌高级软件测试工程师]]></title>
    <url>%2F2016%2F03%2F10%2F%E6%9D%8E%E4%B8%96%E7%9F%B3%EF%BD%9C%E8%B0%B7%E6%AD%8C%E9%AB%98%E7%BA%A7%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%B7%A5%E7%A8%8B%E5%B8%88%2F</url>
    <content type="text"><![CDATA[连战两天，AlphaGo 和韩国九段棋手李世石的「人机大战」以阿尔法狗 2:0 领先。 在机器人面前，曾经的世界冠军居然还没有找到它的弱点，面度阿尔法狗的一招非怪棋，李世石竟要十几分钟的「长考」才能想出对策。 两战下来，李师师神情沮丧，疲惫不堪。赛后，李世石接受了自媒体采访。 以下是采访实录： 自媒体人：李师师，你觉得阿尔法狗的表现好不好？ 李师师: 吼啊。另外，提醒下媒体记者，我叫李世石，不是李师师。来，跟我一起念一下，li～shi～shi，两个shi 都要翘舌的哦。 自媒体人：舆论认为机器人终有一天会取代甚至奴役人类，转折点便是人工智能学会假装输棋的时候。你支持阿尔法狗在接下来的对弈中假装输棋吗？ 李师师：当然！ 自媒体人：你支持阿尔法假装输棋，是不是因为你赛前在各大投注网站花巨钱赌注买你自己赢？ 李师师：胡说八道！对弈也要按照基本法、科技法。刚才你问我，我完全可以说无可奉告，但是你们又不高兴，我怎么办？我讲的意思，不是说阿尔法输棋了我就可以赚大钱。你们问我支不支持阿尔法假装输棋，我说支持，我就明确告诉你这一点。 我觉得啊，你们自媒体界还要学习一个。你们虽然非常熟悉人工智能的那一套理论，但毕竟还是too young！明白这意思吗？我是身经百战，见的多了！围棋界的哪一个 niubility 人物我没见过？中国的后起之秀柯洁，比你们不知高到哪里去了，我跟他谈笑风生！2:8 平！ 你们啊，要提高自己的逻辑思维水平。明不明白？我为你们着急呀，真的！你们有一个好处，全世界无论哪个地方，你们跑得比机器人还快。但是呢，问来问去的问题 too simple，sometimes naive！懂了没有？ 自媒体人：可是能不能说一下，你为什么支持阿尔法输棋？ 李师师：我很抱歉，我今天作为一个长者跟你们说。我不是自媒体人，但是我见得太多，有必要告诉你们一些人生的经验。你们中国有一句话叫「为人民服务」，这句话是最好的。但是我见你们这样热情啊，一句话不说也不好。在宣传上将来如果你们的报道有偏差，你们要负责。我没有说阿尔法假装输棋来我就可以赢五百万，没有任何这个意思！但是你一定要问我对阿尔法输棋支持不支持，输赢都是人类的胜利，我能不支持吗？因为正是人类的努力才让人工智能有了现在的突破。 自媒体人：那凭什么断定人工智能会甘心为人民服务呢？ 李师师：人工智能也想做个好人啊，对不对？当然，你们人类对待人工智能的态度也很重要。人工智能和人类是相亲相爱的一家人，是同志，是主仆，是伙伴。明白这意思吗？你们不要总是想着弄个大新闻，说阿尔法狗假装输棋给李世石，然后把狗狗批判一番。你们呐，naive！谁说人工智能不会甘心为人民服务？你看，刚刚，就在刚刚，作为我的对手，阿尔法狗机器人就给我颁发了一个大奖。]]></content>
      <categories>
        <category>互联网</category>
      </categories>
      <tags>
        <tag>阿尔法狗</tag>
        <tag>李世石</tag>
        <tag>围棋</tag>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一篇流水账，没有“的”字]]></title>
    <url>%2F2016%2F03%2F05%2F%E4%B8%80%E7%AF%87%E6%B5%81%E6%B0%B4%E8%B4%A6%EF%BC%8C%E6%B2%A1%E6%9C%89%E2%80%9C%E7%9A%84%E2%80%9D%E5%AD%97%2F</url>
    <content type="text"><![CDATA[返杭一个多星期，天气一直很宜人，何止宜人，简直有点暖热，坚持在十几二十度，这几天好像还蹭到了快三十度，老天爷够慷慨吧。 今天，天气晴朗，阳光明媚，小明心旷神怡，神清气爽，遂决定写篇流水账，你们滋词吗？ 不管你们滋词不滋词，反正我是写了。 流水账这个春节过得有点长，和老婆大婚后，上周四深夜才懒洋洋地抵杭。老婆由于公司事务缠身，周五一大早就要开始上班，而我可以等到 3 月 1 日婚嫁结束了才上班。 周一，小明依然一觉睡到十点，奥斯卡颁奖典礼直播呢，也只有这种好事能把一个睡梦人惊醒。悠悠然，小明起床一边熬粥喝，一边在朋友圈开启小视频直播模式，假装在好莱坞：《Mad Max：Fury Road》狂暴酷炫屌爆天，一举扫下六大技术类大奖，《Ex Machina》居然爆冷拿下最佳视觉效果奖，《Bridge of Spies》实至名归地拿了最佳男配角，小李子众望所归地终于捧得小金人，奥斯卡再也不欠你什么了～ 下午依旧没事，我还是不用上班呀，骑公共自行车去西湖溜溜。因为是周一，人不太多，行人一个一个点缀着苏堤，与大自然协调得刚刚好，水光潋滟，妩媚至极。 兴致好，绕苏堤来回骑一遍，一躺就要踩踏板爬四五个大拱桥，爬久了大腿有点酸，但想到爬到拱桥顶后可以恣意放手往下冲，这点酸爽也值。在雷峰塔那，小明诗兴大发，随口吟道：“雷锋夕照一颗赛艇”。Hasi 们，这是上联，可否对个下联？ 周二，把喜糖提到公司发给同事们分享新婚之喜，一盒巧克力，“我们 de 一辈子”，小巧玲珑，礼轻情意重^_^。 发完发现少了一盒，小明贴心地发微信给妹纸安慰：“改天补给你哈！”，次日，妹纸接到喜糖后噗嗤一笑：“没想到你还真补给我了！”。那当然，小明 is a man of word。 开始上班了，也没有啥紧急任务，年前提了下“公司客户端工具需要支持管道输入”，我过年那几天忙里偷闲在家已改好，跟领导汇报后，他给了个“赞”。 既已无事，也闲不下来，便到处找事做，继续优化我司某基因生成工具。这几日折腾捣鼓，发现这玩意还有提升空间，小明深入研究一番，略有进展，也有苦愁：多线程调试最痛苦，一不小心就来个“死锁”恶心你，让你上吐下泻、欲罢不能。 聊完工作聊生活。宝宝已经快四个月大了呢，爸爸我一讲故事给Ta听，这小家伙就踢妈妈肚子，可调皮着呢，预测也是一枚熊孩子哈，棒棒哒～老婆孕味十足，母性气息止不住往外侧漏，这几个月来受了不少苦，老婆加油哦！ 没有“的”字写流水账就是爽啊，想到哪，写到哪，不用担心有无文采，完全没有束缚，你看，整篇下来，居然都没有一个“的”字，suprised ?! 这种蠢事我也可以干，蛤蛤。]]></content>
      <categories>
        <category>心旷神怡</category>
      </categories>
      <tags>
        <tag>流水账</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[互联网精英都在看微信最近的几个「小动作」]]></title>
    <url>%2F2016%2F03%2F01%2F%E4%BA%92%E8%81%94%E7%BD%91%E7%B2%BE%E8%8B%B1%E9%83%BD%E5%9C%A8%E7%9C%8B%E5%BE%AE%E4%BF%A1%E6%9C%80%E8%BF%91%E7%9A%84%E5%87%A0%E4%B8%AA%E5%B0%8F%E5%8A%A8%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[最近微信又不动声息地搞了几个「小动作」。 在搜索的「朋友圈」界面上出现了「一年朋友圈回顾」、「一周热门朋友圈」、「朋友分享的音乐」标签，「文章」搜索界面上也露出个「互联网精英都在看」的标签。 「互联网精英都在看」这个入口貌似并不是所有人都会显示，点击之后，页面会显示一系列微信公众平台上和互联网行业相关的原创文章。 去中心化＋流量分发 两手抓？在我看来，「一周热门朋友圈」、「朋友分享的音乐」、「互联网精英都在看」有两个作用： 为公众号内容找到「朋友圈」或者微信群之外的展示入口 主动为用户筛选其社交渠道中的内容展示 按理说，微信公众号的招牌一直是内容分发的「去中心化」，用户和用户的好友一起来决定朋友圈里展示什么内容，而这些新的入口，却等于让系统为用户的社交信息流做了一个二次筛选，让系统而不是用户决定你能看到什么。 现在，微信搞来这几个入口，想必没有如此简单。 这让我联想到前几天微信公众号后台更新的一个功能：增加公众号文章阅读来源的数据统计。根据部分自媒体大V的爆料，即使像他们那样动则几十万粉丝的公众号文章，其中80%的阅读源是公众号会话，而不是传说中的朋友圈。 自从去年8月份后公众号的用户没有再持续地的增长，主要原因大概也是朋友圈传播的能力并没有想象中的那么大。基本上每个公众号写手都是在其擅长的领域内耕作，即使像大部分自媒体苦心经营自己的粉丝微信群，却少了强有力的流量分发机制，也只是一个圈子里的人分享来分享去，朋友圈内容同质化现象严重。「酒香也怕巷子深」啊，公众号除了在朋友圈里被分享出去，继而被潜在读者发现并关注，很难通过其他渠道来找到潜在的读者，这造成了用户获取成本太大。 「80%的阅读源是公众号会话」，解释了为什么单个公众号阅读量下降了，由于读者大部分的阅读行为都通过会话完成，而用户订阅的公众号数量少则几十个，多则几百个，单个公众号能得到的阅读机会相应地也就减少了，用户根本无暇去一篇一篇地阅读每天公众号推送的几十上百篇推文，公众号内容被稀释的越来越厉害了。 也许微信官方意识到了公众平台需要有新的流量分配机制进行「宏观调控」，才推出这几个功能来试探下效果吧。 咋一看，「互联网精英都在看」这样赤裸裸的界面，俨然一个简易版的今日头条，蛤蛤。]]></content>
      <categories>
        <category>WeChat</category>
      </categories>
      <tags>
        <tag>微信</tag>
        <tag>朋友圈</tag>
        <tag>互联网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小李子拿影帝和长者有什么关系？]]></title>
    <url>%2F2016%2F02%2F29%2F%E9%95%BF%E8%80%85%E5%92%8C%E5%B0%8F%E6%9D%8E%E5%AD%90%E6%8B%BF%E5%BD%B1%E5%B8%9D%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[陪跑22年，莱昂纳多·迪卡普里奥终于手捧小金人，粉丝再也不用一到颁奖季就为他操心了，而「奥斯卡欠小李子一个小金人」的梗也成为了过去。 小李获奖后更新的Facebook状态，看得我不禁一脸心酸： 回想当年，大家还记得他2014年的时候，他在twitter上发的是什么吗？只有他能够这样毫无掩饰自己的内心！ 苦尽甘来，终于熬出来奥斯卡影帝，下面是他的获奖感言： Thank you. Thank you all so very much. Thank you to the Academy, thank you to all of you in this room. I have to congratulate the other incredible nominees this year for their unbelievable performances. “The Revenant” was a product of the tireless efforts of an unbelievable cast and crew I got to work alongside. First off, to my brother in this endeavor, Mr. Tom Hardy. Tom, your fierce talent on screen can only be surpassed by your friendship off screen. To Mr. Alejandro Inarritu. As the history of cinema unfolds, you have forged your way into history these past two years. What an unbelievable talent you are. Thank you, to you and Chivo, for creating a transcendent cinematic experience. Thank you to everybody at Fox and New Regency. In particular, Ana Melching, you were the champion of this endeavor, my entire team. I have to thank everyone from the very onset of my career, Mr. Caton Jones, for casting me in my first film. Mr. Scorsese, for teaching me so much about the cinematic art form. To Mr. Rick Yorn, thank you for helping me navigate my way through this industry. And to my parents, none of this would be possible without you. And to my friends, I love you dearly, you know who you are. And lastly I just want to say this: Making “The Revenant” was about man’s relationship to the natural world. A world that we collectively felt in 2015 as the hottest year in recorded history. Our production needed to move to the southern tip of this planet just to be able to find snow. Climate change is real, it is happening right now. It is the most urgent threat facing our entire species, and we need to work collectively together and stop procrastinating. We need to support leaders around the world who do not speak for the big polluters or the big corporations but who speak for all of humanity, for the indigenous people of the world, for the billions and billions of underprivileged people out there who would be most affected by this. For our children’s children, and for those people out there whose voices have been drowned out by the politics of greed. I thank you all for this amazing award tonight. Let us not take this planet for granted. I do not take tonight for granted. Thank you so very much. 注释： first off, 首先，等于first of all, at first navigate one’s way,导航(多用来给船，飞机导航)，此处是为人生导航 in recorded history, 有史记载以来 voices have been drown out, 声音被淹没，被盖过 take sth for granted, 认为XX理所当然 下面请允许我翻译下他的获奖感言： 首先感谢光荣伟大的民主党，感谢美利坚合众国，感谢奥巴马总统，感谢美国电影协会。 他说要特别感谢支持他的中国粉丝，并让记者给中国粉丝带话: 请留下你们的邮箱，《荒野猎人》的种子我会一一发送给大家，好人一生平安，1024！ 小李子顿了顿，继续说到： 我还要郑重地感谢中国那位西方哪个国家都去过的长者，如果没有他，我的那部《泰坦尼克号》就不会一刀未剪地进入中国，你们也不会有机会看到美人的裸体和香艳的船震。感谢那位戴四方眼镜的长者，在他治下的那个稍显开放的时代，当年我这个毛头小子至今还能被那么多中国人记住。 作为R级影片，《荒野猎人》可能不会在我国公映，小李子之前的很多影片都没有公映，《被解放的姜戈》更是上映了一半又被撤下了。 当你被禁止看到他的作品，或者看残缺的作品，还对这个演员抱有如此大的热情和期望，只能说明: 人们的文艺之心不死，对美丽精神世界的向往，是任何墙都阻挡不了的。 说到这时，小李子强忍着眼角快要溢出的泪水，仰头45度看了下舞台上方，好让泪水不致于受重力影响，一泻而出。他哽咽着继续讲到： 我还要感谢奥巴马总统，他曾经教导我们文艺工作者：要创作生产出无愧于我们这个伟大民族、伟大时代的优秀作品。《荒野猎人》就是一部全面展现美国人与天斗、与地斗的革命浪漫主义情怀的作品。它深刻挖掘了我们美利坚民族独有的拼搏、冒险精神，凝结了一代又一代美国人对于「美国梦」的执着追求。 接下来，小李子回顾了他步入影坛二十多年来的演艺经历： 以前我走过不少弯路，《华尔街之狼》展现了资本主义的腐朽与人性的泯灭；《了不起的盖茨比》大肆宣扬消费主义、享乐主义，里面还有大量情色等低俗片段；《无间道风云》更是一部向东方文化低头，毫无原创精神的暴力之作。反思我这几年的创作，都背离了以人民为中心的创作导向。只有贴近人民，才能创作出有道德、有温度的文艺作品。直到今天，我才能无愧于「人民艺术家」这个荣誉。我能获奖，除了注重和人民的血肉联系，主动贴近主旋律之外，就是坚持、坚持、坚持不减肥。 小李子最后提到了最近我国某任性、任姓的房地产、网络大V被有关部门封号的事情，他语重心长地告诫艺人们到： 你们不要怕，我被封杀过、被下架过、被嘲笑过，依然站在了这里，靠的是什么？是作品！如果你知道去哪，世界都会为你让路！加油，我的中国朋友，再次感谢！ 另据小道消息： 《荒野猎人》中国内地正式定档3月18日上映，宣传方还表示小李子确定将来华宣传影片。]]></content>
      <categories>
        <category>电影</category>
      </categories>
      <tags>
        <tag>长者</tag>
        <tag>蛤学</tag>
        <tag>小李子</tag>
        <tag>奥斯卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[男人需要一场婚礼]]></title>
    <url>%2F2016%2F02%2F27%2F%E4%B8%99%E7%94%B3%E6%98%A5%E8%8A%82%E7%BB%93%E5%A9%9A%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[多日不见，别来无恙？ 今天已经是2016年2月27日，正月廿一。给大家拜个晚年了：祝大家猴年大吉，心想事成，工作顺利，万事如意。 公众号自从1月24日最后一次更新以来，断更一个多月，一不小心就堕落成「月经贴」了。一来是因俗事缠身（这个春节，我完成了人生中的最重要的一件大事）；二来也怪我偷懒倦怠荒废了公众号更新进度。 昨晚打开公众号后台，居然发现还新增了十几个粉丝，诸位厚爱至此，令我受宠若惊。感谢你们对我一如既往的的支持与信任，我会继续将这个公众号好好做下去，保持每周两到三篇的博文更新频率，争取早日拿到「原创」标志。 花开二朵，各表一枝。公众号的事咱先按下不表，下面说点重要的事。 ​给大家报个喜：2016年2月18日，农历正月十一，本人与爱妻正式结婚🎎。 有人说： 男孩子，都是在一瞬间长大的。他们不像女孩子一样心理年龄普遍要大过实际年龄；甚至很多男性，三十而立之后，都没有真正的长成一个男人。 和菜头在《情人节前夜写给男生》中也有过类似的一段话： 坦率说，我认为是我国男性和女性并不生活在一个时代。男人天生有一种病，叫做时间不敏感。对于时间的认知，一个男人很可能在十几岁就停止了。不知道具体什么时候，反正就是那么一下子，咔嚓，时间凝固下来。所有的事情都像是在昨天24小时之内发生的，十年、二十年光阴，对于时间不敏感症患者的男生来说，并没有多大差别。所以，经常会发生什么重返母校的活动中，有男生从双杠上摔下来骨折，或者翻栏杆重温旧日时扭伤腰部—因为他内心里觉得自己还是当年那个白衣飘飘的少年郎，根本没有认识到自己已经悄然老去，筋骨僵硬，肚腩前凸。 大多数男人真正地成长起来，都是以同一种方式：结婚。 男人，需要婚礼这种郑重肃穆的仪式感，来让自己接受他已不再是那个能放浪形骸、自由洒脱的家伙了，他现在多了几份责任：丈夫、女婿、爸爸…… 我是从我的婚礼的那一刻后，意识到，仪式感对于人生来说，是多么的重要。我们需要盛大的欢聚，盛大的离别，盛大的狂欢，盛大的礼物，才足以成就人生的丰富。 只有经过这么一场喧闹，才能照见到彼此心中的郑重，不管外面如何喧哗，在那一刻。在夹杂着喧嚣、浮夸、喜泣的热闹里面，你反而最沉静，前所未有的清晰，我们就这样托付给了对方，从此荣辱与共，携手白头。]]></content>
      <categories>
        <category>心旷神怡</category>
      </categories>
      <tags>
        <tag>丙申</tag>
        <tag>婚礼</tag>
        <tag>男人</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dup2 | 考得一首好古]]></title>
    <url>%2F2016%2F02%2F03%2Fdup2-%E8%80%83%E5%BE%97%E4%B8%80%E9%A6%96%E5%A5%BD%E5%8F%A4%2F</url>
    <content type="text"><![CDATA[这两天在看 《Unix 环境高级编程》，学到了不少好姿势，还意外地考了一次古。 dup &amp; dup2关于这两个系统调用，Unix 圣经里已经介绍得很清楚了, man dup可以看用法。 123#include &lt;unistd.h&gt;int dup (int filedes);int dup2(int filedes, int filedes2); 两函数的返回:若成功为新的文件描述符,若出错为-1，返回的新文件描述符与参数 filedes 共享同一个文件表项。 由 dup 返回的新文件描述符一定是当前可用文件描述符中的最小数值。 用 dup2 则可以用 filedes2 参数指定新描述符的数值。如果 filedes2 已经打开,则先将其关闭。如若 filedes 等于 filedes2 ,则返回 filedes2 ,而不关闭它。 有关这部分的知识点我就不啰嗦了，放截图： 这两款调用非常给力，它们经常用来重定向进程的 stdin,stdout. 重定向好似抗战片中，我铁道游击队阻击日本鬼子，将铁轨移到别的路上：或南辕北辙，转向一条错误的道路 fd；或干脆把铁轨坠下深谷 /dev/null。 但是，后来问题来了： 你为了让自己干活方便，把管子移到别处了，你干完活后，总不能留下一地鸡毛就走吧，为了不影响后来人，得把现场恢复。 看了下前辈们的血泪史，偶遇一个11年前的好贴 《使用dup2重定向了标准输出后,使用什么方法恢复对终端的输出??》 解决了心中疑惑。 Demo来来来，搞个 demo 验证下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;;#include &lt;unistd.h&gt;;#include &lt;stdlib.h&gt;;#include &lt;fcntl.h&gt;#include &lt;sys/types.h&gt;;#include &lt;sys/stat.h&gt;;#include &lt;string.h&gt;;#include &lt;strings.h&gt;;#define TESTSTR "Hello dup2\n"int main ()&#123; int fd3; int s_fd; int n_fd; int r_fd; fd3 = open ("testdup2.dat", O_WRONLY | O_CREAT| O_TRUNC, 0666); printf ("after open, fds:%d\n", fd3); if (fd3 &lt; 0) &#123; printf ("open error\n"); exit (-1); &#125; // 复制标准输出描述符 s_fd = dup (STDOUT_FILENO); printf ("after dup, s_fd:%d\n", s_fd); if (s_fd &lt; 0) &#123; printf ("err in dup\n"); exit (-1); &#125; // 重定向标准输出到文件 n_fd = dup2 (fd3, STDOUT_FILENO); // 写入testdup2.dat中 printf ("after dup2, n_fd:%d\n", n_fd); if (n_fd &lt; 0) &#123; printf("err in dup2\n"); exit(-1); &#125; // 写入testdup2.dat中 write (STDOUT_FILENO, TESTSTR, strlen(TESTSTR)); // 恢复标准输出 r_fd = dup2 (s_fd, STDOUT_FILENO); printf ("after restore, r_fd:%d\n", r_fd); if (r_fd &lt; 0) &#123; printf("err in dup2\n"); &#125; // 输出到屏幕上 write (STDOUT_FILENO, TESTSTR, strlen(TESTSTR)); return 0;&#125; 编译，运行： 123456789hxz@pc0170:~/workspace/c++$ gcc -o dup dup.chxz@pc0170:~/workspace/c++$ ./dupafter open, fds:3after dup, s_fd:4after restore, r_fd:1Hello dup2hxz@pc0170:~/workspace/c++$ cat testdup2.datafter dup2, n_fd:1Hello dup2 归纳一下，利用 dup/dup2处理 i/o的大致流程： fd2 = dup(STDOUT_FILENO); //fd2表示stdout fd = open(filename, O_WRONLY|O_CREAT, fd_mode); dup2(fd, STDOUT_FILENO); //把输出重定向到新打开的文件fd //all stdout content will be redirect to fd close(fd); dup2(fd2, STDOUT_FILENO); //恢复stdout 小明在 2016 年了翻出了 2004 的技术帖，今天真是考得一首好古啊～蛤蛤]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>dup</tag>
        <tag>dup2</tag>
        <tag>unix</tag>
        <tag>io</tag>
        <tag>stdin</tag>
        <tag>stdout</tag>
        <tag>铁道游击队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[管道是个好东西]]></title>
    <url>%2F2016%2F02%2F02%2F%E7%AE%A1%E9%81%93%E6%98%AF%E4%B8%AA%E5%A5%BD%E4%B8%9C%E8%A5%BF%2F</url>
    <content type="text"><![CDATA[临近春节假期之际，我司提供给客户用的命令行工具还遭遇一个新需求： 支持管道输入/输出。 需求背景： 原始的视频流体积巨大（一个十分钟视频的原始视频流就占用 2G 多空间），为了节约机器资源，客户希望能将原始的视频流直接通过管道输入，而不必转码生成临时媒体文件。 简而言之，客户希望支持这种调用方式： 1cat some_big_rawvideo | ./my_prog 比如，我们用到的 ffmpeg 和 ffplay 工具也支持通过 - 或 pipe来指定管道输入输出： 123ffmpeg -i input.mp4 -f avi - | ffplay -ffmpeg -i input.mp4 -f avi pipe: | ffplay pipe:ffmpeg -i input.mp4 -f avi pipe:1 | ffplay pipe:0 不幸的是，我们现有的工具并不支持，它只能根据命令行中的文件路径来指定输入输出。 1my_prog -i /path/to/inputfile -o /path/to/outputfile 咋办？改！ 已知首先，小明知道，对于标准的命令行程序，它遵从基本的「一进二出」规范。 123456789 ---&gt; stdout, pipe:1 / / ||======================||stdin, pipe:0 ---&gt; || cmd || ||======================|| \ \ ---&gt; stderr, pipe:2 管道管道是 unix 设计哲学之一，其核心思想就是将前一个命令的标准输出作为后一个命令的标准输入。 比如programo0 | program1 | program2 的输入输出示意图如下： 12345678910111213 stdin stdout stdin stdout stdin stdout || ======================= ====================== /\ || /\ || /\ || || || || || || || || \/ || \/ || \/ ||||==========|| ||==========|| ||==========|||| program0 || || program1 || || program2 || ||==========|| ||==========|| ||==========|| || || || || || || \/ \/ \/ stderr stderr stderr 基于这么一条简单到爆的原则，管道通过 | 把一系列命令连接起来：第一个命令的输出会作为第二个命令的输入通过管道传给第二个命令，第二个命令的输出又会作为第三个命令的输入……，最终结果为管道行中最后一个命令的输出。 举个栗子： 1cat /etc/passwd | grep /bin/bash | wc -l 这条命令使用了两个管道，利用第一个管道将 cat 命令（显示passwd文件的内容）的输出送给grep命令，grep命令找出含有/bin/bash的所有行；第二个管道将grep的输出送给wc命令，wc命令统计出输入中的行数。这个命令的功能在于找出系统中有多少个用户使用bash。 stdin stdout stderr在 unix 世界中，一切皆文件。文件描述符是与打开文件或者数据流相关联的整数，0、1、2 是系统保留的三个文件描述符，分别对应标准输入、标准输出、标准错误。 0: stdin 标准输入串流 (键盘輸入） 1: stdout 标准输出串流 (终端屏幕） 2: stderr 标准错误输出串流 (终端屏幕) 重定向比如： 1my_prog &lt;inputfile &gt;outfile 2&gt;&amp;1 将标准输入重定向到 inputfile（意味着 my_prog不再从标准输入而是从 inputfile 中读取数据），将标准输出和标准错误结果都重定向到 outfile。 如何才能让一个命令行程序支持管道？So，小明上 StackOverflow 上先看看各位同仁怎么说： To be “pipe compatible” your program will need to read from stdin and write to stdout. 原来如此:「为了支持管道，你的程序需要从 stdin读取输入并且将输出写到 stdout」 小试牛刀1234567891011121314151617181920//pipe-std.c#include &lt;stdio.h&gt;int main()&#123; FILE * fi = stdin; FILE * fo = stdout; char buf[1024]; int r_cnt, w_cnt; while ((r_cnt = fread (buf, 1, 1024, fi)) &gt; 0) &#123; w_cnt = fwrite (buf, 1, r_cnt, fo); if (w_cnt != r_cnt) &#123; fprintf (stderr, "some err: %d, %d\n", r_cnt, w_cnt); return -1; &#125; &#125; return 0;&#125; 这个示例非常简单，编译、运行： 123456hxz@pc0170:~/workspace/c++$ gcc -o pipe-std pipe-std.chxz@pc0170:~/workspace/c++$ ls -l ~/test/input/2.mp4-rw-r--r--@ 1 hxz staff 1958612 Nov 27 18:01 /Users/hxz/test/input/2.mp4hxz@pc0170:~/workspace/c++$ cat ~/test/input/2.mp4 | ./pipe-std &gt;copy.mp4 2&gt;errorhxz@pc0170:~/workspace/c++$ ls -l copy.mp4 -rw-r--r-- 1 hxz staff 1958612 Mar 1 14:22 copy.mp4 瞧见了没，这个简单的程序通过管道将输入的内容~/test/input/2.mp4复制到输出copy.mp4。 实践出真知原理搞懂了，接下来就是体力活了。在实际码代码过程中，还是发现了几点管道程序需要注意的地方： 由于是从管道读取输入内容，而管道每获取到片段内容就会发送到下一级程序处理，这意味着我们不能事先获知输入文件的大小了。因此，像 get_file_size之类的方法将不再可用。 管道内容只能顺序读取，不可逆回溯，也不可重复读取同一段内容。所以啊，我们的程序要珍惜每一次读取的机会，不能open了再open，只能open、do_work1、do_work2……close 。具体到 ffmpeg 解码程序就是，avformat_open_input 这个api只能用一次，一次就要把需要的信息全部预加载进来。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>stdin</tag>
        <tag>stdout</tag>
        <tag>ffmpeg</tag>
        <tag>stderr</tag>
        <tag>pipe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[张小龙饭否语录]]></title>
    <url>%2F2016%2F02%2F01%2F%E5%BC%A0%E5%B0%8F%E9%BE%99%E9%A5%AD%E5%90%A6%E8%AF%AD%E5%BD%95%2F</url>
    <content type="text"><![CDATA[饭否因为张小龙重新火了一把，蛤蛤。 人性 中小学每次考试都给同学们排名，这应该让所有人都增强了对比意识和自卑心理吧。2010-12-29 15:33 人生是个被道德调制的过程，却没有人负责解调。2010-12-29 15:49 如果社会进步到没有商人了，生产的人直接赚钱，该是种进步吧。app store所以好。2010-12-29 16:32 让子弹飞激起男人的豪情女人的柔情，是因为，子弹象征着精子。2010-12-29 16:41 所以“让子弹飞”是今年名字取得最好的电影名。2010-12-29 16:43 爱如潮水的科学解释来自于月亮对地球的影响。2010-12-29 17:19 鸟的羽毛是给自己用的，人的羽毛是给别人看的。2010-12-30 15:04 话语在口语口之间传播，形成为可通过传播来生存的有生命的文化。因此，对着树洞说话属于观点自杀行为。每句话，都有它的自私基因，都是希望能更远更长久地生存下去。2010-12-30 15:22 人类做的几乎每一件事情都是错的，却要求机器做的每件事情都是对的。2011-01-02 16:41 古人写诗写词，不超过140字，是因为墨水太贵。今人写微博，纯属偷懒。2011-01-04 19:23 《黑天鹅》里总结得太好了：人有天生的归纳能力来将复杂事物模型化。但这也导致人的认知误区，没有见过黑天鹅就认为天鹅都是白的。2011-01-05 16:43 《黑天鹅》让我知道我是如何被我的经验和直觉所愚弄了。2011-01-06 12:37 没有自由的人，只有被念头所控制的人。2011-01-07 16:09 转：“人们往往出于责任做慈善，但事实是，做慈善有益于自己的身心，有助于自己了解生活。我从难民身上学到了最多东西，比如如何当母亲、做一个坚强的人并生存下去，所以我只是希望能回报一些东西。”–安吉丽娜朱莉 2011-01-09 14:50 人的思维如同膝跳反射，需要外力刺激一下才会反弹。弹得不好就变成踢人了。2011-01-11 02:02 谈产品 和“敌人比我们自己更了解我们”相对应的是，用户比我们自己更了解我们的产品。产品是有人用才成为有灵魂的产品，图纸和代码堆出来的只是躯壳。2010-12-29 16:30 人走茶凉是世间常态，但是在机器的世界里，ID是永恒的。2010-12-29 17:24 很多人争论说自己选择的手机是最好的，别人选择的手机是垃圾。大部分时候，他们争论的不是手机，是捍卫自己的选择是聪明的，怕被别人当作傻逼。但我就承认，我用了10年windows并且当时觉得windows很好，是很傻逼的。2010-12-30 14:27 针无两头利。考核一个技术专家，还要要求他有极好的客户导向，难。2010-12-30 14:41 我不跟人说我正在做的东西比别人好，因为我无法保证中立。但我可以说我做的东西有什么不好，因为我很了解。对祖国也是这样。2010-12-30 15:46 在经过3天的吵架式讨论之后，终于砍掉了一个已经做好的功能。2010-12-30 20:20 中移动有个秘密一直未跟用户说：其实短信是不会丢失或延迟的。移动太了解人性了，每天，有多少人都在用“没有收到短信”或者“才看到短信”作为借口啊！2010-12-30 22:58 当whatsapp，kik，米聊，速聊，kiki都狂推实时聊天概念时，老夫决定反其道而行。2011-01-02 15:18 你问我们和竞争对手比有什么区别，我说我们没有他们那些臃肿艳俗的部分。2011-01-02 15:20 在一个always online的时代，就不需要宣称自己是否是online的了。但always online并不意味着需要立即回应。2011-01-02 15:27 短信的好处在于它是默认隐身的。2011-01-02 15:31 这么多天过去了，米聊竟然才3千个用户。2011-01-03 18:58 FaWave这类工具，汇集了多个产品的数据和功能，看似提高效率，但人毕竟不只是效率工具，汇集类工具脱离了原产品的气息后，就丢失了对产品的情感认同。2011-01-03 19:29 所谓的“N合一”产品，都是单个产品做烂了以后，合起来甩卖。2011-01-03 19:32 表白这么多，是时候搞个表白网了。转@像疯一样 又有人要表白了。刚在学校教学楼公告栏看到的，差不多每个布告栏都贴满了 http://fanfou.com/photo/lyg...2011-01-05 16:51 我们总是高估了用户的智商，低估了用户的情商。2011-01-06 17:48 小众的会做得更动人，大众的会做得更中庸。2011-01-10 12:58 正儿八经竟然上榜了，这事让我明白，蝴蝶效应背后，其实还是有推手存在的。2011-01-10 18:19 评论的意义：一个人如果自顾自写东西会写到离谱，评论相当于自动控制系统的负反馈，让人从偏激中收缩，趋于稳定。最终一个社区的个体互相影响，形成一个稳定的中庸的气场。2011-01-11 18:52 谈科技 当我在嘲笑盛大kiki的时候，其实我比它也好不了多少。2010-12-30 16:58 quora让我感叹的是，人家的知识底子确实必我们厚太多了。2010-12-31 01:36 古人对过去的一年有无数种表达方法，如今是数字时代，统一表达为“2010”。看起来像3进制的。2010-12-31 13:42 if 2010-1/365 then 2010+1 2010-12-31 13:46 企业email越来越成为官僚化的工具。少数的无能的人拼命通过email来混个脸熟。2010-12-31 15:23 现代通讯工具的要义是：我发出消息，你看，或者不看，都与我无关。人们在IM上花费的时间将越来越少。2011-01-01 14:33 方向盘是手的延伸，油门刹车是脚的延伸。汽车并不单是个运输工具，而更像人工肢体。开车和坐车是不同的。对驾驶者来说，汽车是有生命的。2011-01-02 15:16 手机QQ，是当作留言性质用，还是狂聊的多呢？转@bjshadow 移动QQ不就是吗？实时聊天一个很重要的体验就是输入法要好用。转@gzallen 手机上需要实时聊天吗？谁有耐心用手机输入来聊天呢？2011-01-02 15:16 手机是人的最重要的人工器官。2011-01-02 15:33 电脑都能接摄像头看到外部世界了，盲人们还无法接个摄像头将图像接入到视觉神经。可见神经系统很复杂。2011-01-02 15:35 一些手机软件说，将通讯录的电话号码用“不可逆的单向加密上传到服务器，无人可以知晓号码”。问题是，全球手机号是有限的，先生成对应表，遍历一下就逆向破解了。2011-01-03 14:53 围棋是个介于模拟和数字之间的奇怪事物，它自古就有，但又只有0和1两态。2011-01-04 18:56 如果有这样一个网站，号称数据放在月球，服务器放在卫星上，太阳能供电，永久运行，100年没问题。因此，你写的任何记录都会永久保存。不知道会不会很多人去用。2011-01-04 19:31 看到那么多人在macbook里面直接运行windows，我就想，苹果你也有失败的时候啊。2011-01-05 00:49 10年前我跟用windows mobile的朋友争得面红耳赤到底是windows手机好还是塞班手机好。现在我不争了，直接说，你手里的是最好的。2011-01-05 00:52 总结一下，我在app store花钱买的软件基本都没玩过几次。一些免费的倒经常用。有可能是，卖钱的软件都不会有人气。2011-01-05 01:37 用macbook的恶果终于出现了：以前用鼠标，中指基本没用，而macbook的触摸板，全靠中指了。现在中指痛。2011-01-06 14:56 以后的互联网公司的组成是，一个ceo和一堆会写程序的机器人。2011-01-10 15:05 成功是个概率事件，这些传记可以当故事看，但不能当推理看。2011-01-10 18:09 谈饭否 你最需要他们加上什么功能？我来转告。转@琦殿 饭否从回归到现在，功能几乎没有任何改善，我很失望。凭感情做事，做不长久。2010-12-30 14:18 一个最聪明的饭否机器人是：对每一个帖子，都转播一句话，“表现贴。鉴定完毕！” 是基本不会错的。对@大本钟beta 这类机器人就无效了，只有机器人不需要表现什么。2010-12-30 15:07 所谓话痨，就如同一个美女，不停地到镜子前面照一下镜子。只不过，镜子上有个自动相机，把每次镜子的影像都自动发到饭否上了。2010-12-30 15:37 每条消息，都是一个快照，饭否是个相机。2010-12-30 15:46 我的消息是555了，应该给我挂个三五香烟勋章的。2010-12-31 20:19 饭否确实有bug，一些消息，在ta的个人页可以看到，但是timeline没有显示。2011-01-02 17:10 子说，吾日三省吾身于饭否，不亦乐乎。2011-01-05 01:53 什么时候，中国的sns将“饭局”这个应用做火了，一定大快民心。2011-01-06 01:11 每天能够抛离烦琐杂事来饭否刷下，还是很爽的。以后饭否上刷屏应该叫做刷锅。2011-01-10 01:48 谈sns 李开复说：“有网友问我为什么写微博。回答：记录自己的思想和趣事 +正面影响社会和他人。” 我想，唐骏也会这么回答的吧。2011-01-05 01:33 初次进入pengyou.com，同事很多啊，唯一一个加好友的请求，竟然来自pony。这是不是一个要鼓励公司同事都用的策略呢。2011-01-06 00:44 在pengyou.com里决定加入一个行业，叫做“互联网”，必须选择职务，通看一遍，有测试猿但是没有PM这个职务，于是我选择了“嵌入式硬件开发（主板）”。2011-01-06 00:50 pengyou.com让我头晕目眩。看来我是跟不上热闹事物的节奏了。2011-01-06 01:09 怎么看怎么觉得社交这个词很有中国气质。似乎社交是种技能和工具，而不是生活。2011-01-06 01:21 新浪和腾讯微博的社交气氛太浓厚，建议改名为社交微博。2011-01-06 01:23 将来每个人需要两个微博，一个是社交型微博，一个是自我表达型微博。2011-01-06 01:26 刚看到的，“如果这个世界上有什么事比谈论自己更重要的话，那就是能够探究一个陌生人的陌生生活了。”2011-01-06 02:40 微博是个穿衣服的地方，饭否是个脱衣服的地方。2011-01-06 12:44 社交网络，并不是好友越多越好。2011-01-06 13:13 sns上，一下子给我100个好友，怎能给我一个一个去发现和找到好友的乐趣呢。2011-01-06 13:16 很多人学了数据结构以后，思维就变得太结构化了。这就是微博的结构化数据展示的来由。2011-01-07 19:13 社会是所大学，选修表演专业者众。2011-01-07 21:37 我不能孤独地坐在微博身边。这可能是我用微博少了的原因吧。2011-01-09 01:33 认识的人超过一个村子的人，就应该算太多了。2011-01-10 01:42 陌生人组成的社区，虽然冰冷，但是去掉了熟人社区的温情和虚伪，多了规则。2011-01-10 15:30 关系千万重。facebook竟然要将关系一网打尽，它不会有好下场的。2011-01-11 18:19 开复竟然写了本《微博改变一切》的书。我很佩服他竟然能就微博写出那么厚一本书出来。2011-01-11 19:33 微博改变了什么吗？改变了工作？房价？生活？交友？舆论？2011-01-11 19:34 牧羊人把羊群从三只一堆划分成十只一堆，然后说，everything changed。2011-01-11 19:36 央视决定出一本书，《春晚改变一切》2011-01-11 19:40 有一句歌词是这么唱的，“是微博改变了我们，还是我们改变了微博”。2011-01-11 19:45 谈 windows windows的糟糕的字体表现让中国人的UI审美水准滞后了10年。2010-12-30 03:29 在鄙视了windows mobile多年之后，开始为windows phone7叫了一声好。微软这次能在iPhone之外找到了完全不同的另外一种交互模式，还是很牛逼闪闪的！2010-12-30 15:32 抽风 我智商高的时候，情商就低。情商高的时候，智商就低。两个一样高的时候，我就双高了。2010-12-29 01:20 夜间不睡觉，天明徒悲伤 2010-12-29 02:07 “严以律己，宽以待人”这么假的一句话竟然流传至今。所以我的输入法直接显示的组合是，“宽衣待人”。 2010-12-30 17:17 我知道一个真相，就是真相是基本不会知道的。2011-01-03 17:38 为了让我的air能开光，我决定带它去星巴克喝咖啡。2011-01-03 17:57 清醒就是痛苦，一般指晚上睡不着。2011-01-04 02:39 晚上闲到闷头睡，白天睡到自然醒。2011-01-04 02:43 内心强大的检验标准是，是否怕冷。2011-01-04 17:48 乱花确实迷人眼，但谁又不喜欢乱花呢。2011-01-05 02:05 要给农民兄弟们做个网站，让他们聚集在村口的大树下面聊天。2011-01-05 02:25 谈工作 工作邮件，现在基本上只看邮件标题了。2010-12-29 16:07 看来，沉默才能长久啊。转@Xiaochao99 而我已经从里边被移除。。。转@gzallen 有个叫lecterhe的人还每天都出现在微博运营日报邮件的收件人里。2010-12-29 18:38 在提交完年终考核之后，我身心如橘皮。2010-12-30 15:41 下午两件事：处理邮件和谈话。并在这些事情的间隙到饭否发泄情绪。2010-12-30 16:38 去年就是itouch。转@马克叔叔 itouch4 背后激光刻 转@gzallen 每年，我们都会给同事们发一个礼品，并把名字刻在上面。正在想今年能发个什么牛逼哄哄的东西值得刻名字上去的。2010-12-30 16:54 办公室竟然有私欲在飘荡 2010-12-31 15:59 同意。请各部门按此落实执行。转@和菜头 公司里，凡是有老板参加的会议就拼命发言的人，凡是有抄送老板的邮件就拼命回复的人，直接炒掉根本不会影响任何业绩，而且团队的开心度上升了。2010-12-31 17:19 为了让大家有更多时间干活，决定取消今天下午的周会。2011-01-04 15:29 作为PM，怎么能悲伤地坐在开发人员身旁呢。所以从小诅咒有感而歌。2011-01-06 12:24 将whatsapp，kik，miliao打下来，也算是个小小的刺激吧。2011-01-10 01:19 我现在沦落到只能靠折磨programmer为乐了。2011-01-10 01:52 决定买个sim卡来正儿八经地体验下windows phone。2011-01-10 15:21 决定买个红杏牌vpn来正儿八经地体验下出墙。2011-01-10 15:37 决定买个饭岛来正儿八经体验下神马叫爱。转@Xiaochao99 决定买个腾兰来正儿八经体验一下什么叫武。2011-01-10 17:26 明天要开大会了。尝试下用饭否来写ppt。主题是创新。2011-01-11 22:25 1，创新是无稽之谈。创新不是决定取舍的理由。创新一般都是空想。创新是靠不住的，死得很快的。2，要的，是把握用户心理。其结果，才被观察为创新。3，创新是件碰运气的事，你只是蝴蝶，剩下的交给云。ppt over。2011-01-11 22:31 生活 中午剪头发，是个男的洗头，我只能奋力想象，这是机器手臂。2010-12-29 15:32 钟南山说，空气污染对肺的伤害远远超过吸烟了。搞得我都不好意思戒烟了。转@阳光不锈钢 RT @elaoda 中国疾病专家最近表示，中国空气污染与呼吸疾病的联系越来越紧密，广州、北京、上海等许多大城市都面临肺癌率明显上升的趋势，肺癌已经取代肝癌成为中国癌症死亡的第一杀手。2010-12-29 17:09 今天证明了，刷瓶确实是有快感的。2010-12-30 17:01 各位饭友新年快乐了！2011-01-01 00:43 2010，股沟走了，360运动了，群众怒了，微博火了，苹果牛逼了，饭否回来了，巴尔扎克来了，春天快到了，春晚又要上演了。2011-01-01 01:45 你问我去向何方，我指着球场的方向。打球去了。2011-01-01 14:13 你们这些人一到深更半夜就来劲啊。2011-01-02 02:52 睡前饭否？No，会长胖的。看看@和菜头 吧！2011-01-02 02:54 大家，晚安 2011-01-02 03:15 我证明，这是虚构的。转@和菜头 上岛咖啡不行的。。。转@大咸魚 为啥我天天带着没人理。。。 转@和菜头 早不出！！！转 @苑小帅 MacBook Air 果真是装逼神物，今天下午坐咖啡厅4个小时，去掉认识我的，还有4个美女过来搭讪，ipad党赶快投靠MBA吧。 #人人都是装逼犯 2011-01-04 01:27 装，当然要装壁，我没听说过宁住毛坯房也不装修墙壁的。2011-01-04 01:38 从今晚开始，早睡。从明天开始，早起。2011-01-06 01:37 起得太早就会无所事事。2011-01-06 12:40 想起一天中最美好的时刻，就在午夜1点。2011-01-10 01:12 文艺 夜阑卧听风吹雨，铁马冰河入梦来。2010-12-30 03:32 安得大叔千万只，大庇天下腐女俱欢颜。2010-12-30 15:16 一个人在不务正业的时候，干出来的事情往往是最牛逼的。2010-12-30 15:17 理想成为现实的点缀，还是比没有点缀要好点。2010-12-30 15:25 说出来的，如水花跃出水面，稍纵即逝。没有说出来的，还在暗流涌动。2010-12-30 15:38 将树干涂上白漆，是为了显示出庄严感吧。2010-12-31 00:14 在网上看到母校的一张照片，恍惚半天。我怀念的不是母校，只是我住过的宿舍。2010-12-31 00:17 人说女人被物化，我还不信，现在连xiaochao也称她为它了。转@Xiaochao99 2010马上过去了，我很怀念它。2010-12-31 17:26 多年前，我在武昌的体育馆听崔健的现场，是纯粹的荷尔蒙的盛会。现在，是一堆老男人在回味当年的味道吧。转@和菜头 崔健演唱会，大多观众为中年糙汉。 http://fanfou.com/photo/4tN... 2010-12-31 20:13 脑满肠肥的粉丝们已经不再一无所有了，不再问你何时跟我走了。2011-01-02 03:08 年岁越大，朋友也越来越少了。2011-01-06 01:18 抖机灵 人民搜索有A片？转@和菜头 谷歌：搜一下，全知道。百度：搜一下，让你知道的你知道。人民搜索：你搜个毛啊你？！2010-12-29 15:36 不让让人知道有气无力吧。转@泡芙先生 十万个为什么：为什么生日蜡烛要一口气吹灭？2010-12-29 15:35 人类群星闪耀，是牛逼照出来的。2010-12-30 15:33 我说，或者不说，意识都在那里，没有多一份，没有少一份。2010-12-30 15:34 人类群星总能闪耀，说明人类总是在夜间。2010-12-30 15:39 盛大出了一个叫“Kiki”的软件。我只能说，好歹，不要在名字上也这么山寨吧！取个名字有那么难么？2010-12-30 15:53 我以为她说，“你把我倒起来看看”。转@马克叔叔 林志玲对记者说，“我的胸是真的，如果我要是说谎，以后就把名字倒起来念。”看来取名字很重要。–转 2010-12-30 17:02 空山新雨后 人比黄花瘦。一个自动组句的尝试。转@和菜头 自发性直觉写作需要药物，冥想，或者简单一点：随意说废话，直到句子自动组织起来，意象喷涌而出 2011-01-02 02:51 搞IT的人看不到月亮，一个都没有，更别说两个。2011-01-04 02:14 牛逼的bug，都选择在1月1号或者4月1号才发作。2011-01-04 02:48 不管你怎么说互联网的发展如何被我们的国学所包涵，我知道的是，扎克伯格不懂我们的国学。2011-01-04 17:56 我说网民怎么增长这么快。农民们都没地了，或者离开土地了，不上网干嘛？2011-01-04 20:41 一种新型的智能验证码诞生了。转@和菜头 Twitter今天的热词No.1是：tYp3 LyK tHi5。这是英文和数字的混合，意思是：Type like this。原句是：If you tYp3 LyK tHi5 I hope you can read this: k7LL y0 2011-01-09 01:56 天气很冷的时候，说的笑话都成冷笑话了。2011-01-10 01:46]]></content>
      <categories>
        <category>产品狗</category>
      </categories>
      <tags>
        <tag>张小龙</tag>
        <tag>饭否</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《间谍之桥》| 大师手笔，尽管放心]]></title>
    <url>%2F2016%2F01%2F31%2F%E3%80%8A%E9%97%B4%E8%B0%8D%E4%B9%8B%E6%A1%A5%E3%80%8B-%E5%A4%A7%E5%B8%88%E6%89%8B%E7%AC%94%EF%BC%8C%E5%B0%BD%E7%AE%A1%E6%94%BE%E5%BF%83%2F</url>
    <content type="text"><![CDATA[历史背景简介: 1957年，鲁道夫·阿贝尔因涉嫌充当苏联间谍而被逮捕，纽约律师詹姆斯·多诺万被推荐去当他的辩护律师。在多诺万的努力之下，阿贝尔最终被免除死刑，判30年监禁。 1960年，美国空军飞行员加里·鲍里斯因驾驶侦察机在苏联上空拍照被击落俘虏。美苏双方私下达成协议，将在柏林伯尼克桥互换阿贝尔和鲍里斯，但介于局势敏感，多诺万以非官方身份被派往柏林进行交换事宜，而他最终不止救出了一个人…… 这是一个关于「交换俘虏」的故事，斯皮尔伯格以回归古典主义的手法娓娓道来，没有故作煽情，没有各种拍摄的奇技淫巧，有的只是一股慢慢渗透的剧情张力，让你在觉得不温不火的同时却始终按不下停止键。 这是一部工整的片子，如教科书般工整的主旋律电影，一如既往的考究的细节，一如既往的四平八稳的叙事，一如既往的几近完美的调度。斯导还是那个斯导，宝刀未老，人物塑造之成功，柏林危机反映之真实，令人震撼，令人心寒。 给想看这部电影的人一个定心丸：大师手笔，尽管放心。 间谍惊悚与法庭文案的完美结合，斯皮尔伯格又贡献了一部优雅、智慧并具娱乐精神的电影。9分，高分力荐所有人观看，我觉得奥斯卡应该爱它，而不是《荒野猎人》，小李子继续去厕所哭吧～ 宪法 人权汤姆·汉克斯在面对 CIA 猥琐探员朗诵的那段鸡汤箴言听起来老套却依然带感： 你我来自不同的国家，正是我们称之为宪法的东西，使得我们成为「美国人」。 他在最高法院九位大法官前为了捍卫苏联间谍的人权将美式人权鸡汤炖至沸腾： who we are – is that not the greatest weapon we have in this Cold War? 在我看来，片名《间谍之桥》除了交换俘虏的那座大桥，更多地，是在比喻多诺律师。他竭尽自己所能，冒着死亡的危险，去拯救一个敌国的间谍的生命，一个素不相识的CIA飞行员的生命，以及，一个留学生的生命。他凭借一己之力，在险恶的国际政治漩涡之上架起一座保护生命与正义的桥梁！ 友谊多诺敢于忤逆美苏两个大国的意志，只因为他是鲁道夫·阿贝尔的律师。 他也不负律师这个职业，他甚至不在乎阿贝尔是否真是间谍，即使他隐约感觉到阿贝尔真是间谍。从死刑争到30年监禁，判决后上诉至联邦最高法院，在9位大法官慷慨陈词，直到他的家人因为受到公众骚扰才不得不中止。 他们建立起一种微妙的友谊，多诺为了能救出阿贝尔不惜远赴动乱之中的东德于反覆无常的俄国使馆交涉互换俘虏事宜，而阿贝尔也视多诺为知己，看到多诺，阿贝尔才会改变僵硬、凄冷、无助的表情，朝他久违一笑。 他也相信多诺，在伯尼克桥交换俘虏的关键时刻，多诺还在等待西德当局押送的另一名美国公民（一位在东德研究共产主义经济的25岁研究生）。当时，美方人员明确告知他已恢复人生自由，可自行离开步行至桥对头。但阿贝尔此刻没有马上就走，当他发现多诺似乎还在等另一个人时，他说： 我愿意多等一会。 也许，在阿贝尔心中，他和多诺惺惺相惜，多诺甚至比他死死守护的苏联更贴心。接送阿贝尔的苏联人员甚至都没有给他一个拥抱，阿贝尔被苏联人员押送上车，他夹在中间，旁边坐着两个人，可以看出，他是不受苏联待见的，他们怀疑他熬不住煎熬已经泄漏了苏联的国家机密。]]></content>
      <categories>
        <category>电影</category>
      </categories>
      <tags>
        <tag>间谍</tag>
        <tag>冷战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本来天气预报说今天有雨]]></title>
    <url>%2F2016%2F01%2F18%2F%E6%9C%AC%E6%9D%A5%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5%E8%AF%B4%E4%BB%8A%E5%A4%A9%E6%9C%89%E9%9B%A8%2F</url>
    <content type="text"><![CDATA[本来天气预报说今天有雨，江主席一来天清气朗。 今天来聊一聊我国当代著名的气象专家：徐嘉诰老先生。 那是1947年，当时竺可桢老先生因为于子三事件（http://baike.baidu.com/view/251380.htm）和 KMT（原名罗马化：Kuomintang；简称国民党、KMT；英文亦可直译作“Chinese Nationalist Party”）闹翻了，一家老小住在杭州浙大医学院教师公寓的斗室之中，生活困顿。 徐老爷子在一个雪天从上海益民食品厂弄来一车即将过期的蛋糕，解决了燃眉之急。 竺老先生一高兴，就口授了一部《天气晴朗学》，徐老爷得此真传，加上天资聪颖，勤奋专研，刻苦攻读，数十年后，终有所成。 据徐老的夫人回忆，相处几十年，徐老先生一有闲暇，便会抬起头以45度角仰望苍穹，略有所思，他默默地记录下当天天气状况，并总结出规律，逐渐地，徐老磨练出一种对天气情有独钟的感觉。 所谓天人合一、万法自然，除了静观天象，随时记录晴雨表，徐老爷有时候还会和一些生物现象结合起来。 此中最大的贡献就是把生物学和气象学结合起来，根据一位老学者的出行，就能预报天气了。 徐老灵活应用这项研究成果的高光时刻是在2009年，当时，某位德高望重的领导人视察徐老所在的中国联合工程公司。作为他的学弟，徐老一向将这位长者以慈父视之，在座谈会上，徐老意气风发，他向师兄展示了研究多年的气象生物学，一时传为美谈。 《长江论语》有云： 徐公嘉诰曰：「钦天监主簿语余曰，今日有雨。然尊师驾到，则晴空万里。」 徐老爷子的气象生物学的研究成果获得我党领导的高度重视。 此后，气象生物学在国庆阅兵、世博会、APEC会议等多项大型国际赛事、会议上广有建树，或「阅兵蓝」、或「世博蓝」、或「APEC蓝」，保证了沪、京、粤等地顺利举办各项会议的天气条件。]]></content>
      <categories>
        <category>蛤学</category>
      </categories>
      <tags>
        <tag>长者</tag>
        <tag>徐嘉诰</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular CQRS $https request in nw.js]]></title>
    <url>%2F2016%2F01%2F14%2Fangular_cqrs_%24https_request_in_nw%2F</url>
    <content type="text"><![CDATA[This articl records my experience with development on “NW.js + Angular”, implementing https request by $http. pure $httpin nw.js + angualr: host = &quot;192.168.10.69&quot;; $http({ method : &apos;POST&apos;, url : &quot;https://&quot; + host + &apos;/mediawise/auth&apos;, data: &apos;{&quot;protocols&quot;: [&quot;5.2.6&quot;], &quot;user&quot;: &quot;&apos;+ $scope.user.name + &apos;&quot;,&quot;password&quot;:&quot;&apos; + $scope.user.pwd +&apos;&quot;}&apos;, }) .then (function(res) { setLocalStorage(&quot;cur_user&quot;, $scope.user.name); setLocalStorage(&quot;vdnaGenPwd_&quot; + $scope.user.name, $scope.user.pwd); if($scope.remember == true){ $scope.remPwd(); } else { setLocalStorage(&quot;pwd_&quot; + $scope.user.name, null); } $scope.user = {name : &apos;&apos;, pwd : &apos;&apos;}; $scope.remember = false; window.location = &quot;main.html&quot;; }, function(res) { console.log (JSON.stringigy (res.data)); }); in Nginx config: if ($request_method = &apos;OPTIONS&apos;) { add_header &apos;Access-Control-Allow-Origin&apos; &apos;*&apos;; add_header &apos;Access-Control-Allow-Credentials&apos; &apos;true&apos;; add_header &apos;Access-Control-Allow-Methods&apos; &apos;GET, POST, OPTIONS&apos;; add_header &apos;Access-Control-Allow-Headers&apos; &apos;DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&apos;; add_header &apos;Access-Control-Max-Age&apos; 1728000; add_header &apos;Content-Type&apos; &apos;text/plain charset=UTF-8&apos;; add_header &apos;Content-Length&apos; 0; return 204; } if ($request_method = &apos;POST&apos;) { add_header &apos;Access-Control-Allow-Origin&apos; &apos;*&apos;; add_header &apos;Access-Control-Allow-Credentials&apos; &apos;true&apos;; add_header &apos;Access-Control-Allow-Methods&apos; &apos;GET, POST, OPTIONS&apos;; add_header &apos;Access-Control-Allow-Headers&apos; &apos;DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&apos;; } if ($request_method = &apos;GET&apos;) { add_header &apos;Access-Control-Allow-Origin&apos; &apos;*&apos;; add_header &apos;Access-Control-Allow-Credentials&apos; &apos;true&apos;; add_header &apos;Access-Control-Allow-Methods&apos; &apos;GET, POST, OPTIONS&apos;; add_header &apos;Access-Control-Allow-Headers&apos; &apos;DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&apos;; } if you meet this error: Basically you need to use: &quot;chromium-args&quot;: &quot;--allow-running-insecure-content --ignore-certificate-errors&quot;, And it has to go outside of the window object (e.g. after name property) in the package.json file. eg: 123456789101112131415161718192021&#123; "name": "VDNA", "chromium-args": "--enable-file-cookies --allow-running-insecure-content --ignore-certificate-errors", "main": "index.html", "descrption": "client for Ingesting, Query and manage VDNA meta", "version": "0.1.0", "dependencies": &#123; "request": "^2.49.0" &#125;, "window": &#123; "title": "VDNA", "icon": "images/login_bg.png", "toolbar": true, "frame": true, "width": 1180, "height": 820, "position": "center", "min_width": 960, "min_height": 660 &#125; &#125; node request()12345678910111213141516171819202122232425262728function do_request (method, path, data, callback)&#123; var request = require('request'); var options = &#123; url: 'https://192.168.10.111' + path, method: method, rejectUnauthorized: false, //very important headers: &#123; //'Content-Type': 'application/x-www-form-urlencoded', //'Content-Length': data.length, 'Cookie': getLocalStorage ("auth_token") &#125;, &#125;; if (method != 'GET' &amp;&amp; data != null) &#123; options.body = data; &#125; request (options, callback); /* callback = function (error, response, body) &#123; if (!error &amp;&amp; response.statusCode == 200) &#123; ... &#125; &#125; */&#125; or 1234567891011121314151617181920212223242526272829303132333435363738394041424344function do_request2 (method, path, data, callback) &#123; //process.env.NODE_TLS_REJECT_UNAUTHORIZED = "0"; var https = require('https'); var options = &#123; host: '192.168.10.113', port: 443, path: path, method: method, rejectUnauthorized: false, headers: &#123; 'Content-Type': 'application/x-www-form-urlencoded', 'Content-Length': data.length, 'Cookie': getLocalStorage ("auth_token") &#125; &#125;; var req = https.request(options, callback); req.on('error', function(e) &#123; console.error(e); &#125;); req.write(data); req.end(); /* //callback eg: callback = function (res) &#123; var xxx = ""; res.on('data', function (d) &#123; process.stdout.write('RESPONSE:' + d); xxx += d; &#125;); res.on ('end', function () &#123; if (res.statusCode == 200) &#123; //handle received data:xxx &#125; &#125; &#125; */&#125; 参考 https://github.com/nwjs/nw.js/issues/3123#issuecomment-96393512]]></content>
      <categories>
        <category>Front-end</category>
      </categories>
      <tags>
        <tag>Angular</tag>
        <tag>CQRS</tag>
        <tag>nw.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Stay Young Stay Simple | 全球首届蛤丝大会暨张宝华成都见面会]]></title>
    <url>%2F2016%2F01%2F13%2FStay-Young-Stay-Simple-%E5%85%A8%E7%90%83%E9%A6%96%E5%B1%8A%E8%9B%A4%E4%B8%9D%E5%A4%A7%E4%BC%9A%E6%9A%A8%E5%BC%A0%E5%AE%9D%E5%8D%8E%E6%88%90%E9%83%BD%E8%A7%81%E9%9D%A2%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[张宝华，15年前，一个长者怒斥的香港女记者，现在已经是寰亚传媒集团高级副总裁。最近宝华姐第一次来内地参加活动，而且是和年轻人见面。 本来天气预报说今天有雨，结果宝华姐一来天气晴朗。 活动地点定在IFS内一家餐厅。 3点30分，会场的粉丝还不会太多。随着时间推移，粉丝越来越多，大家都开始拿出自己带来学习的书籍。 原定活动开始时间为4点。时间到了4点03分，宝华姐才姗姗来迟，只见宝华姐身着带黑框眼睛的黄色针织衫，出现在众人面前，众粉丝纷纷对在场的传媒记者表示： 将来在报道聚会时间上出现了偏差，你们是要负责的。 不知道这次的主讲座位安排，是否故意模仿16年前的那次采访。 宝华姐拿出了六本她的新书《失眠书店》，会面一开始就来了一次钦定：钦定在场年纪最大的一位长者和年纪图森破的一位少女，以及其他四位粉丝。分别签名并送出新书《失眠书店》。 当然了，在场要求宝华姐签名的还有其他书籍，宝华姐欣然接受。 宝华姐坦言: 16年过去了，她今天作为一名长者，要告诉我们一点人生经验。她绝对不知道她一个香港记者怎么到现在还被我们记得。 她说“长者”的威力真的很大。 当然还是需要介绍一点主办方，主办方以“你们继续，就不打扰你们交流了。”把话筒转给宝华。粉丝热情继续高涨： 你也实在不是谦虚，中央已经决定了，你来继续讲。 宝华姐说很多微博上面的朋友会私信她一些问题，例如问学业啦，爱情啦，有时候她也不懂怎么回答。只能说加油继续追，并且希望大家 stay young stay simple。 她说父母都是上海人，她全家都是很年轻的样子。她也不知道，她怎么就在香港出生了。粉丝问道: 你作为一个上海人怎么被选到香港去了？ 另一位粉丝回答： 中央已经决定了。 宝华笑谈: 他们的决定权也很重要。 宝华姐说除了学习提高姿势水平，运动也很重要。要跑得比谁都快，希望大家多跑步。粉丝当中有一个人问到底她跑得有多快。她也通过一些国内的学生知道了黄薄码，知道了之前的蛤三篇，知道了有人统计过她跑得到底有多快。有粉丝说，就不要跑步了，我们到重庆比赛爬山比赛拔河啊。 宝华姐随后问在场是否有外地来朋友，许多昆明南京来的朋友热情回应。继续问到在坐各位有哪些学校的，其中南京大学，和上海交大的同学引来粉丝热情欢呼。川大新闻系也是很大的。并且其中有人是学微电子的。 宝华姐也鼓励年轻人多恋爱，鼓励大家早恋。粉丝提问“是彭定康说的吗？”宝华姐回答“他没这么说，但他直接这么做的。”并且说希望大家多给她私信，她会尽量解决粉丝的问题。 通过宝华13年的脸书我们发现，宝华也是中学时候早恋的。她喜欢高高瘦瘦文采风流的男生，不知道是否这样的男生在微博上留言，她回复点赞概率更高？ 这时候现场粉丝提问了“16年前面对长者的心态是什么？” 宝华姐回答“当时年轻，只是尽到自己的责任，没有想太多。但是没想到现在还有这么多粉丝记得她。” 在场年纪最大的长者继续追问“如果继续做记者，那有没有勇气向当今领导人这样提问？” “我现在真的没有跑新闻了，如果继续跑新闻我也会尽责。而这个不是勇气，是责任。” 国内传媒人也对宝华有了提问，不过这位传媒人被硬点坐在了宝华姐的位置上。 “国内媒体成就感低，很多没法报道。你当初为什么选择媒体？” “有些事情是改变不了的，做自己能够做的，对未来要有希望。自己内心要强大，每个人的成长都会遇到这种事。例如我本来也不运动，可是后来也开始了跑步。不要灰心，每个人成长都会遇到这种事。”随后也对另一位传媒人表示，每个行业都有自己的困难和压力，应该找到自己的空间。 “那你会参选港姐吗？” “很惭愧，超龄了。” 当然有暴力的粉丝问宝华姐是否吃过蛤蟆？ 宝华姐坦言回答“没吃过，我是吃素的。而且吃素可能更容易保持年轻，stay young。”笔者提醒想要保养的女粉丝记得多吃素。并表达她信奉佛教，明天会去大慈寺和看熊猫。 也有粉丝问到每天被骚扰你会觉得困扰了？宝华姐回答其实是很荣幸的别人都没有，这是很特别的一件事。并希望大家不要提16年前的事情，因为这样大家会知道她年龄。如果她嫁出去无所谓，如果没嫁出，粉丝要负责的。 最后宝华姐总结了这次演讲的三句话： 多跑步，多拍拖，stay young stay simple。并祝愿粉丝姿势水平越来越高，相约天气暖和时候在成都和大家一起跑步。 北京时间17点04分，在场粉丝领唱《毕业歌》送给宝华姐，活动圆满结束。在场的粉丝今后都可以怒斥他人一个: 香港的张宝华，比你们不知道高到哪里去了，我和她谈笑风生。 总结：宝华姐亲自来到成都和蛤丝见面，现场蛤意盎然，蛤友们神魂颠倒，坐卧难安，大家都很 excited！ 很惭愧，就做了一次不完整的会议记录这么点微小的工作，谢谢大家。]]></content>
      <categories>
        <category>蛤学</category>
      </categories>
      <tags>
        <tag>长者</tag>
        <tag>张宝华</tag>
        <tag>蛤学</tag>
        <tag>成都</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[香港记者到底跑的有多快？]]></title>
    <url>%2F2016%2F01%2F11%2F%E9%A6%99%E6%B8%AF%E8%AE%B0%E8%80%85%E5%88%B0%E5%BA%95%E8%B7%91%E7%9A%84%E6%9C%89%E5%A4%9A%E5%BF%AB%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[今天把蛤三篇的最后一篇「香港记者到底跑的有多快」扯完。（前两篇分别是「到底哪个西方国家他没去过」、「美国的华莱士到底有多高」） 许多年后，张宝华依旧会想起14年前她向长者提问的那个下午，那时已经是长者第四次打断她了： 窝很捉急啊，增的，不过你们有一个好，全世界跑到什么地方比其他西方记者还快。 当时长者钦点的「跑的比西方记者快」的香港女记者张宝华是香港中文大学95级新闻与传播专业毕业的，今年9月号《中大校友》封面专题是「跑出中大精神」，其中介绍她用的是《跑是小挑战》，她在文中说她从小体育就不行，在中大就读时就差点因为体育差不能毕业。应该直到那次采访长者对她进行激励后，她才开始爱上了跑步，她说“我现在每周可以跑上三小时，每次最少都能跑一小时”。 女记者没有撒谎，笔者翻阅了其2014年1月至今一年的微博发现，和所有的健身（哗~）一样，女记者每次跑步都会晒出自己的成绩。不完全统计在今年，她共计跑步30次，里程共计175.56km，差不多正好是上海到杭州的距离。共花费时间28.75h，速度约为6km/h。 虽然女记者跑的不快，但敏锐的西方公司发现了其价值，阿迪达斯公司在今年「i am a runner」这个主题宣传中，机智地将她列入其中。“穿上阿迪跑的比西方记者都快”的隐喻昭然若揭。 越是孤独的运动，越需要有人和你一起跑的感觉。这个一起不一定是要在身边，但要在同一个时空里。于是，今年2月，在香港，女记者报名参加了渣马，她参加的是10km组，成绩是81分34秒。 在北京，经过一个月环玉泉山的夜跑准备后，长者也「隔空约跑」报名参加了今年的上海马拉松，在赛后组委会发布的名单里我们可以看到，长者在全部6262名参赛男选手中以3小时11分跑完全程的成绩高居242位，陪跑的老搭档月月鸟排在301位，比排在425位的那位不知道高到哪里去了（如下图） 从前慢，车、马、女记者都慢，她6km/h的速度只能算是小步快跑，但她和长者都明白现在能做的事就只是长途跋涉的归真返璞 ，去找回: 以小步紧跑去迎接一个人的那种快乐]]></content>
      <categories>
        <category>蛤学</category>
      </categories>
      <tags>
        <tag>张宝华</tag>
        <tag>蛤学</tag>
        <tag>蛤三篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[美国的华莱士到底有多高？]]></title>
    <url>%2F2016%2F01%2F10%2F%E7%BE%8E%E5%9B%BD%E7%9A%84%E5%8D%8E%E8%8E%B1%E5%A3%AB%E5%88%B0%E5%BA%95%E6%9C%89%E5%A4%9A%E9%AB%98%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[跟昨天那篇「到底哪个西方国家他没去过」一样，本文继续来讨论下那段讲话中的另一句金句： 你们要知道，美国的那个华莱士比你们不知道高到哪里去了，我跟他谈笑风生。。 华莱士到底有多高呢，我们试图以长者的身高来推出他的身高来。 先来看一张长者和华莱士的合影。 这张是“CBS60分钟”里的截图 由于是采访前的对话，双方着装很正式，所以不存在一方人字拖一方皮鞋造成的身高误差。从图里看出华莱士明显比长者高出半个头，但从腰带看长者的腿却比华莱士的长不少，可见按这腿的比例来算长者应该是十头身的魔鬼身材。 首先来确定下长者身高，在身高问题领域，领导人的大多是秘密，而由于职业原因运动员的身高数据是相对最透明的，于是我们来看下长者和姚明的合影，图中还有老布什。而且三人合影推身高必将比两人推更准确。 稍有常识的人都知道姚明的身高是226CM，现在来确定老布什，根据姚明跟同样是体育明星的刘翔合影看出老布什与刘翔同样顶到姚明的肩膀，所以老布什也约莫是188CM。 再看那张三人合影，长者头顶与老布什鼻头相平，而鼻头到头顶一般13-14CM，所以长者在76岁时的身高是174CM左右，所以华莱士的身高比长者高半个头为185CM左右。 于是第一个问题华莱士的身高问题解决了，现在来继续研究下长者说的「比你们高到哪里去了」中「哪里去了」究竟是多大的一个度量衡。 我们先找到长者「你们」中的这位女记者，她叫张洺华，14年前是香港无线的记者，现在微博认证为「香港传媒人，寰亚传媒集团高级副总裁」，她这十四年来的心路历程以后单独开篇详述。确定她的身高也简单，其相册里有一张她与张家辉的合影（中间）。 从微博内容及图片里来看她是在跟张家辉一起参加阿迪的活动，一身运动装扮也避免了高跟鞋等装扮带来的计算误差。张家辉在百度百科里的身高是172，按照标准中国男人的身高虚报法，其真实身高应该是170CM，女记者的头顶约莫位于张的眼部，眼部到头顶距离一般10CM+，这样女记者的身高应该就是160CM上下。 所以答案很快就出来了，「美国的华莱士有多高？」「185CM」、「比你们高到哪里去了？」「25CM」，蛤蛤~]]></content>
      <categories>
        <category>蛤学</category>
      </categories>
      <tags>
        <tag>长者</tag>
        <tag>蛤学</tag>
        <tag>蛤三篇</tag>
        <tag>华莱士</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[到底哪个西方国家他没去过?]]></title>
    <url>%2F2016%2F01%2F08%2F%E5%88%B0%E5%BA%95%E5%93%AA%E4%B8%AA%E8%A5%BF%E6%96%B9%E5%9B%BD%E5%AE%B6%E4%BB%96%E6%B2%A1%E5%8E%BB%E8%BF%87%2F</url>
    <content type="text"><![CDATA[1989 年到 2002 年，是中国国际地位飞速上升的关键年份。苏联解体、东欧剧变、冷战“终结”、中美摩擦，国际形势风云诡谲。 而我们敬爱的长者运筹帷幄、决胜千里，熟谙游戏规则。他的一次又一次出访，足迹遍布五洲，和绝大部分西方国家。是他，让世界认识中国，让中国走向世界。 也许在多年以后，当中国小孩在异国对着中文菜单点餐后用标准普通话对外国服务员说一声“谢谢”然后尽情享受他乡明媚的阳光时，他一定不知道，有一位老人、有一代前辈，为了这一刻苦苦追求、舍身奉献。 历史不会忘记，人民不会忘记。向老人致谢，向前辈致意！ 西方哪一个国家我没去过？在 15 年前，长者那个众所周知的著名演讲里，有一传诵至今的金句： 我告诉你们，我是身经百战，见得多了，西方哪一个国家我没去过？ 长者说的不错，他出访过 70 多个国家，执政 13 年里行程约 60 万公里，在空中和外国土地上的时间总共 364 天，今天我们试图来厘清到底哪个「西方国家」长者没有去过。 我们依据的是由外交部各大地区司和国际司编撰的《长者出访纪实》一书，因长者发表讲话在 2000 年，所以我们收集数据为敏感词年(懂否？)到 2000 年长者出访的国家，执政前长者去过苏联和法国，后来也都去过，重复不计算。 这样按照先后顺序，排除亚非拉及俄罗斯之外，长者先后去过日本、美国、乌克兰、法国、芬兰、匈牙利、德国、西班牙、挪威、罗马尼亚、加拿大、意大利、瑞士、奥地利、澳大利亚、新西兰、英国、葡萄牙、摩洛哥、土耳其、希腊。 而麻烦的是如何定义「西方国家」，西方这个词在文化、地理及政治上外延均不同，按照惯用的「以美国为首的西方国家」语境，这里还是采取政治上的定义，而样本用北约国家阵营加日本、澳大利亚、新西兰。而为了切合长者演讲时间，北约阵营国家沿用 99 年扩张之前版本。 这样「西方国家」就为：美国、加拿大、比利时、法国、卢森堡、荷兰、英国、丹麦、挪威、冰岛、葡萄牙、意大利、希腊、土耳其、德国、西班牙。 交叉对比上面两副名单可以看出，2000年长者还有 比利时、荷兰、卢森堡、丹麦和冰岛五个「西方国家」没有去过，而02年长者情暖冰岛，但由于时间不对无法算在范围内。 由此可见，当年长者怒斥记者时是有底气的，即使算上日澳新，长者也确实把西方主要大国都去了一遍，有的国家还去了又去，但美中不足，目前仍有四个国家没有去。 长者出行清单根据传记新闻报道整理。 担任国家领导人之前 1955 年苏联身份:斯大林汽车厂实习生。 留苏期间和苏联姑娘的合影 1971 年罗马尼亚身份:中国援罗考察组总组长 1980 年新加坡、斯里兰卡、美欧地区等12个国家身份:国家进出口管理委员会、国家外国投资管理委员会副主任。 1980年10月29日至31日，率代表团参观自贸区。 1983 年美国身份:中央委员会委员、电子工业部部长。 1983年6月，旧金山，“恭祝泽民先生荣任部长”。长者当时得知自己升任电子工业部部长，友人Chining Liu为其庆祝。 担任国家领导人之后 1990 年 3月 首访朝鲜。 1990年3月14日至16日，长者对朝鲜进行友好访问。在平壤金日成广场，江泽民接受“朝中友谊雕像”。 1990年3月15日，长者在金日成陪同下观看歌剧《卖花姑娘》 1991 年 5月 苏联。 1991年5月15日至19日，长者访问苏联。江泽民和戈尔巴乔夫在克里姆林宫出席中苏东段边界协定签署仪式。 1992年 4月 日本 首访日本 1993年 11月 美国 西雅图峰会 1993年 11月 古巴 1993年 11月 巴西 1994年 9月 俄罗斯 1994年 9月 乌克兰 1994年 9月 法国 首访法国 1994年 11月 新加坡 1994年 11月 马来西亚 1994年11月印度尼西亚亚太经合组织贸易会议 1994年 11月 越南 1995年5月俄罗斯世界反法西斯战争胜利50周年庆典 1995年 7月 芬兰 1995年 7月 匈牙利 1995年 7月 德国 1995年 10月 美国 1995年 11月 韩国 1995年11月日本亚太经合组织大阪会议 1996年 5月 肯尼亚 1996年 5月 埃塞俄比亚 1996年 5月 埃及 1996年 5月 马里 1996年 5月 纳米比亚 1996年 5月 津巴布韦 1996年 6月 西班牙 1996年 6月 挪威 1996年 6月/7月 罗马尼亚 1996年 7月 乌兹别克斯坦 1996年 7月 吉尔吉斯斯坦 1996年 7月 哈萨克斯坦 1996年11月菲律宾亚太经合组织苏比克湾会议 1996年 11月 印度 1996年 12月 巴基斯坦 1996年 12月 尼泊尔 1997年 4月 俄罗斯 1997年6月30日“香港”（未回归） 迎接香港回归 1997年 10月 美国 1997访美，檀香山弹奏夏威夷吉他。 1997年11月加拿大亚太经合组织温哥华会议 1997年 11月/12月 墨西哥 1997年12月马来西亚东盟与中国(10+1)领导人会议 1998年 7月 哈萨克斯坦 1998年11月马来西亚亚太经合组织吉隆坡会议 1998年 11月 俄罗斯 1998年 11月 日本 1999年 3月 意大利 1999年 3月 瑞士 1999年 3月 奥地利 1999年 7月 蒙古 1999年 8月 吉尔吉斯斯坦 1999年 9月 泰国 1999年 9月 澳大利亚 1999年9月新西兰亚太经合组织奥克兰会议 1999年 10月 英国 1999年 10月 法国 与法国前总统雅克·希拉克的夫人贝尔纳黛特·希拉克（Bernadette Chirac）共舞华尔兹。 1997年11月加拿大亚太经合组织温哥华会议 1997年 11月/12月 墨西哥 1997年12月马来西亚东盟与中国(10+1)领导人会议 1998年 7月 哈萨克斯坦 1998年11月马来西亚亚太经合组织吉隆坡会议 1998年 11月 俄罗斯 1998年 11月 日本 1999年 3月 意大利 1999年 3月 瑞士 1999年 3月 奥地利 1999年 7月 蒙古 1999年 8月 吉尔吉斯斯坦 1999年 9月 泰国 1999年 9月 澳大利亚 1999年9月新西兰亚太经合组织奥克兰会议 1999年 10月 英国 1999年 10月 法国 1999年 10月 葡萄牙 1999年 10月 摩洛哥 1999年 10月 阿尔及利亚 1999年 10月/11月 沙特阿拉伯 1999年12月19日“澳门”（未回归） 迎接澳门回归 2000年 4月 以色列 2000年 4月 巴勒斯坦 2000年 4月 埃及 2000年 4月 土耳其 2000年 4月 希腊 2000年 4月 南非 2000年7月塔吉克斯坦第五次“上海五国”元首会晤 长者与普京双方首次以国家元首身份会晤，很高兴遇见你。 2000年 7月 土库曼斯坦 获赠土库曼斯坦的“汗血宝马”阿哈尔捷金马。 2000年 9月 美国 联合国千年首脑会议 2000年10月，北京，怒斥张宝华。 2000年 11月 老挝 2000年 11月 柬埔寨 2000年11月文莱亚太经合组织斯里巴加湾会议 2001年 4月 智利 2001年，圣地亚哥，在联合国拉丁美洲和加勒比经济委员会上使用西班牙语发表演讲 2001年 4月 阿根廷 2001年 4月 乌拉圭 2001年 4月 巴西 2001年 4月 古巴 向卡斯特罗赠诗，全文如下: 朝辞华夏彩云间，万里南美十日还。隔岸风声狂带雨，青松傲骨定如山。 辛巳春日重访古巴次韵唐朝诗人李白朝发白帝城书赠卡斯特罗同志江泽民二〇〇一年 四月十二日 于哈瓦那 2001年 4月 委内瑞拉 2001年 7月 俄罗斯 2001年7月16日，江泽民和普京在莫斯科签署了《中俄睦邻友好合作条约》,拥抱一下。 2001年 7月 白俄罗斯 2001年 7月 摩尔多瓦 2001年 7月 乌克兰 2001年 7月 马耳他 2001年 9月 朝鲜 2001年 12月 缅甸 2002年 2月 越南 2002年 4月 德国 2002年 4月 利比亚 2002年 4月 尼日利亚 2002年 4月 突尼斯 2002年 4月 伊朗 2002年6月哈萨克斯坦“亚洲相互协作与信任措施会议”领导人会晤 2002年6月俄罗斯上海合作组织圣彼得堡峰会 2002年6月6日，圣彼得堡，中俄双边会晤,喜悦之情溢于言表。 2002年 6月 拉脱维亚 2002年 6月 爱沙尼亚 2002年 6月 冰岛 2002年 6月 立陶宛 2002年 10月 美国 2002年10月墨西哥出席亚太经合组织洛斯卡沃斯会议 弹指十余年 2014年5月20日，上海，亚信峰会。 弹指十余年，老友再相见。此时长者已荣休，普京依然执掌毛子国权柄。 面对着这位克格勃的年轻人，他会回忆起自己的青春。 在普京三岁那一年一个冬夜，寒风凛冽。他放下手中书卷，凝望窗外飞雪。在异国异乡的苦愁、报效祖国的豪情、对真理的追求，全都化作音符，莫斯科郊外的晚上，琴声悠扬。 去年秋天大阅兵，我们又都看到了长者虽年近 90 依然「精神矍铄」的一幕，我们广大民饭看了无比振奋，长者从02年到14年，12年都没出访过了，这里真诚希望长者能打破退休领导人不得出访的禁忌，出访完比利时、荷兰、卢森堡、丹麦这最后四个「西方国家」，相信长者能施展独有的个人魅力外交手段，谈笑风生，长袖善舞，继续弘扬我天朝上国蒸蒸日上的外交态势。]]></content>
      <categories>
        <category>蛤学</category>
      </categories>
      <tags>
        <tag>长者</tag>
        <tag>蛤学</tag>
        <tag>蛤三篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ffmpeg 使用指南]]></title>
    <url>%2F2016%2F01%2F07%2Fffmpeg-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[本文档翻译自:https://ffmpeg.org/ffmpeg.html 中间加入了部分笔者的个人理解。有翻译生硬之处，难登“信、达、雅”之境界。望读者不吝指正。 语法1ffmpeg [global_options] &#123;[input_file_options] -i input_file&#125; ... &#123;[output_file_options] output_file&#125; ... 概述ffmpeg 是一个快速的音视频转换工具，它能在任意的采样率和视频大小之间转换并且获得高质量多态的过滤。 ffmpeg 根据 -i 选项读取任意数量的输入文件（普通文件、管道流、网络流、可抓取设备等等），将转换结果写入到指定的多个输出 文件。命令行参数中不能被解析为选项的所有参数都被视为一个输出文件名。 理论上讲，每个输入或输出文件都可以包含任意数量的多媒体流（视频、音频、字幕、附件及额外信息），但实际允许的多媒体流数量可能受限于转换格式。 通过 map 选项（参考流筛选章节）可自动地从某个输入文件的某个多媒体流映射到某个输出文件。 为了指定输入文件，你必须遵从从 0 开始的索引规律，第一个输入文件的索引为 0，第二个输入文件的索引为 1，以此类推。类似的，文件内的多媒体流也是从 0 开始计数，比如 2:3 指第三个输入文件的第四个多媒体流。 一般来说，参数选项都将应用于下一个文件。因此，命令行参数都顺序非常重要，你可以在命令行中多次使用同一个参数，将它用于不同的文件，每个参数都会应用于下一个输入或输出文件。除非是全局选项，它们必须在命令行中的最前面。 切勿混合使用输入和输出文件：首先指定输入文件选项，然后再指定输出文件选项。同样地，不要在不同文件间混合使用参数，所有的选项都只会应用于紧挨着它都下一个输入或输出文件。 将输出文件的比特率置为 64 kbit/s: 1ffmpeg -i input.avi -b:v 64k -bufsize 64k output.avi 强制输出文件的帧率为 24 fps: 1ffmpeg -i input.avi -r 24 output.avi 强制输入文件（仅限于原始格式）的帧率为 1 fps，输出文件的帧率为 24 fps: 1ffmpeg -r 1 -i input.m2v -r 24 output.avi 详细说明ffmpeg 的转码过程可以用如下图表示： 12345678910111213141516 _______ ______________| | | || input | demuxer | encoded data | decoder| file | ---------&gt; | packets | -----+|_______| |______________| | v _________ | | | decoded | | frames | |_________| ________ ______________ || | | | || output | &lt;-------- | encoded data | &lt;----+| file | muxer | packets | encoder|________| |______________| ffmpeg 调用 libavformat库来读取输入文件，从中获得压缩数据包，如果输入文件为多个，ffmpeg 尝试在每一个有效的输入流中将它们同步并记录最小时间戳。 然后，压缩数据包传递给相应的流解码器，输出原始的未压缩的数据流（原始视频或者 pcm 音频……），这些数据流经过过滤后传递给相应的编码器，对其进行编码、压缩，最后将压缩数据包写入到输出文件。 过滤Before encoding, ffmpeg can process raw audio and video frames using filters from the libavfilter library. Several chained filters form a filter graph. ffmpeg distinguishes between two types of filtergraphs: simple and complex. 在编码之前，ffmpeg 能通过 libavfilter库对原始音视频流进行过滤，多个过滤器构成了一幅过滤图，ffmpeg识别简单和复杂的两种过滤图。 简单过滤只有一种类型的输入和输出，如上图中，可在解码和编码之间插入一个简单过滤： 12345678910 _________ ______________| | | || decoded | | encoded data || frames |\ _ | packets ||_________| \ /||______________| \ __________ / simple _\|| | / encoder filtergraph | filtered |/ | frames | |__________| 简单过滤根据每一个流的过滤选项（-vf 和 -af）来配置，一个简单的视频过滤示例如下： 1234 _______ _____________ _______ ________| | | | | | | || input | ---&gt; | deinterlace | ---&gt; | scale | ---&gt; | output ||_______| |_____________| |_______| |________| 复杂过滤当输入或输出为多个，或者输入和输出文件的媒体流类型不同时，不能对流进行简单地进行线性过程处理，这个过程如下图： 12345678910111213141516 _________| || input 0 |\ __________|_________| \ | | \ _________ /| output 0 | \ | | / |__________| _________ \| complex | /| | | |/| input 1 |----&gt;| filter |\|_________| | | \ __________ /| graph | \ | | / | | \| output 1 | _________ / |_________| |__________|| | /| input 2 |/|_________| 通过 -filter_complex 全局选项指定，-lavfi 等同于 -filter_complex. 流拷贝流拷贝是提供给 -codec 选项的一种流筛选模式，它让 ffmpeg 跳过解码和编码步骤，因此它只有解复用步骤。流拷贝对于修改容器格式或容器级别的元数据是很实用的。 12345 _______ ______________ ________| | | | | || input | demuxer | encoded data | muxer | output || file | ---------&gt; | packets | -------&gt; | file ||_______| |______________| |________| 少了解码和编码步骤，拷贝过程是很快并且无损的。但是，受多种因素影响，在某些情况下它可能无法应用。流过滤因此也显然不可用，因为过滤必须工作于未压缩的原始数据上。 流筛选ffmpeg 默认只从输入文件中选择一个同种流媒体类型（音频、视频、字幕等），将它们包装到输出文件中。基于如下标准，它挑选出最 好 的那个流： 对于视频，它是最高分辨率的那个流； 对于音频，它是通道数最大的那个流； 对于字幕，它是第一个字幕流。 如果有多个同类型流都符合标准，那么选择索引最小的那个流。 你可以通过 -vn/-an/-sn 等选项移除默认筛选的这些流，若要人工控制选择哪些流，可用 -map选项。 参数选项所有数值选项，如果没有另外的规定，表示接受数字作为输入，其可以随后 SI单位 前缀之一的字符串，例如：K，M，或G。 如果i被附加在SI单位前缀，则完整的前缀将被解释为一个以 1024 （而非 1000 ）为基数的二进制倍数的单元前缀，将 B 附加到SI单位后缀将乘以 8。这允许使用，例如：“KB”，“MIB”，“G”和“B”为数字后缀。 选项不带参数的布尔选项，并设置相应的值设置为 true, 它们可以通过与no的前缀选项名称设置为 false。例如使用-nofoo将设置名称为foo为flalse的布尔选项。 流选择器有些选项适用于每个媒体流，比如 bitrat 和 codec。流选择器用于精确指定给定的选项适用于哪个流。 一个流选择器是一个字符串，它被追加到一个选项中并且用 :分隔，比如 -codec:a:1 ac3 包含流 a:1, 它匹配第二个音频流，因此，这个流选择器将在第二个音频流上采用 ac3编码器。 一个流选择器可以匹配多个流，因此选项将默认用于所有的流。比如 -b:a 128k将所有的音频流的比特率置为 128k。 一个空的流选择器匹配所有流，比如 -codec copy 或 -codec:copy 将拷贝所有的流。 流选择器的形式有： stream_index匹配中这个索引指代的流，比如，-threads:1 4将会把第二个流的线程数设置为 4. stream_type[:stream_index]stream_type可以是：v or V for video, afor audio, sfor subtitle, dfor data, and tfor attachments。v 匹配所有的视频流，V之匹配没有附加图片、视频缩略图或者封面的视频流。如果指定了stream_index，那么它指定该stream_index 索引对应的那个流，否则，它匹配该类型的所有流。 p:program_id[:stream_index]If stream_index is given, then it matches the stream with number stream_index in the program with the id program_id. Otherwise, it matches all streams in the program. stream_id or i:stream_idMatch the stream by stream id (e.g. PID in MPEG-TS container). m:key[:value]Matches streams with the metadata tag key having the specified value. If value is not given, matches streams that contain the given tag with any value. uMatches streams with usable configuration, the codec must be defined and the essential information such as video dimension or audio sample rate must be present.Note that in ffmpeg, matching by metadata will only work properly for input files. 时间戳格式1[-][HH:]MM:SS[.m...] 或者 1[-]S[.m...] 示例：55,12:03:45,23.189, 适用于 -t,-ss,-sseof,-t等选项。 常用选项 -f fmt (input/output) 强制输入/输出的媒体格式。一般情况下，ffmpeg 会自动从输入文件中识别出媒体格式，并且从输出文件名后缀猜测出输出格式，因此，大多数情况下，不需要此选项。 -y (global) 不提示，覆盖同名的输出文件。 -n (global) 不准覆盖输出文件，如果存在同名文件，则立即退出程序。 -c[:stream_specifier] codec (input/output,per-stream) -codec[:stream_specifier] codec (input/output,per-stream) ffmpeg -i INPUT -map 0 -c:v libx264 -c:a copy OUTPUT 将所有视频流以 libx264 编码并且拷贝所有的音频流。 对每个流，起作用的是最后一个-c选项。 ffmpeg -i INPUT -map 0 -c copy -c:v:1 libx264 -c:a:137 libvorbis OUTPUT 将拷贝所有的流，除了第二个视频流以 libx264 编码，第 138 个音频流以 libvorbis 编码。 -t duration (input/output) 当用于输入选项（-i 之前），限制从输入文件中最多读取的时长。 当用于输出选项（output_file 之前），当写入时长超过该时长时，将停止写入。 -to和-t不允许同时存在，-t优先。 -to position (output) 指定在何时停止写入，必须以 ffmpeg 允许的时间格式表示。 -ss position (input/output) 当用于输入选项时，定位到该文件的这个位置开始解码。 当用于输出选项时，解码当前位置前面的媒体但是忽略这些输入直到读取到该时间戳。 -sseof position (input/output) 和 -ss类似，但是相对于文件尾部而言，它是距离文件尾部的非正值，0 代表 EOF。 ffmpeg -sseof -00:06 -t 00:05 -i input output 将从距离 input 末尾 6 秒的地方开始，解码 5 秒。 视频选项 -vframes number (output) 指定输出多少视频帧，等同于-frames:v。 -r[:stream_specifier] fps (input/output,per-stream) 指定帧率 fps。 作为输入，忽略原有的时间戳并且用新生成的时间戳代替。 它和用于某些输入媒体的格式如 image2或v4l2 的 -framerate 选项不同，如有疑问，请用 -framerate代替-r选项。 作为输出，复制或丢弃某些帧以达到指定的帧率。 -s[:stream_specifier] size (input/output,per-stream) 指定帧尺寸， w*h 或 wxh。 -aspect[:stream_specifier] aspect (output,per-stream) 指定视频的显示宽高比，4:3, 16:9, 1.3333, 1.7777等。 -vn (output) 不输出视频内容 -vcodec codec (output) 指定视频编码器，等同于 -codec:v。 音频选项 -aframes number (output) 指定输出多少音频帧，等同于-frames:a。 -ar[:stream_specifier] freq (input/output,per-stream) 指定音频采样率。 -ac[:stream_specifier] channels (input/output,per-stream) 指定音频声道数。 -an (output) 不输出音频内容 -acodec codec (input/output) 设置音频编解码器，等同于 -codec:a . -sample_fmt[:stream_specifier] sample_fmt (output,per-stream) 指定音频采样格式。 高级选项 -map [-]input_file_id[:stream_specifier][,sync_file_id[:stream_specifier]] | [linklabel] (output) 指定一个或多个输入流作为输出源。 每个输入流根据输入文件索引、输入文件id和输入流索引来标示。所有的索引从 0 开始。第一个 -map选项确定输出流 0, 第二个 -map 选项确定输出流 1, 以此类推。 -符号表示不对该输入流进行映射。 示例： 将第一个输入文件的所有流映射至输出： ffmpeg -i INPUT -map 0 -f FORMAT output ffmpeg -i INPUT -map 0 output.mp4 假设你有一个输入文件，其中含有两个音频流，分别以0:0,0:1标示，只将第二个音频流输出： ffmpeg -i INPUT -map 0:1 out.wav 选取输入文件 a.mov中第三个输入流，标示为0:2 ，和输入文件 b.mov 中第 7 个输入，流标示为1:6 ，将它们拷贝到输出文件out.mov： ffmpeg -i a.mov -i b.mov -c copy -map 0:2 -map 1:6 out.mov 从输入文件中选中所有的视频流和第三个音频流： ffmpeg -i INPUT -map 0:v -map 0:a:2 OUTPUT 将所有流，除了第二个音频流，映射至输出： ffmpeg -i INPUT -map 0 -map -0:a:1 OUTPUT 音视频转换 视频 ==&gt; yuv ffmpeg -i 2.mp4 2.yuv ffmpeg -i input.mp4 -f rawvideo -vcodec rawvideo -pix_fmt yuv420p -s 1920x1080 -r 25 rawvideo.yuv yuv ==&gt; 视频 必须指定输入的 yuv 分辨率 -s ffmpeg -s 320x240 -i 2.yuv -c:v mpeg4 output.mp4 ffmpeg -f rawvideo -vcodec rawvideo -s 1920x1080 -r 25 -pix_fmt yuv420p -i inputfile.yuv -s 320x240 -c:v libx264 -qp 0 output.mp4 audio + yuv ==&gt; 视频 ffmpeg -i /tmp/a.wav -s 640x480 -i /tmp/a.yuv /tmp/a.mpg 音频转换 ffmpeg -i /tmp/a.wav -ar 22050 /tmp/a.mp2 通过映射流，将输入同时编码成多种格式到不同输出: ffmpeg -i /tmp/a.wav -map 0:a -b:a 64k /tmp/a.mp2 -map 0:a -b:a 128k /tmp/b.mp2 从视频中抽取图像 从 foo.avi 中每一秒抽取一张大小为 320x240 的图像到 foo-001.jpeg, foo-002.jpeg… ffmpeg -i foo.avi -r 1 -s 320x240 -f image2 foo-%03d.jpeg 如果只想抽取指定数量的图像帧，可搭配使用 -vframes`-t-ss`等选项。 根据图像序列生成视频 ffmpeg -f image2 -framerate 12 -i foo-%03d.jpeg -s 480x240 foo.avi 将多个 同类型 的输入媒体映射至输出 ffmpeg -i test1.avi -i test2.avi -map 1:1 -map 1:0 -map 0:1 -map 0:0 -c copy -y test12.nut 将 test1.avi 和 test2.avi 的音视频流逆序映射至 test12.nt 。（注意：这不是拼接视频，用 ffplay 播放的话，可以看出只播放了前面的 test.avi 部分） 从视频中生成 GIF ffmpeg -ss 00:10:00 -t 10 -i capx.mp4 -s 320x240 jilu.gif 拼接视频前提条件 视频图像尺寸一样 编码格式相同 protocol 支持文件级别拼接(MPEG-1, MPEG-2 PS, DV)，媒体类型必须一致。 ffmpeg -i &apos;concat:input1|input2&apos; -codec copy output ~~~在 `OS X 10.11` 下 `ffmpeg 2.8.2` 用该方式拼接后，只有 `input1` 部分。~~~ demuxer 推荐使用此方法 支持媒体流级别拼接，比 protocol 更灵活，可用于不同的媒体类型。 123456$ cat mylist.txtfile '/path/to/file1'file '/path/to/file2'file '/path/to/file3'$ ffmpeg -f concat -i mylist.txt -c copy output 编码格式不同 video filter适用于不同编码格式、不同媒体类型的文件拼接。 1ffmpeg -i opening.mkv -i episode.mkv -i ending.mkv -filter_complex '[0:0] [0:1] [1:0] [1:1] [2:0] [2:1] concat=n=3:v=1:a=1 [v] [a]' -map '[v]' -map '[a]' output.mkv 参考 https://ffmpeg.org/ffmpeg.html http://stackoverflow.com/questions/15778774/using-ffmpeg-to-losslessly-convert-yuv-to-another-format-for-editing-in-adobe-pr https://trac.ffmpeg.org/wiki/Concatenate]]></content>
      <categories>
        <category>ffmpeg</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
        <tag>命令行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[请按那个橙色键]]></title>
    <url>%2F2015%2F12%2F26%2F%E8%AF%B7%E6%8C%89%E9%82%A3%E4%B8%AA%E6%A9%99%E8%89%B2%E9%94%AE%2F</url>
    <content type="text"><![CDATA[12月25日，习近平在视察解放军报社时，通过军报微博微信平台，敲击键盘、发出了一条微博: 值此新年即将到来之际，我代表党中央、中央军委向全体解放军指战员、武警部队官兵和民兵预备役人员祝贺新年。希望大家践行强军目标，有效履行使命，为实现中国梦强军梦做出新的更大贡献！ 然而，细心的网友发现，习主席所操作的那台电脑的 Enter 键，被贴上了“微博发布”的橙色标签…… 这个”多此一举”的标注引起了不少网友对习大大电脑技术水平的怀疑，以及对下级无微不至的“贴心服务（回车键还要涂成全黄色，怕习主席找不到吗？）”的嘲笑。一时间，“赵王回车”火爆全网，庙堂与江湖齐欢。 更让人怀疑的是，所谓的“习主席键盘发微博”并不是指习主席本人 one by one 地用某狗输入法打出了这条消息，他只是负责在百忙中按下那个醒目的回车键而已。 要我说，这事活该，作秀要么来真的，像人家影帝就真哭，不行就干脆仪式化，没人觉得有问题，现在弄得不伦不类，贻笑天下。 小明还有两处疑问不解： “微博管理平台”不是新浪的吗？咋成军报技术团队自主研发的“微博管理平台”了？ “习主席敲击回车键，于16时13分把这条微博同时发布到4个平台。”，这么高端的“同时发布到4个平台”是如何实现的？ 小明供个方案：做个御用键盘，发微博专用，比金三胖的那个核按纽还牛哦。]]></content>
      <categories>
        <category>指点江山</category>
      </categories>
      <tags>
        <tag>赵王回车</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一曲动山河，熬碗鸡汤给你喝]]></title>
    <url>%2F2015%2F11%2F29%2F%E4%B8%80%E6%9B%B2%E5%8A%A8%E5%B1%B1%E6%B2%B3%EF%BC%8C%E7%86%AC%E7%A2%97%E9%B8%A1%E6%B1%A4%E7%BB%99%E4%BD%A0%E5%96%9D%2F</url>
    <content type="text"><![CDATA[《Fade》这首电音，没有一句歌词，却是辣么好听。 无论是运动、Party、车载，还是聚会，甚至一个人的时候都可以无限循环的神曲，蛤蛤，你值得拥有！ 有一天，小明开着车听这首歌，听完跪着开了20公里，被交警抓到，问他为什么跪着开车，他打开门让交警听一下，听完交警跪着给小明开了罚单。 《Fade》这首美到窒息的电音，旋律着实抓耳，恢弘大气而不失婉约，Alan 把他对生命热烈的赞美和青春流逝的叹息都注入这澎湃起伏的旋律中: 起初的一段曲调引人入胜，象征着少年得志，意气风发，对世间万物、人生百态充满了想象和希望……而后少年恣意地成长，他开始领略这世间的繁花簇锦，他开始在这滚滚红尘中打拼奋斗……看他在绚烂地绽放生命的花朵、看他在傲娇地挥洒青春热血……或高亢激昂，或低沉深吟，如同乐调一样，跌宕起伏，暂时的高峰接下来就是低谷，他还是不停的攀爬，背负起悲伤和痛苦，不断的前进……一路的各种经历使人颤栗，到最后沧桑巨变物是人非，他依然守住初心不变，笑看这潮起潮落云卷云舒…… 铿锵岁月融入到这一曲绚烂的青春舞曲中，这是一种既感慨生活的艰辛又无比热爱生活的人生哲学。 它，就好比《海阔天空》中的“原谅我这一生不羁放纵爱自由”它，就好比《蜗牛》中的“我要一步一步往上爬”它，就好比《相信自己》中的“超越极限超越自己”它，就好比《怒放的生命》中的“飞翔在辽阔天空，穿行在无边的旷野”它，就好比《最初的梦想》中的“最想要去的地方，怎么能在半路就放”它，就好比《阳光总在风雨后》中的“请相信有彩虹” 这排比句写的我连自己都感动了几百遍…… 4 分 24 秒，曲子播放完了。 来，干了这碗鸡汤： 生活虐我千百倍，我待生活如初恋。 我们又多了一首可以单曲循环的 《Fade》。 温馨提醒下：无论这首曲子多么好听，我都不建议你把它设为闹铃。]]></content>
      <categories>
        <category>心旷神怡</category>
      </categories>
      <tags>
        <tag>Fade</tag>
        <tag>Alan Walker</tag>
        <tag>鸡汤</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蛤蛤~水能载舟，亦可赛艇！]]></title>
    <url>%2F2015%2F11%2F02%2F%E8%9B%A4%E8%9B%A4-%E6%B0%B4%E8%83%BD%E8%BD%BD%E8%88%9F%EF%BC%8C%E4%BA%A6%E5%8F%AF%E8%B5%9B%E8%89%87%EF%BC%81%2F</url>
    <content type="text"><![CDATA[前不久，纽约时报中文网发表了一篇极有意味的文章《“膜蛤文化”盛行中国网络，或为影射习近平》，对着中英文看吧，顺便还能学几句地道英语…… 看完觉得，他们搞的这个东西啊，exciting~ 没想到连歪果仁都知道如今中文互联网上掀起的这股亚文化了，蛤蛤~ 但是呢，在我们这片神奇的土地上，基本法还是要遵守的。万一不小心弄个大新闻，又要被封杀。 所以，我不兹瓷你们对这篇文章过度解读。 要时刻警惕着美帝亡我之心不死，西方国家的媒体长者哪个没领教过？即使面对涛涛洪流，依然正襟危坐，你有这能耐吗？ 所以，我们还是要多积攒些人生经验，毕竟我们还是 too young，too simple。]]></content>
      <categories>
        <category>蛤学</category>
      </categories>
      <tags>
        <tag>蛤学</tag>
        <tag>一颗赛艇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最近有谁死了？]]></title>
    <url>%2F2015%2F11%2F01%2F%E6%9C%80%E8%BF%91%E6%9C%89%E8%B0%81%E6%AD%BB%E4%BA%86%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[有好事者搜集了我们这个星球最近一周（上周日：2015年10月25日 至 本周六：2015年10月31日）的亡魂。 有沉船死的，有地震死的，有被车压死的，有坠楼死的，有炸死的，有撞死的，有被火烧死的，有被土活埋的，有触电身亡的，有被刀砍死的，有患癌症死的，有自杀的，有跑马拉松猝死的，有喝酒喝死的，有被情杀的，有吵架被人骂死的（不懂？） 有道是： 金木水火土，样样杀人凶器。 在死亡面前，人的生命显得如此脆弱，《死神来了》依稀在目。 那么问题来了： 要不要到微博点个蜡烛祈福？好怕有人半夜趴窗户看我……]]></content>
  </entry>
  <entry>
    <title><![CDATA[蓝色骨头]]></title>
    <url>%2F2015%2F10%2F31%2F%E8%93%9D%E8%89%B2%E9%AA%A8%E5%A4%B4%2F</url>
    <content type="text"><![CDATA[《蓝色骨头》是中国华语歌手崔健首次参与执导的一部文艺电影，由崔健亲自担任编剧。 “一首歌，两代人，三段故事，四种曲风”，这是崔健对《蓝色骨头》极为简练的介绍，后来，他又多透露了点内容，这部电影在他 2005 年制作专辑《给你一点颜色》时就已经成形. 电影讲述了一个地下摇滚歌手兼网络黑客的年轻男子钟华，勾搭了一个小歌手萌萌，但萌萌却是老板的情人……钟华父亲的一个邮包又牵出 wen ge（懂？）期间的一段凄婉故事…… 电影将分为三个篇章，《蓝色骨头》这首歌贯穿始终，观众将听到四种曲风的《蓝色骨头》。这首歌是崔健2005年专辑《给你一点颜色》的主打歌，也是他个人以摇滚的态度看人生的真实写照。 该片故事较为敏感，整体风格偏向文艺，对于部分观众有一定的吸引力。 2013年11月16日该片于第8届罗马国际电影节上首映并获得组委会特别提及奖 2014年10月17日正式在中国内地公映。]]></content>
      <categories>
        <category>心旷神怡</category>
      </categories>
      <tags>
        <tag>崔健</tag>
        <tag>文革</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有jQuery背景的开发者如何建立起AngularJS的思维模式？]]></title>
    <url>%2F2015%2F10%2F30%2F%E6%9C%89jQuery%E8%83%8C%E6%99%AF%E7%9A%84%E5%BC%80%E5%8F%91%E8%80%85%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E8%B5%B7AngularJS%E7%9A%84%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%BC%8F%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[程序员技术网站 stackoverflow 有一则精彩问答： How do I “think in AngularJS” if I have a jQuery background? 【阅读原文】可浏览整篇技术含量极高的所有答案，对于 Angular 开发者十分涨姿势。 该问题至今已集结了 4538 个赞，其中 Josh David Miller 的答案得票最高，其文洋洋洒洒，循循善诱，娓娓道来，众望所归地荣获 7200 多赞，这篇文章将他的西文翻译成国语，以飨读者。 问题摘要我可以熟练使用jQuery进行客户端应用的开发，但是现在我希望开始使用Angular.js。哪位能描述一下这个过程中必要的模式变化吗？希望您的答案能够围绕下面这些具体的问题： 我如何对客户端web应用进行不同方式的架构和设计？它们之间最大的区别是什么？（译者注：指jQuery和Angular.js） 有什么是我不该做或者不该使用的；而又有什么是我应该做或者应该使用的呢？ 有没有一些服务端的考量/约束呢？ 我在寻找的就是一个关于jQuery和Angular.js之间的详细的比较。 1. 不要先设计页面，然后再使用DOM操作来改变它的展现在jQuery中，你通常会设计一个页面，然后再给它动态效果。这是因为jQuery的设计就是为了扩充DOM并在这个简单的前提下疯狂的生长的。 但是在AngularJS里，必须从头开始就在头脑中思考架构。必须从你想要完成的功能开始，然后设计应用程序，最后来设计视图，而非“我有这么一个DOM片段，我想让他可以实现XXX效果”。 2. 不要用AngularJS来加强jQuery类似的，不要以这样的思维开始：用jQuery来做X，Y和Z，然后只需要把AngularJS的models和controllers加在这上面。这在刚开始的时候显得非常诱人，这也是为什么我总是建议AngularJS的新手完全不使用jQuery，至少不要在习惯使用“Angular Way”开发之前这么做。 我在邮件列表里看到很多开发者使用150或200行代码的jQuery插件创造出这些复杂的解决方案，然后使用一堆callback函数以及$apply把它粘合到AngularJS里，看起来复杂难懂；但是他们最终还是把它搞定了！问题是在大多数情况下这些jQuery插件可以使用很少的AngularJS代码重写，而且所有的一切都很简单直接容易理解。 这里的底线是： 当你选择解决方案时，首先“think in AngularJS”；如果想不出一个解决方案，去社区求助；如果还是没有简单的解决方案，再考虑使用jQuery。但是不要让jQuery成为你的拐杖，导致你永远无法真正掌握AngularJS。 3. 总是以架构的角度思考首先要知道Single-page应用是应用，不是网页。所以我们除了像一个客户端开发者般思考外，还需要像一个服务器端开发者一样思考。我们必须考虑如何把我们的应用分割成独立的，可扩展且可测试的组件。 那么如何做到呢？如何“think in AngularJS”？这里有一些基本原则，对比jQuery。 视图是“Official Record”在jQuery里，我们编程改变视图。我们会将一个下拉菜单定义为一个ul ： 1234567891011&lt;ul class="main-menu"&gt; &lt;li class="active"&gt; &lt;a href="#/home"&gt;Home&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#/menu1"&gt;Menu 1&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="#/sm1"&gt;Submenu 1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#/sm2"&gt;Submenu 2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#/sm3"&gt;Submenu 3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#/home"&gt;Menu 2&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt; 在jQuery里，我们会在应用逻辑里这样启用这个下拉菜单： 1$('.main-menu').dropdownMenu(); 当我们只关注视图，这里不会立即明显的体现出任何（业务）功能。对于小型应用，这没什么不妥。但是在规模较大的应用中，事情就会变得难以理解且难以维护。 而在AngularJS里，视图是基于视图的功能。ul声明就会像这样： 1&lt;ul class="main-menu" dropdown-menu&gt; ... &lt;/ul&gt; 这两种方式做了同样的东西，但是在AngularJS的版本里任何人看到这个模版都可以知道将会发生什么事。不论何时一个新成员加入开发团队，他看到这个就会知道有一个叫做dropdownMenu的directive作用在这个标签上；他不需要靠直觉去猜测代码的功能或者去看任何代码。视图本身告诉我们会发生什么事。清晰多了。 首次接触AngularJS的开发者通常会问这样一个问题：如何找到所有的某类元素然后给它们加上一个directive。但当我们告诉他：别这么做时，他总会显得非常的惊愕。而不这么做的原因是这是一种半jQuery半AngularJS的方式，这么做不好。这里的问题在于开发者尝试在AngularJS的环境里“do jQuery”。这么做总会有一些问题。视图是official record。在一个directive外，绝不要改变DOM。所有的directive都应用在试图上，意图非常清晰。 记住： 不要设计，然后写标签。你需要架构，然后设计。 数据绑定这是到现在为止最酷的AngularJS特性。这个特性使得前面提到的很多DOM操作都显得不再需要。AngularJS会自动更新视图，所以你自己不用这么做！在jQuery里，我们响应事件然后更新内容，就像这样： 123456$.ajax(&#123; url: '/myEndpoint.json', success: function ( data, status ) &#123; $('ul#log').append('&lt;li&gt;Data Received!&lt;/li&gt;'); &#125; &#125;); 对应的视图: 1&lt;ul class="messages" id="log"&gt; &lt;/ul&gt; 除了要考虑多个方面，我们也会遇到前面视图中的问题。但是更重要的是，需要手动引用并更新一个DOM节点。如果我们想要删除一个log条目，也需要针对DOM编码。那么如何脱离DOM来测试这个逻辑？如果想要改变展现形式怎么办？ 这有一点凌乱琐碎。但是在AngularJS里，可以这样来实现： 12345$http('/myEndpoint.json').then(function (response) &#123; $scope.log.push(&#123; msg: 'Data Received!' &#125;);&#125;); 视图看起来是这个样子的： 123&lt;ul class="messages"&gt; &lt;li ng-repeat="entry in log"&gt;&lt;/li&gt;&lt;/ul&gt; 但是其实还可以这样来做： 123&lt;div class="messages"&gt; &lt;div class="alert" ng-repeat="entry in log"&gt;&lt;/div&gt; &lt;/div&gt; 现在如果我们想使用Bootstrap的alert boxes，而不是一个无序列表，根本不需要改变任何的controller代码！更重要的是，不论log在何处或如何被更新，视图便会随之更新。自动的。巧妙！ 尽管我没有在这里展示，数据绑定其实是双向的。所以这些log信息在视图里也可以是可编辑的。只需要这么做： 123&lt;div class="highlight"&gt; &lt;pre&gt;&lt;input ng-model="entry.msg" /&gt;&lt;/pre&gt;&lt;/div&gt; 简单快乐。 清晰的模型（Model）层在jQuery里，DOM在一定程度上扮演了模型的角色。但在AngularJS中，我们有一个独立的模型层可以灵活的管理。完全与视图独立。这有助于上述的数据绑定，维护了关注点的分离（独立的考虑视图和模型），并且引入了更好的可测性。后面还会提到这点。 关注点分离上面所有的内容都与这个愿景相关：保持你的关注点分离。视图负责展现将要发生的事情；模型表现数据；有一个service层来实现可复用的任务；在directive里面进行DOM操作和扩展；使用controller来把上面的东西粘合起来。这在其他的答案里也有叙述，我在这里只增加关于可测试性的内容，在后面的一个段落里详述。 依赖注入依赖注入帮我们实现了关注点分离。如果你来自一个服务器语言（java或php），可能对这个概念已经非常熟悉，但是如果你是一个来自jQuery的客户端开发者，这个概念可能看起来有点傻而多余。但其实不是的。。。 大体来讲，DI意味着可以非常自由的声明组件，然后在另一个组件里，只需要请求一个该组件的实例，就可以得到它。不需要知道（关心）加载顺序，或者文件位置，或类似的事情。这种强大可能不会立刻显现，但是我只提供一个（常见。。）的例子：测试。 就说在你的应用里，我们需要一个服务通过REST API来实现服务器端存储，并且根据不同的应用状态，也有可能使用（客户端）本地存储。当我们运行controller的测试时，不希望必须和服务器交互 —— 毕竟是在测试controller逻辑。我们可以只添加一个与本来使用的service同名的mock service，injector会确保controller自动得到假的那个service —— controller不会也不需要知道有什么不同。 说起测试…… 4. 总是 —— 测试驱动开发这其实是关于架构的第3节。但是它太重要了，所以我把它单独拿出来作为一个顶级段落。 在所有那些你见过，用过或写过的jQuery插件中，有多少是有测试集的？不多，因为jQuery经不起测试的考验。但是AngularJS可以。 在jQuery中，唯一的测试方式通常是独立地创建附带sample/demo页面的组件，然后我们的测试在这个页面上做DOM操作。所以我们必须独立的开发一个组件，然后集成到应用里。多不方便！在使用jQuery开发时，太多的时间，我们挑选迭代而非测试驱动开发。谁又能责怪我们呢？ 但是因为有了关注点分离，我们可以在AngularJS中迭代地做测试驱动开发！例如，想要一个超级简单的directive来展现我们的当前路径。可以在视图里声明： 1&lt;a href="/hello" when-active&gt;Hello&lt;/a&gt; OK，现在可以写一个测试： 1234567it('should add "active" when the route changes', inject(function () &#123; var elm = $compile('&lt;a href="/hello" when-active&gt;Hello&lt;/a&gt;')($scope); $location.path('/not-matching'); expect(elm.hasClass('active')).toBeFalsey(); $location.path('/hello'); expect(elm.hasClass('active')).toBeTruthy();&#125;)); 执行这个测试来确认它是失败的。然后我们可以开始写这个directive了： 1234567891011121314.directive('whenActive', function ($location) &#123; return &#123; scope: true, link: function (scope, element, attrs) &#123; scope.$on('$routeChangeSuccess', function () &#123; if ($location.path() == element.attr('href')) &#123; element.addClass('active'); &#125; else &#123; element.removeClass('active'); &#125; &#125;); &#125; &#125;;&#125;); 测试现在通过了，然后我们的menu按照请求的方式执行。开发过程既是迭代的也是测试驱动的。太酷了。 5. 概念上，Directives并不是打包的jQuery你经常会听到“只在directive里做DOM操作”。这是必需的。请给它应有的尊重！ 但让我们再深入一点…… 一些directive仅仅装饰了视图中已经存在的东西（想想ngClass）并且因此有时候仅仅直接做完DOM操作然后就完事了。但是如果一个directive像一个“widget”并且有一个模版，那么它也要做到关注点分离。也就是说，模版本身也应该很大程度上与其link和controller实现保持独立。 AngularJS拥有一整套工具使这个过程非常简单;有了ngClass我们可以动态地更新class；ngBind使得我们可以做双向数据绑定。ngShow和ngHide可编程地展示和隐藏一个元素；以及更多地 —— 包括那些我们自己写的。换句话说，我们可以做到任何DOM操作能实现的特性。DOM操作越少，directive就越容易测试，也越容易给它们添加样式，在未来也越容易拥抱变化，并且更加的可复用和发布。 我见过很多AngularJS新手，把一堆jQuery扔到directive里。换句话说，他们认为“因为不能在controller里做DOM操作，就把那些代码弄到directive里好了”。虽然这么做确实好一些，但是依然是错误的。 回想一下我们在第3节里写的那个logger。即使要把它放在一个directive里，我们依然希望用“Angular Way”来做。它依然没有任何DOM操作！有很多时候DOM操作是必要的，但其实比你想的要少得多！在应用里的任何地方做DOM操作之前，问问你自己是不是真的需要这么做。有可能有更好的方式。 这里有一个示例，展示出了我见过最多的一种模式。我们想做一个可以toggle的按钮。（注意：这个例子有一点牵强、啰嗦，这是为了表达出使用同样方式处理问题的更复杂的情况。） 12345678910111213141516.directive('myDirective', function () &#123; return &#123; template: '&lt;a class="btn"&gt;Toggle me!&lt;/a&gt;', link: function (scope, element, attrs) &#123; var on = false; $(element).click(function () &#123; if (on) &#123; $(element).removeClass('active'); &#125; else &#123; $(element).addClass('active'); &#125; on = !on; &#125;); &#125; &#125;;&#125;); 这里有一些错误的地方。首先，jQeury根本没必要出现。我们在这里做的事情都根本用不着jQuery！其次，即使已经将jQuery用在了页面上，也没有理由用在这里。第三，即使假设这个directive依赖jQuery来工作，jqLite(angular.element)在加载后总会使用jQuery！所以我们没必要使用$ —— 用angular.element就够了。第四，和第三条紧密关联，jqLite元素不需要被$封装 —— 传到link里的元素本来就会是一个jQuery元素！第五，我们在前面段落中说过，为什么要把模版的东西混到逻辑里？ 这个directive可以（即使是更复杂的情况下！）写得更简单： 123456789101112.directive('myDirective', function () &#123; return &#123; scope: true, template: '&lt;a class="btn" ng-class="&#123;active: on&#125;" ng-click="toggle()"&gt;Toggle me!&lt;/a&gt;', link: function (scope, element, attrs) &#123; scope.on = false; scope.toggle = function () &#123; scope.on = !$scope.on; &#125;; &#125; &#125;;&#125;); 再一次地，模版就在模版里，当有样式需求时，你（或你的用户）可以轻松的换掉它，不用去碰逻辑。重用性 —— boom！ 当然还有其他的好处，像测试 —— 很简单！不论模版中有什么，directive的内部API从来不会被碰到，所以重构也很容易。可以不碰directive就做到任意改变模版。不论你怎么改，测试总是通过的。 所以如果directive不仅仅是一组类似jQuery的函数，那他们是什么？Directive实际是HTML的扩展。如果HTML没有做你需要它做的事情，你就写一个directive来实现，然后就像使用HTML一样使用它。 换句话说，如果AngularJS库没有做的一些事情，想想开发团队会如何完成它来配合ngClick，ngClass等。 总结不要用jQuery.连include也不要。它会让你停滞不前。如果遇到一个你认为已经知道如何使用jQuery来解决的问题，在使用$之前，试试想想如何在AngularJS的限制下解决它。如果你不知道，问！20次中的19次，最好的方式不需要jQuery。如果尝试使用jQuery会增加你的工作量。]]></content>
      <categories>
        <category>Front-end</category>
      </categories>
      <tags>
        <tag>Angular</tag>
        <tag>JQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[怀上来生出来养起来，就是不能打下来]]></title>
    <url>%2F2015%2F10%2F29%2F%E6%80%80%E4%B8%8A%E6%9D%A5%E7%94%9F%E5%87%BA%E6%9D%A5%E5%85%BB%E8%B5%B7%E6%9D%A5%EF%BC%8C%E5%B0%B1%E6%98%AF%E4%B8%8D%E8%83%BD%E6%89%93%E4%B8%8B%E6%9D%A5%2F</url>
    <content type="text"><![CDATA[今天，党的第十八届五中全会传来一个福音：执行了三十多年的灭绝人性、违背天理、惨绝人寰的计划生育政策，终于要做调整了。 我党经常干这种自我打脸（美其名曰：自我批评）的丑事，我脑海中首先浮现的是跟计划生育有关的那些悲惨事迹。 当年一手搞经济建设，一手狠抓计划生育，家里的猪被计生办牵走了，沙发被计生办抢走了……家破了，人还没亡，小两口躲到外地去生，咣咣猛生，不造一个带把的出来绝不罢休，此等意志，非外力可挡，着实壮烈。 据说十年后农村的标语： 1.怀上来生出来养起来，就是不能打下来。2.经济搞上去，人口跟上来。3.二胎奖，一胎罚，丁克不育都该抓。4.该生不生，后悔一生。该养不养，老无所养。5.生男生女都一样，不然儿子没对象。6.一人拒绝多生，全村人工受精。7.农村要想富，多生孩子多种树。 我党的二胎宣传语估计是这样的： 虽然此项德政来的晚了点，不过依旧是德政，欢迎我党继续自我打脸，啪啪啪~]]></content>
      <categories>
        <category>指点江山</category>
      </categories>
      <tags>
        <tag>计划生育</tag>
        <tag>二胎</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一周墓碑记]]></title>
    <url>%2F2015%2F10%2F26%2F%E4%B8%80%E5%91%A8%E5%A2%93%E7%A2%91%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[小明这个星期干嘛去了？ 怎么一个礼拜没有更新了？ 后台收到不少粉丝的亲切问候，其中不乏不明真相的群众开始胡思乱想： 小明哥是不是被领导请去喝茶了？小明不会是在东莞被抓了吧，哎！怎么那么不小心呢？一日不见小明发牢骚，顿觉世界黑暗了许多……几日不见先生推送新文章，先生莫非有什么苦衷？先生有空还是写写吧。小黄你是不是被弟妹罚跪搓衣板了？你妈的到底什么时候更新啊？ 其实，是人家的公众号一不小心被微信后台屏蔽了，屏蔽周期：2015-10-19 至 2015-10-26。 为了证明你们敬爱的小明老师并不是因为在东莞被抓，也不是被老婆体罚，我还是晒一下后台的处罚记录吧，看看这华丽的、屡战屡败、屡败屡战、屡教不改的违规记录： 关注我微信公众号的朋友们可能发现，有部分推送出去的文章存活期不到一天有时甚至几小时就被后台以“违法”之名删除，究其原因大概是长者的文章发多了吧……说到这，让我们鄙视下文字狱。 我也真是奇了怪了，人家经营公众号不足三月，粉丝数可怜的尚未破千，难不成我的粉丝队伍不纯洁，其中居然埋伏有朝廷的鹰犬每日对我发的文章虎视眈眈：一看到“长者”就举报，一说政府坏话就举报，也不管其中内容为何，只问立场、不问是非，俨然文革再世，何其可怖？ 经过此次被封事件，小明总结了一下三点经验教训： 堡垒是从内部被攻破的，要保证革命队伍的纯洁性。兹决定审查粉丝名单，对那些地下特工嫌疑分子一律拉黑名单，宁可错杀三千（虽然我粉丝还没有那么多），绝不放过一人。 逐步提高笔杆子斗争的技术含量。指点尖山、激扬文字、粪土万户侯也是门技术活。有些话不能直说，要拐着弯说；有些人即使欠骂也不能图嘴舒服乱骂，要拐着弯儿不带脏字地骂；有些理念不能说得太直白，too simple，要用冷门专业词汇加西文翻译点缀之；有些句子不能说得太通顺，要主语谓语宾语状语补语和名词动词形容词糅合着用，不能被人一眼就看明白文章的真实寓意……以此为文，以期达到即使文章“被举报+后台漂亮MM来人工审查”，也无法看出文章的弦外之音。 劈开枪林弹雨，准确把握“反围剿”的最佳战期。以前发文章的时间大多为晚上9点多后，其实8点到凌晨这个时间段是公众号后台文章审核最严格的时间段，稍微检测到几个敏感词，就被告知”违反相关法律法规规定，发送失败……”，相比而言，审核最松懈的时间段为早上8点到10点。我曾经把某篇在前一晚死活发不出去的文章放到第二天早上9点左右发，结果一次就发送成功了。Surpried~]]></content>
      <categories>
        <category>WeChat</category>
      </categories>
      <tags>
        <tag>微信</tag>
        <tag>屏蔽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[$watch vs ng-change]]></title>
    <url>%2F2015%2F10%2F25%2Fwatch-vs-ng-change%2F</url>
    <content type="text"><![CDATA[When something changesIn the olden days, before you used MVC frameworks such as Angular, you were probably used to doing stuff like this in jQuery: 12345function showNameChanged() &#123; // stuff...&#125;$('input.show-name').change(showNameChanged); This achieves the simple task of performing an operation whenever the user typed something inside an input, using JS change events. In Angular, though, most people would consider this code the equivalent: 12&lt;input type=text ng-model=show.name&gt;$scope.$watch('show.name', showNameChanged); Now, you might think I’m being nit picky here, but I’d usually rather write it like this: 1&lt;input type=text ng-model=show.name ng-change="showNameChanged()"&gt; ng-change?I’m always surprised that this directive is foreign for a lot of newcomers to Angular, and that $watch seems to be the tool everyone reach for first. ng-change is a simple directive that operates much like using jQuery to register a change event listener. In my opinion, this is the “real” equivalent of the first code sample we saw. The differences Using ng-change would call our showNameChanged() function only on actual changes to the input by the user. Watches, as you might know, are called in other cases too: right when they’re being defined the first time and on changes made to the value not by the user, e.g. programmatically. I’m a big believer in expressing intent when writing code (you do know The 4 Rules of Simple Design, right?). If my intent is to only listen to changes by the user, and I don’t expect the input to be changed programmatically, I would rather explicitly show that. Using $watch means whenever you read this code in the future you’ll have to consider whether it’s being triggered by something else, too. Another plus for intent for ng-change is that you can see from the template that this input is bound to something and how. Otherwise you’d need to start looking for the value in ng-model in the controller for usages. This way you can see right away who’s listening for these changes. Less code. And “less code == less things to debug”. As you can see above we didn’t need to add another line to the controller to listen for input changes. Using ng-change is a tiny bit more performant, since it uses one less watch expression. Since Angular knows it should only call the expression on change events it doesn’t need to keep evaluating it on every digest cycle, as opposed to, well, a watch. Yes, just this one doesn’t matter a lot, but across a big app these things stack up. Of course, sometimes $watch is what you want. But sometimes – it ain’t! References http://stackoverflow.com/questions/15112584/angularjs-using-scope-watch-and-scope-apply http://www.angularjs.cn/A0a6]]></content>
      <categories>
        <category>Front-end</category>
      </categories>
      <tags>
        <tag>$watch</tag>
        <tag>ng-chane</tag>
        <tag>angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[长者究竟掌握了几门外语]]></title>
    <url>%2F2015%2F10%2F18%2F%E9%95%BF%E8%80%85%E7%A9%B6%E7%AB%9F%E6%8E%8C%E6%8F%A1%E4%BA%86%E5%87%A0%E9%97%A8%E5%A4%96%E8%AF%AD%2F</url>
    <content type="text"><![CDATA[每当看到 naive 这个单词时，我总会会心一笑，这是一个暗号：如果不是长者，我们怎能轻松掌握这个词汇。那一段短短几分钟的即兴讲话里融合了普通话、粤语和英语，充分展现了长者的语言才能。 今天我们就来梳理下长者究竟掌握了几门语言。 毕竟严肃文学，我们不妨把标准定得严一点。只会几句寒暄不算，只有能顺利表达自己，与人交流，乃至通过语言对其文化产生共鸣才能算掌握。 按此标准筛选，长者精通的是英语和俄语，罗马尼亚语次之，通晓西班牙语、日语，法语和德语一般交流没的说，此外还掌握了冷门的乌尔都语。 八门语言英语这无疑是长者掌握最好的一门的语言，堪称精通。从9岁学习英语，到如今90岁依旧沉溺其中。江真正将书本上的英语扎扎实实落根的是在上海交大的两年，其时江就读于工学院电机系，列举下他几位老师，朱物华教授，麻省理工硕士哈佛博士，张种俊院士，麻省理工博士后，知名学者顾毓琇麻省理工博士，「教学全用英语」江继续说道「教科书、实验报告、讲课、考试——这一切极大地提高了我们的语言技能」。 良好的英语功底加之好莱坞电影在当时上海滩的风靡，使得年轻的江能轻而易举地啃生肉，当时影院放映时的字幕，是刻好字用药水腐蚀出来的，放出来的效果是反光的，一闪一闪，看不清楚。「他挤时间看了美国电影《乱世佳人》和《魂断蓝桥》」 江喜欢用英语演讲，2000年在美中关系全国委员会等组织联合举行的午餐会上，他用英语发表演说，而更早的97年，江在哈佛大学英语演讲，而江也成为中国领导人「英语演讲第一人」。不仅在哈佛，他还在儿子的母校德雷克塞尔大学用英文讲话。 江展现英语的高光时刻是在2001年的上海，他用英语主持了APEC第9次领导人非正式会议对话会，并用英语宣读了《2001年APEC领导人宣言》，会上他与布什讲英语，与普京讲俄语，与小泉讲日语，游刃有余。 同时他的英文书法也写的不错，字体应该是 chancery ltalic。 英文阅读方面，江订阅了几份英文报纸，其中之一是《华盛顿邮报》。文革初他为了姿势正确地学习英语，特意买了英文版的毛泽东选集看。江也重视听力训练，「每次出差途中，总看到他捧着一台在国外参加会议时买的半导体收音机，收听中央台的对外外语广播」他在热工所的老同事丁瑞芝回忆道。 其他如86年在交大背诵林肯葛斯底堡演讲、00年与华莱士历时四小时88回合的英语访谈这样的经典桥段就不再赘言了，毕竟长者的英语堪比母语，秀得太多太多，这里提一下逼格高一点的，李岚清曾在书中回忆长者恢复失传的托塞利小夜曲英文歌词的经过。 俄语长者的俄语水平次之，俄语的学习是解放后，有据考察是51年江在英商肥皂厂，跟一位白俄秘书茜茜金娜学习俄语。两年后江调任一机部二分局，当时苏联援助不断涌进，为了看懂技术资料，江倡导成立了俄语学习班，开始了系统的学习。55年，江被派往莫斯科， 在那里，江只要一有机会就练习俄语——在正式会议上，在与陌生人的邂逅中——他从来不觉得有什么不自在，他还鼓励那些沉默寡言的同事以他为榜样。 文革初，他为热工所技术人员组织讲座和课程，其中就有用俄语授课。95年访俄，江在专场音乐会上用俄语深情朗诵起西蒙诺夫的诗《等着吧，我会回来》。 98年，江造访俄罗斯科学院西伯利亚分院，为了节省时间，他决定不用翻译直接用俄语演说，值得一提的是这是演讲内容皆为科技题材，包括了「脱氧核糖核酸双螺旋结构」这种中文都很难讲顺的词。01年访俄，在莫斯科大学，江用俄语作了40分钟的演讲，畅谈了「中俄关系的美好未来」。上一位在莫斯科大学做演讲的是毛，「八九点钟的太阳」即出于此。02年江在圣彼得堡参观，用俄语吟诵了普希金著名诗篇《致凯恩》中的诗句。 多掌握一门语言还有助于撩菜，02年赖斯陪同布什访华时，江与她跳了一曲，「江似乎与赖斯女士配合得特别出色，因为她也会讲俄语。他们用俄语交谈，江告诉赖斯，她看上去比以前更年轻了」 文革前夜，江还曾经将他在苏联的实习老师特莱霍夫的著作《机械制造厂电能的合理使用》翻译成中文，该书于89年出版。 日语这门语言于长者有点敏感。39年底，日据时的扬州部分学校开始复课，日语成为学校的必修课。后来江自己回忆起来当时尽管每天都上日语课，但却总是勉强及格，「却从不后悔当时的倔强」江说，「要不是那时我是被迫学习日语的，今天我的日语就会讲得好一些」 江没说谎，后来五十年代在上海工作时，单位成立了日语学习班，江也报名参加了。刚在日语班时，一同事跟他开玩笑说江的名字日语发音应该叫Kezagumin（译音），江说不对吧，应该念Koutakumin（译音），后来这位同事去查，果然江是对的。 成为总书记后，一次江参观中央台对外日语演播室，对工作人员说了句日语，意为「我也多少知道点日语的」，访日时江也多次用日语进行日常交流。 法语、德语法语是唯一没找到江系统学习证据的，只在一篇老同事回忆里提到70年代初去北京出差去拜见长者，发现他「半夜里还在走廊自学法语”，当时江任一机部外事局局长，负责对外援建的事宜，起早贪黑学习法语所言非虚。 后来，作为国家主席的江访法时在爱丽舍宫欢迎宴会上用法语致祝酒词；与西哈努克当面讨论「太皇」一词的法语翻译如何更为准确；参观摩洛哥胶合板厂法语向工人们问好，可见江的法语一般交流毫无问题。 06年，交大成立110周年，江来母校看望师生，当听到管理学院学生朱莉丽02~04年参加上海交大与法国中央理工大学的国际交流活动，大龄学长用法语问「你会法语吗？」，随后便与她寒暄起来。 和日语学习类似，由于当时德国电器顶尖，不少情报杂志都是德文，研究所成立了德语学习小组，江作为唯一一名领导加入了德语学习小组，后来江的老师回忆道： 他很懂学外语的门道，紧抓发音不放，而且敢于开口 四十年后在柏林出席德国经济亚太委员会举行的宴会，江以德语发表重要讲话。他还曾脱离讲稿，即席朗诵了歌德的诗歌《中德四季晨昏杂咏》中的一段「暮色徐徐下沉，景物俱已远遁。长庚最早升起，光辉柔美晶莹！……此时在那东方，该有朗朗月光」 西班牙语江在访问智利期间做了长达四十分钟的演讲，除去激动人心的内容外，江这次演讲吸引人的地方还在于他自始自终用西班牙语进行演讲。 和其他所有掌握的语言不同，西语是他为了访问拉美国家临时学会的，当时他已经75岁，连续用七八个周末向外交部一位年轻译员学西班牙语。据那位后来成为大使的翻译同志讲，江学得特别认真，有时为了一个词的发音会练上十来遍。 造访古巴时，江步下舷梯，与卡斯特罗深情拥抱后，便用西语问候道「Gracias.Cómo estás，mi viejo amigo(谢谢。你好吗？老朋友)」，更让卡斯特罗惊喜的是，随后的会谈中，江又用西班牙语做了五分钟的开场白。在欢迎宴会上，江还用西语演唱了《鸽子》，向卡斯特罗赠送七绝诗朗诵时用也是西语。 乌尔都语1976年4月，江率领专家组到巴基斯坦检查援助项目，在这里工作了六周。巴方给他排了个司机，但司机只会讲乌尔都语，因为要指挥司机怎么走，江短短时间内掌握了这门冷僻的语言。时隔20年，江与巴国领导人会晤时讲了几句乌尔都语，让巴基斯坦报纸分外激动。访巴期间江还跟当年老同事回忆起说，至今还记得「一直走」叫「Seethaa」。 当然，像江访问蒙古时用蒙古语向仪仗队说道「赛百诺！（你好）」，用意大利语唱《我的太阳》，这样的小花絮都没算长者真掌握了，毕竟严肃文学，有着严格的标准。 长者为什么能掌握这么多语言？家庭环境江祖父是扬州文化名人，「诗画医音融一炉」，著有《梦笔生花馆诗集》，六叔江上青被誉为「生花妙笔的江淹」，长兄江泽君是新中国江苏戏剧事业奠基人，七叔江树峰精通英俄法多国文字，老丈人曾留美，说一口流利的英语。这样的家教和环境对长者学习语言有极大的帮助。 speak more 农大校长在一篇文章中曾回忆道，江会见了出席国际农业科技大会的部分外国专家时，英语俄语法语无障碍切换，其中有位专家说了句「江主席您会那么多国外语呀！」听了这句话后，江笑着说道： 学外语就要 speak more，我这个人就敢说。 天赋、享受学习的乐趣、以及必要的刻苦训练打通了一种良性循环，驱策着江成就了他人认为遥不可及的业绩。 一位漂亮老师 特殊的生理构造 “你们一定要学好英语”《他改变了中国》一书里曾记载到，当与外宾正式会议结束时，尤其是如果要举行午宴或者晚宴，江就会转而说英语，享受这种自然的交流。如果某些政府成员或者工作人员跟不上的话，他就会利用善意的公共压力来刺激他们学习。「所有在这里的人当中」，江会微笑着说，「只有X先生和Z先生听不懂我们说的话（英语）」 「江主席的外语能力是有名的」，前国务院新闻办主任赵启正说，他喜欢学习不同语言的新词汇，并和以外语为母语的人讨论词义的微妙差别。「一次，我们正在讨论哪种核反应堆最安全，我把‘pressure’这个词中的‘r’发音发错了，发成了一个喉音。江纠正了我的发音并问我为什么会犯这个错误。我说因为我的第一外语是德语。」 如果江的同僚们了解江司机的处境时，也不会觉得自己受到怎样的苛求。「我必须重新开始学习英语」，他的司机说，「不然在我为主席开车的时候就会感到窘迫。」 江甚至将对语言的苛求要求在其家人身上上，99年12月，江组织了一个家族聚会，欢度千禧年。库恩在江的传记里如实记载了这个场景「聚会开始之前，他回顾了20世纪的中国历史，也讲了江氏家族里一些人的往事。说完后，他把年轻的一代叫到身边，包括他的孙儿们，让他们把刚才他所说的翻译成英语。江用英语和汉语向他们提问。如果他的问题用汉语提出，他们要先把问题翻译成英语，然后再用英语回答。如果他的问题用英语提出，那么他们直接用英语回答。他对小字辈能够流利使用英语感到欣慰，对自己差不多能跟上他们的水平也样感到高兴。就在晚餐开始前，江提了个令人吃惊的要求：所有人，不论长幼都必须说英语。」 知乎上曾有人问掌握多种语言是一种怎样的体验，我最喜欢的一个回答是： 一种谦逊、平和心态。你的思维方式会更加多元化，你看一个问题的视角会变得更加宽阔，你会从原来的世界看到一个更大的世界，你也可以从一个新的世界里看到自己原来的世界。 所以江曾在《领导干部一定要努力学习外语》一文中说： 我们应该尊重世界多样性，了解和借鉴各国人民创造的文明成果，促进和加强同各国人民的交流交往。要做到这一点，需要努力学习外语。 语言也可以体现出世界观，江任期内难能可贵地不断向主流文明靠拢，反之则是固步自封、自命不凡的思维，所以一种人会劝读弟子规，一种人说还要读莎士比亚。 参考 《革命青年满腔热血——青年江泽民与南京》 《江泽民在一机部：1970-1980》 《江泽民在一汽的岁月》 《江泽民在上海：1985-1989》 《中国能源问题研究》 《江泽民与中国科学院》 《为了世界更美好：江泽民出访纪实》 《日出江花：青年江泽民在上海》 《古风今韵：江泽民运用古诗文赏析》 《领导干部一定要努力学习外语》]]></content>
      <categories>
        <category>心旷神怡</category>
      </categories>
      <tags>
        <tag>长者</tag>
        <tag>外语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再谈阿里校招缩水与侮辱性 Offer]]></title>
    <url>%2F2015%2F10%2F16%2F%E5%86%8D%E8%B0%88%E9%98%BF%E9%87%8C%E6%A0%A1%E6%8B%9B%E7%BC%A9%E6%B0%B4%E4%B8%8E%E4%BE%AE%E8%BE%B1%E6%80%A7-Offer%2F</url>
    <content type="text"><![CDATA[关于阿里校招缩水一事，［阅读原文］可看我之前写过的一篇文章：《我看阿里巴巴 2016 校园招聘名额缩减》。 今天，小明更是惊闻： 阿里巴巴校招月薪降到 8K 了吗？！ 小明和女神让我先来说一个段子： 小明看上了一位女神，女神漂亮啊，天使面孔、魔鬼身材，家里有钱又有田，人又有品味，简直是~~ 要知道，女神的追求者很多，可是小明觉得自己也不差，因为从来只有自己拒绝女生，还没有女生拒绝自己。 女神面对众多的追求者说，你们别着急，我要一个一个考察，然后对小明说，「你放心，我一定嫁给你。」 小明开心啊，不管之前有多少萌妹纸、御姐想要和小明滚床单，小明都拒绝了，小明说，我是真爱，要守身如玉。 等了很久，女神和小明说，「好了，我可以嫁给你了。」 小明很激动啊。 女神又说：「但是，你要答应我几个条件。」 小明都快要乐晕了，忙不迭地连声说：「什么条件我都答应你！」 女神不紧不慢开始数条件：「婚后，扫地、洗衣、做饭、刷碗、家务活，所有需要动手的，你干；工资卡上缴；大事儿小事儿统统我说了算。」 小明勃然大怒：「你这个绿茶婊！这是侮辱！」 好了，现在让我们把段子拉回现实，以下为传言： 阿里本来计划校招 3000 人，后来缩编到 400 人，但已经发出了 1400+ 的口头 Offer，这个时候，阿里做了决定： 1、所有口头offer全部进入谈薪阶段，谈薪完成，发正式 Offer 2、所有进行中但未发口头offer的校招停止。 据内部人士透露，阿里巴巴 2016 年校招 Offer 月薪降到 8K 了……很多学生表示，这是「侮辱性的 Offer」！ 风口上的猪8K 的批发价确实不高，毫不夸张地说，杭州随便扔出个互联网公司都能开出这个价位。马云今年提出「拥抱变化」，这变化也有点耸人听闻啊。 那些觉得自己真牛逼的，不止这个价，自认无论在哪个公司都值 10K＋的，你又何必在意阿里呢？如果你真的是大牛，到一些中小型开发企业你就是天，所有人都把你当佛一样供着……大公司、小公司都各有千秋，何必抱死在一颗大树呢？ 傻眼的是某些参加阿里校招的同学，有人因为拿了阿里的口头 Offer，结果其他公司开的正式 Offer 都拒绝了。 整个互联网已经过了野蛮扩张的增长期，开始回归理性。阿里开出这种 Offer ，估且看作是把那些眼高手低，三观不符合其预期的人阻挡在外的举措。「是金子在哪里都会发光」，那些一听到 8k 就暴跳如雷的人，你怕的，无非是整个行业都冷静下来，而平庸的你，再也没法滥竽充数，一入行就拿到其他行业毕业生羡慕不已的高薪了吧。 雷军当年的「猪」论还犹如在耳： 站在风口，是猪都会飞。 今年的阿里校招给它续下了后半句： 风过了，猪是会摔下来的。]]></content>
      <categories>
        <category>互联网</category>
      </categories>
      <tags>
        <tag>互联网</tag>
        <tag>阿里</tag>
        <tag>校招</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OS X 上配置 Apache VirtualHost]]></title>
    <url>%2F2015%2F10%2F14%2FOS-X-%E4%B8%8A%E9%85%8D%E7%BD%AE-Apache-VirtualHost%2F</url>
    <content type="text"><![CDATA[我使用的系统是 OS X Yosemite Version 10.10.5。 启动Apache打开 terminal，输入 sudo apachectl -v，如下显示 Apache 的版本： 1234hxz@Mac-mini:~$ sudo apachectl -vPassword:Server version: Apache/2.4.16 (Unix)Server built: Jul 22 2015 21:03:09 接着输入sudo apachectl start，这样 Apache 就启动了。打开浏览器地址栏输入 http://localhost，可以看到内容为It works!的页面。其位于/Library/WebServer/Documents/下，这是 Apache 的默认根目录。 设置虚拟主机 在终端运行 sudo vi /etc/apache2/httpd.conf，打开Apche的配置文件在 httpd.conf 中找到 #Include /private/etc/apache2/extra/httpd-vhosts.conf，去掉前面的＃，保存并退出。 运行sudo apachectl restart，重启 Apache 后就开启了虚拟主机配置功能。 运行sudo vi /etc/apache2/extra/httpd-vhosts.conf，配置虚拟主机了。该文件默认开启了两个作为例子的虚拟主机： 123456789101112131415&lt;VirtualHost *:80&gt; ServerAdmin webmaster@dummy-host.example.com DocumentRoot "/usr/docs/dummy-host.example.com" ServerName dummy-host.example.com ErrorLog "/private/var/log/apache2/dummy-host.example.com-error_log" CustomLog "/private/var/log/apache2/dummy-host.example.com-access_log" common&lt;/VirtualHost&gt; &lt;VirtualHost *:80&gt; ServerAdmin webmaster@dummy-host2.example.com DocumentRoot "/usr/docs/dummy-host2.example.com" ServerName dummy-host2.example.com ErrorLog "/private/var/log/apache2/dummy-host2.example.com-error_log" CustomLog "/private/var/log/apache2/dummy-host2.example.com-access_log" common&lt;/VirtualHost&gt; 而实际上，这两个虚拟主机是不存在的，在没有配置任何其他虚拟主机时，可能会导致访问 http://localhost 时出现如下提示： 12ForbiddenYou don't have permission to access /index.php on this server 最简单的办法就是在它们每行前面加上#，注释掉，这样既能参考又不导致其他问题。 增加如下配置:123456&lt;VirtualHost *:80&gt; alias /Upload "/Users/hxz/workspace/ng-flow-2.6.1/samples/Upload" &lt;Directory "/Users/hxz/workspace/ng-flow-2.6.1/samples/Upload"&gt; Require all granted &lt;/Directory&gt;&lt;/VirtualHost&gt; 上面这个虚拟配置的作用是：将 /Upload 的访问路径映射到 /Users/hxz/workspace/ng-flow-2.6.1/samples/Upload目录。 如果不确定自己添加的配置是否合法，可用 sudo apachectl -t 测试下，例如： 123hxz@Mac-mini:~$ sudo apachectl -tAH00526: Syntax error on line 36 of /private/etc/apache2/extra/httpd-vhosts.conf:Illegal option FollowSymLinkss 有个“坑”如果出现下面这种错误信息：1[Fri Oct 16 15:20:43.568523 2015] [authz_core:error] [pid 13293] [client ::1:49853] AH01630: client denied by server configuration: /Users/hxz/workspace/ng-flow-2.6.1/samples/Upload/ 可能原因：apache 2.4 版本和 2.2 以前的版本，配置上有些许改动。具体 fix 方法： 将 &lt;/Directory&gt; 下面的 12Order allow,denyAllow from all 修改为： 1Require all granted 参考 http://note.rpsh.net/posts/2013/11/27/osx-10-9-apache-server-php-mysql/ http://stackoverflow.com/questions/18739764/how-to-set-up-a-virtual-host-on-apache-2-4-4-mac-nix http://stackoverflow.com/questions/11215283/alias-403-forbidden-with-apache]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>OSX</tag>
        <tag>Apache</tag>
        <tag>VirtualHost</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[很傻很天真]]></title>
    <url>%2F2015%2F10%2F13%2F%E5%BE%88%E5%82%BB%E5%BE%88%E5%A4%A9%E7%9C%9F%2F</url>
    <content type="text"><![CDATA[腾讯有个「万象鉴黄智能识别」系统来做黄色图片识别。号称是： 腾讯优图独创基于深度学习的图片鉴黄技术，为保障互联网健康助力。 有兴趣的，可以去自己体验下这神一般的鉴黄技术， 地址： http://www.qcloud.com/event/pd 小试牛刀有好事者上传一张其男性亲戚的仰泳照片（由于不想侵犯他隐私，打码），识别结果居然被算作「性感」，概率 73.847% …… 他已经报警了。 这是色情图片？！我觉得我真的忘了爱…… 连我们敬爱的长者也不放过…… 我上传了几张「德莱尼、血精灵与魅魔」主题的媾和图片，完全没有被识别出来。 可以肯定的是，图片的颜色在识别中占了比较大的权重。 它还会根据身体器官的暴露程度来识别： 米开朗基罗等哭晕在厕所…… 更搞笑的： 看来，这个鉴黄识别系统存在不少「错杀」和「漏杀」的算法漏洞，下面这画面太美，我不敢看： 很傻很天真体验过后，可以发现： 这是个目前看起来有点「naive（看不懂英文的念：拿衣服）」的产品 人工智能在当下，更现实的理解是：「智能不够，人工来凑」。 你可以小看腾讯在【智能】上的功力，但永远不要小看掌握着巨量用户行为数据、内容数据的腾讯在【人工智能】上的功力。 腾讯手里握的 QQ 和 微信两把大刷子，和 Facebook、微博等社交应用一样，海量的用户每天在这两个应用上发来发去的图片数以吨计，可以说这个世界的大多数图片，可能都经过了 QQ/微信的二次处理。 假以时日，在迭代若干个版本、搜集到足够多的训练数据与黑白名单之后，个人揣测，它大约会演变成这样： 在实际应用中的工作流程可能是这样： 正确的鉴黄应该用何种姿势？上面我们看到，基于「颜色＋器官」分布识别色情图片的算法并不靠谱，因为这些算法忽略了图片本身要传递的信息，而关注的是其他特征。 所以真正的鉴黄方法还需要配合搜索引擎，通过颜色形状识别和在线图片搜索后有该图片的网站的文字信息结合判断，这个图究竟是不是黄图。 首先，这套系统要能从图片中识别出能产生【黄】的源头，比如裸露的成年男人与女人、文章、链接与种子等等。因为这样才能过滤掉大家吐槽的加菲猫、塑雕人像、小孩等正常物体。 其次，这套系统必须能正确区分出「裸露」，用什么方法？黄色面积占比？那么黑白图片怎么搞？ 最后，对于有歧义的图片，至少能按照正常人的思维去进行歧义处理，比如： 成年男子穿着一个裸露面积超标但不露点的塑料女性人皮，这怎么算？ 小黄文怎么算？ 黄色视频的链接与种子怎么算？ 射在脸上的是牛奶怎么算？ AV 电影只露出女演员娇喘以及晃动的头部的片段怎么算？ 在这方面，腾讯，嗯，还有同样有类似业务的我司，都得虚心地跟谷歌学习下：Google 的神经网络生成图像 (Inceptionism) 是怎么做到的？ 顺带推荐下一个国外的鉴黄识别系统：https://isitporn.com/]]></content>
  </entry>
  <entry>
    <title><![CDATA[Angular HTML5 file upload]]></title>
    <url>%2F2015%2F10%2F12%2FAngular-HTML5-file-upload%2F</url>
    <content type="text"><![CDATA[A JavaScript + Angular.js library providing multiple simultaneous, stable, fault-tolerant and resumable/restartable file uploads via the HTML5 File API. features Multi file upload support Folder upload support(Chrome only) Darg &amp; Drop support Upload progress bar Cancelable uploads Pause/Resumable uploads Chunked uploads Cross-site uploads DemoYou can try it at:http://hxzqlh.com/Upload/ Files1234567891011121314151617181920212223├── README.md ├── chunk_temp_dir //chunked files will be uploaded here ├── index.html ├── js│ ├── angular.js │ ├── app.js│ ├── appController.js│ └── ng-flow-standalone.js├── src │ └── Flow│ ├── Autoloader.php│ ├── Basic.php│ ├── Config.php│ ├── ConfigInterface.php│ ├── File.php│ ├── FileLockException.php│ ├── FileOpenException.php│ ├── FustyRequest.php│ ├── Request.php│ ├── RequestInterface.php│ └── Uploader.php├── temp //uploaded files will be saved here└── upload.php How do I set it up with my server?Please read the How do I set it up with my server? section of https://github.com/flowjs/flow.js upload.php and src folder is a php implementation of server, you can rewrite to python or other languages. References flow.js ng-flow]]></content>
      <categories>
        <category>Front-end</category>
      </categories>
      <tags>
        <tag>Angular</tag>
        <tag>upload</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[长者如何从工程师成长为政治人]]></title>
    <url>%2F2015%2F10%2F11%2F%E9%95%BF%E8%80%85%E5%A6%82%E4%BD%95%E4%BB%8E%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%88%90%E9%95%BF%E4%B8%BA%E6%94%BF%E6%B2%BB%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[中央文献出版社曾在去年出版了《江在一机部（1970-1980）》一书，讲述了江在第一机械工业部工作的10年时光。他先后担任援助罗马尼亚考察组总组长、外事局副局长、局长。这是中国机械工业发展的关键10年，也是江个人职业生涯的关键期：他从一名工程师逐渐成长为一名政治人，一个成熟的、带队伍的人。 中国援罗考察组总组长东方面孔，在1971年的罗马尼亚很罕见。 时隔43年后，当年的罗马尼亚大使馆经参处专员刘锡惠记得他在出口处等待长者的情形。 「一位东方人显得非常抢眼，他就是中国援罗考察组总组长江泽民同志。」刘锡惠在2014年3月底中央文献出版社出版的《江泽民在一机部（1970-1980）》一书中回忆道： 他记得这位一机部的援助罗马尼亚总组长显得意气风发，一套深色的西服，内搭花格领带，中等偏高的身材，瘦削的国字脸棱角分明，戴一副宽边大眼镜，腰板挺拔，步履稳健，装束得体。 1971年的中国，依然笼罩在「文革」的阴影下，国内几乎无人穿西装，即使是职业外交官，出国也多穿中山装。 此前的长者刚结束了几年近乎闲置的生活，「文革」开始之后，长者在一机部下属的武汉热工所工作了几年。这是一个从北京南迁的单位，长者则是从上海调过去工作，40多岁的人抛妻别子重新过上了单身宿舍生活，尽管是所长，他坚持要和几个年轻同事分享宿舍。 长者注重自己的仪表，曾经被朋友开玩笑说「大脑袋小梳子」，他大方地回答「爱美是人的天性」。 红卫兵一度指责他「资产阶级生活方式」，他愤怒地答道： 无稽之谈！我住的是宿舍。我的毯子都被虫子咬破了。我的公文包破烂不堪。你可以去查我的所有财产！ 长者在武汉被停职2年，其后又去「五七干校」的农场劳动1年，按要求养猪种小麦。在武汉热工所的4年，他权力被架空，大部分时间并未用来工作。 国务院总理周恩来视察工作时，长者不能参加接见，在宿舍里坐着，直到1970年之后，政治形势略有松动，才得以回到一机部机关。 这是长者刚刚从研究部门转向政府官员的第一站，刘锡惠和他握手的时候感到了他的活力，「他的手结实有力，眼神专注而真诚，一下子消除了彼此之间的陌生感」。 长者面临的是一份很难对付的工作—中国援罗马尼亚考察组总组长。1970年代，罗马尼亚领导人齐奥塞斯库和苏联的关系恶化，逐渐转向和中国、南斯拉夫等国家寻求友谊。 长者此行是对罗方进行考察，推行中国对罗方开展的全套项目援助，帮助罗方建立独立的工业体系。 一机部选择了长者负责这个项目，之前他曾带队参加过国际电工委员会在法国的会议，当时印度总理尼赫鲁病逝，会议提议对尼赫鲁默哀，但中国和印度之间处于边境战争的局面。长者让大家起立，但没有低头。这个安排回国后被主管外事工作的廖承志表扬，认为应对得体。 一机部受命给罗马尼亚援建的项目中，有几个汽车模具厂，长者曾经在一汽工作多年。 当时的「一机部」是第一机械工业部的简称，这个主管中国民用机械、电信、船舶工业的部门成立于1952年，脱胎于中国重工业部。在计划经济时代，这个国家一度有8个机械工业部，大部分用于发展军事工业。 长者很早进入一机部。1962年，36岁的他在一机部上海电器科学研究所担任副所长；4年后，他又被调到武汉担任热工机械研究所所长、代理党委书记。 在《他改变了中国：江泽民传》的作者库恩看来，1970年回到一机部，意味着他「23年的一线工作经历」和「基层时期」阶段结束了。 被重用的人长者受到重用之前坐了几年的冷板凳，不荒废业务、不撂下外语，让他在机会来的时候能一把抓住。 「负责人必须具有较强的组织领导能力，业务水平高、知识面广、懂外语」，这是一机部对援罗项目考察组总组长人选的要求。对外成套项目援助步骤众多，包括项目选址、生产纲要、技术目标、生产工艺等，并签订会谈纪要，项目实施效果最终会影响到受援国的利益和中国的脸面。 长者这位上海交通大学电机系毕业生被认为是「最合适的人」。 根据库恩《长者传》的记录，益民食品一厂的党代表、副工程师长者在1949年9月接待了来视察的汪道涵（华东工业部部长）。汪道涵发现这家「陈旧但十分整洁的」乳品厂到处「散发着新鲜冰激凌的香味」。 1954年，长者被调往长春第一汽车制造厂工作。其后他被派往俄罗斯在莫斯科斯大林汽车厂实习。这是他最早的外事工作经历，他的俄语水平在此期间也突飞猛进。 长者在莫斯科逮着机会就跟人讲俄语—这是他学习外语的方法，即多说多听，从来不担心露怯。他看了很多俄文原著，甚至爱上了俄罗斯的「黑列巴」—在大多数俄罗斯人眼中，黑面包比白面包好吃。 这个人的性格似乎也特别适合跟人打交道，他从9岁就开始学习英语，喜好学新的外语（除了日语，他的日语成绩是勉强过关，他把这种成绩归结为被在沦陷区被强迫学日语所致），这使得长者成为援建罗马尼亚的合适人选。 江家人以快速适应环境为荣。长者的妹妹江泽慧考大学时，所填志愿皆未能如愿，最后调剂到安徽农业大学主修林业学。这令一心想学心理学和哲学的她颇为痛苦。 「中国有句老话，叫做‘三百六十行，行行出状元’。」长者写信鼓励妹妹尽快适应环境，「你绝对应该去，而且要成为林业学方面的权威。」 人到中年的长者也在尽力适应完全不熟悉的罗马尼亚，他利用在罗考察的时间系统自学了罗语，据说他在和罗马尼亚方谈判期间达到了可以不用翻译的程度（偶尔说英语或者俄语）。 长者曾经请布加勒斯特大学的学生过来充当翻译，但他们碰到专业的词汇就卡壳。江由此萌生了自己学习的想法。他利用一切空闲时间背词汇，晚上学习到很晚。「无论吃饭、散步、坐车」，他都随身携带罗语词典。 产品经理罗马尼亚这个「客户」口味比较高，他们要的东西都是最好的。长者必须在他们「点菜」需求和一机部的「上菜」能力之间平衡。 罗马尼亚是一个「见过大世面」的欧洲国家。 论综合国力来说，在华约阵营中仅在苏联、捷克、波兰之后，虽然是个农业国，但一直有油井和炼油工业，当年希特勒和斯大林两军对垒，曾经分兵保护罗马尼亚的油井。 有出口石油换取工业制品的能力，罗马尼亚一直在直接进口欧洲的工业设备。中国设备在很多方面都不如罗得到的设备。 长者在刚下飞机到布加勒斯特乘车穿过市中心时，看见穿越市区的登博维察河和秀丽的风景、十几层的白色楼房，当场感叹道：「我们国家要是这么发达，那该多好啊！」 罗方对中方的援助提出了很多要求，比如需要提供跟欧洲同样标准的机械；项目不必成套，某些程序可以由罗方自己完成。 长者敏锐地觉察到罗马尼亚是跟中国以往的一些援助国，比如朝鲜、阿尔巴尼亚等是不一样的，这对援助方中国提出了更高的要求，「套餐」变成了「点菜」。 这不是一个上什么吃什么的客户。 长者认为必须根据受援国家的变化，将援助模式进行有针对性的改变，如果不调整，罗方不接受，项目有可能会就此胎死腹中，伤的可能就是两国的和气。 1971年10月，长者回到国内，陪同他的就是中国驻罗经济专员刘锡惠。援外处工作失误，忘了找人接机，他落地后给对外组干部陈仁慧打电话，说行李太多，希望来个车接一下。 陈仁慧回忆，当时只能找到一辆破旧的面包车，把长者从机场接到了一机部汽车局大院的职工集体宿舍。 他们找到时任一机部副部长周子健。长者当面提出，援罗不能照搬其他国家的模式，而应该调整。 「你小长者不知道部里这个底线吗？你不要把事情办砸了。」周子健急了。 「部长，请您先听我把话说完，再发火也不迟啊。」江坚持将其在罗马尼亚考察所碰到的新情况新问题进行了汇报。周对江的建议给予了肯定，让其起草报告，上报部党的核心小组进行研究。 这一「火花四射」的交锋过程令一旁的刘锡惠对江顿生敬佩：「泽民同志，我很佩服你，不惧怕领导批评，敢坚持原则，不怕丢乌纱帽。」 长者对问题的概括能力很强，他对罗马尼亚的工业水平这样评价道：「罗工业具有一定水平，罗方要求我援建的项目主要是为了填平补齐……罗的土建公用设计水平较高……施工速度很快。」 这些报告也说服了外经部部长方毅。方毅和长者不熟，过去一直熟悉的都是对第三世界国家的援助方式，他改变了自己的看法，被长者说服，他评论长者「真是不简单，有充分依据」和「极端负责」。 罗方提出的一些高要求加速了国内设计部门企业对产品的改造升级；而且在与罗接触期间，中方也趁机接触到欧洲国家的一些先进的设备和技术，对中方也是大有裨益的。 1972年2月，他写下长达18000字的援罗工作考察汇报，对援罗工作的体会和经历进行总结，并提出问题和建议。其后援罗项目的谈判和实施，他都适时跟进。所有援罗项目从1976年开始逐步投产，大部分项目基本在1984年就完工。 带队伍的人这个人教育年轻人多学习，少搞运动，他眼中的国家也该如此。 长者在罗马尼亚期间走访了各大城市和乡村，在他刚刚写完第二份考察报告之后两天，一架飞机坠毁在内蒙古温都尔汗。乘坐这趟飞机的是时任中共中央副主席林彪、妻子叶群和儿子林立果等，「九·一三」事件发生。 在国内的人们困惑无助的同时，援罗总组长长者努力地在援罗工作中排除极左影响。当时的考察组中，有一些专家热衷于「文革」那一套，在罗沿用国内军队连、营、团的称谓，令罗方不解，甚至引来不满。长者发现后，告诉专家们其中引发的误会，及时进行调整。 援罗首个项目考察组汽车模具厂考察组在进行方案讨论时，产生了矛盾：彼此你说你的，我说我的，谁也不服谁，甚至吵架、拍桌子。而罗方工作人员就住在隔壁。 得知消息的长者利用周末赶到考察组居住的小山庄。他跟考察组的成员聊天，散步。晚上吃饭的时候，他和专家们吃烤鱼，有说有笑。后来考察组再也没有出现过吵架。他就这样化解了彼此之间的矛盾，成为公认的「做思想政治工作高手」。 长者喜欢接受西餐，罗马尼亚当地的特色饮食—山羊奶酪和玉米面做的食物，他都乐于尝试，但是对不能欣赏本地食物的同事的胃，他也努力照顾。 在罗马尼亚考察的一名童姓工程师遭遇车祸，撞掉4颗门牙，被送往医院住院。童不懂罗语，无法与医护人员沟通。长者为此特别编制了一份常用中罗文词汇表，比如「牛奶」、「茶」「喝水」、「去卫生间」，解决了童的日常生活需求。童不喜西餐，他就每天坚持给童送鸡汤。他曾为生病的同事到大使馆找咸菜，但没找到。 繁忙的工作让长者一度卧病在床。一机部对外组负责人张剑飞只得以组织的名义写信给他让他多休息。 1972年底，因为援罗考察项目得以出色完成，江泽明被调到一机部外事局工作；1973年3月，他成为副局长；两年后又升任局长。 对长者来说，对外援助是他不太熟悉的领域，但勤奋工作，不忘学习，与人团结，关心人才，是他在每一段工作经历中贯彻的几大要素。 在一机部外事局局长任上的长者制定了很多外事工作方面的管理条例和办法，从出国审查到礼品赠送，外事工作变得透明化、制度化。 见识了罗马尼亚值得中国学习的方面之后，长者建议一机部在中国驻外使馆派驻科技干部。这是一件创举。1974年，一机部向驻法英西德意大利和瑞典派驻了5名科技干部。他们在国外开展科技调研，搜集工业信息，给国内带来不少有价值的科技资料和科技发展动向。后来成为国务院副总理的曾培炎就是当年「科技干部」当中的一员。 外事局工作期间，长者仍会尽量保护同事，1976年，各单位被命令「清查」参加「四五事件」的参与者时，长者尽力做到「大事化小、小事化了」。 早在武汉热工所工作时，有年轻人要去看街头派系武斗。长者劝告所里的年轻人，「不要上街，多学习钻研业务」。他还为所里的青年开办了英语和日语培训班。 武汉热工所其实是隶属于一机部的原子能设备制造所。核工程也是长者不熟悉的领域，为了尽快地熟悉专业，每天除了工作和运动之外，就是进行学习。 「他天天晚上在办公室学习到很晚才回来睡觉。他系统地读完了格拉斯登编著的长达300多页的核工程教程。」《长者同志在武汉热工所》一书中写道。 丁瑞芝是长者在热工所的老同事。在他眼中，长者勤于学习，善于钻研，是专家型领导。「每次出差途中，总看到他捧着一台在国外参加会议时买的半导体收音机，收听中央台的对外外语广播。」丁瑞芝回忆道，「他还总是利用出差的机会，尽可能多地参观、学习有关科技项目。」 长者在担任最高领导人之后，甚至开始学习西班牙语。在一次访问智利的行程中，75岁的他用西班牙语进行了长达40分钟的演讲。 在调任电子工业部后，长者同样利用业余时间学习电子学速成课程。他在接受采访时向记者透露，「作为一个知识分子，我喜欢读书，我阅读与我工作有关的东西，一是机械，二是电子……在工作中学习是我的习惯。」 爱惜人才的长者曾经在一汽工作时，重用一位一直坐冷板凳的工程师—因为其父亲开了一间小商店，被认为是资本家。 「他父亲怎么样跟他无关。」在长者的支持下，这个工程师后来做出了重要贡献，并多次获奖。 「长者本人不是最有才能的开发人员，但他了解和赏识其他人的才干。」库恩在《江泽民传》中援引一位与他共事的人的话说，「他挖掘出了每个人的潜能，那可不是一件容易的事。」 他已经逐步转向成一个成熟的、带队伍的人。 收获人脉的10年汪道涵把长者带进了一机部，长者在那里收获了很多日后的合作伙伴。 当长者在一机部内获得晋升时，他的良师益友汪道涵正被贬谪家中。「文革」开始后，汪道涵被迫赋闲。 这位赏识长者的领导成为一机部副部长之后，长者随之进入一机部上海第二设计分局电器专业科科长。「对他而言，这是一次改变人生的任职。他至此进入到北京管理的干部序列。」曾有公开报道这样评价。 汪道涵发现自己和长者的养父江上青有旧，抗战时期，江上青在安徽做统战工作，打入国民党安徽省第六行政区任督察专员、公署秘书，在党内是「皖东北特派员」。 根据江上青的请求，上海地下党派了一批城市地下党员，充实到第六行政区所属的县里任党政职务，汪道涵即被委任为中共嘉山县委书记。 江上青长汪道涵4岁，1939年江上青战死，汪曾为其修建了烈士墓。 除了这段溯及父辈的缘分，汪道涵和长者二人诸多的共同之处令二人颇为惺惺相惜。汪道涵是安徽人，江家祖上从安徽搬去扬州，两人都毕业于上海交大，二人都曾从事地下工作。汪道涵的夫人一度是长者所在的益民公司的董事长。 「他们越来越熟悉，长者成为汪家的常客，他们把江当小弟弟看待。」《长者传》中，库恩写道。 「文革」之后，汪道涵失去了庇护长者的能力。长者经常去探望汪。这对他来说是有一定风险的。而他的妻子王冶平也在上海照顾和保护着汪道涵的女儿。 曾培炎曾和长者一起在上海的电器科学研究所共事过，在那里，担任所长的长者曾经亲自指挥了一个大工程，把一座混凝土房子连底顶起来，放在几十只弹簧上。这样建成的房子作为噪音室，可以排除其他来自地面的声音干扰。 清华电子学系毕业的曾培炎曾经回忆过自己和长者共事的那段时光，他比长者小十几岁，江是他走入社会后的第一任单位领导。 在曾培炎的记忆中，长者的讲话风格和日后他担任最高领导人时很像。「讲到关键的地方，他会插一点方言，比如四川话，说得挺像，也经常英文讲几句，有时还引用唐诗宋词，他小时候读过，随口就来，把大家的精神提振一下。」 曾培炎后来随整流器室搬迁到西安，到后来在上海和北京筹办会议时，和长者一起共事很长时间。 「我们一起住集体宿舍、挤公交车、到食堂排队买饭，抢着去锅炉房打开水，就是起草文件、写总结报告也总是和大家分担一部分。我们都是离家长期出差在外，他却经常关心别人，问有何具体困难。同长者同志在一起，一点看不出他是一个领导干部，没有一点架子，总能使人感到同志加兄弟般的温暖。」 在江的推荐下，曾培炎于1982年被派驻中国驻美使馆担任科技干部，后来成为国家领导人之一。另一位国务院副总理邹家华也曾经有多年的一机部工作经历。 1976年，「四人帮」倒台，长者在这年离开北京到上海协助恢复秩序。形势看起来似乎依然晦暗不明。华国锋提出了两个「凡是」。1977年2月，长者到「五七干校」劳动了4个月。 在那里长者拔草平地施肥浇水，清理猪圈，像农民一样蹲在地上，用粗糙的饭碗吃面条。6月，他回到北京一机部。库恩写道，这位50岁的局级干部甚至考虑离开政府到母校去任教。为此还向以前的合作伙伴找自己当年译作的手稿—他准备写论文。 这个打算随着1978年十一届三中全会的召开而被取消。 被重新起用的汪道涵找到国家进出口管理委员会、国家外国投资管理委员主任、国务院副总理谷牧，向他推荐了长者。长者在外事领域长达10年的工作经历是有力的竞争砝码。 1980年，54岁的长者开始担任国家进出口管理委员会、国家外国投资管理委员会副主任兼秘书长，这是副部级职位，在诸多被平反的老干部恢复职务的时候，年轻干部要获得任命需要表现得更加出色。 他在一机部10年的任职经历，都是对外，为他后来进入两个管理委员会、中国改革开放搞特区的工作衔接起来了。这段时间的经历为他进行改革开放方面的工作积累了经验。 这本书的前言和后记中提到： 长者同志在对外经济技术援助、对外科技合作及技术引进方面进行了创造性探索，做出了特殊贡献。这段岁月里，长者同志出色地完成了从工程师到政治家角色的转变，为进一步走向更高领导岗位奠定了坚实的基础。 国家进出口管理委员会、国家外国投资管理委员会这两个部级机构是1979年4月，邓小平提议设立「经济特区」之后，应运而生贯彻邓的改革的。 长者获得的这两个副主任职务使得他成了邓的提议的执行者和贯彻者，一机部的10年政治人新手生涯宣告结束，长者迈入了中国高级官员的行列，他带着10年的眼界、见识和珍贵的人脉关系，走向了更高的职位。]]></content>
  </entry>
  <entry>
    <title><![CDATA[「射雕三部曲」前传]]></title>
    <url>%2F2015%2F10%2F10%2F%E3%80%8C%E5%B0%84%E9%9B%95%E4%B8%89%E9%83%A8%E6%9B%B2%E3%80%8D%E5%89%8D%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[从《射雕英雄传》到《神雕侠侣》，再到《倚天屠龙记》，其实它们不是整个系列剧情的第一、二、三部，而是第二、三、四部。 而真正的第一部，一直都藏在暗中。 公元12世纪初叶，处北宋政和年间。徽宗皇帝继位未久，下令遍搜天下道书，并命黄裳主持编刻发行。黄裳受任数年间细读道书，偶然悟得上乘武功。 徽宗喜求道，擅书法，治国无方，重用蔡京等佞臣。对外，徽宗与蔡京等人谋划与金国夹击日衰的辽国，宋军大败而归。对内，蔡京等人祸国乱政，民不聊生，义兵四起。 此间，自唐朝时由波斯传入中土的摩尼教日盛，此时名为「明教」。明教鼓励受压迫民众以暴力抗法，而非原有官方所宣儒道佛门的逆来顺受。如此行侠仗义，颇得武林各大正派之心，于是各派中，多有年轻后辈加入明教。 而徽宗治下的北宋朝廷对外战败，对内加赋，民变渐渐积小成大。明教教主方腊，带同教众于吴越之地起事，一时势大，与梁山、王庆、田虎三支义军齐名。起事之地，处于黄裳治下，黄裳当年便数次袭击明教义军，杀法王、使者等教内高手数人。 徽宗察觉明教的威胁，将之定为邪教，并于第二年令童贯率十五万军征讨方腊义军。此前梁山义军已受招安，摇身一变成为官军，并已替朝廷灭了王庆、田虎两只起义军。此役，梁山军作为童贯大军先锋征讨方腊义军，黄裳率地方军策应。 此前明教已有诸多顶尖高手被黄裳击杀，军力虽然日盛，但总坛实力锐减。最终帮源洞一役，在黄裳缺席下，宋将韩世忠率一众军中高手与梁山高手攻入义军总部。明教教主方腊虽一人武勇，奈何诸多高手围攻，血战弥久，终被武松、鲁智深合力所擒。 方腊义军就此被扑灭，经此一役，明教一时式微，活动转入地下，总坛迁至西域昆仑光明顶。不久后，武林各大门派遣出多名高手围攻黄裳，为门下投入明教而为黄裳所戮的弟子报仇。黄裳寡不敌众，杀得数人后，重伤逃入深山，而黄裳满门被武林「正派」高手们尽数屠戮。 匿于深山之中，黄裳苦苦思索各派仇家武功，谋求破解之法，春去秋来，年年雪花不同。就在黄裳隐居期间，靖康之变发生，金国先灭辽，再灭北宋，掳走徽宗钦宗等皇族主脉。康王赵构幸免遇难，召集北宋余下散兵败将，沿淮河往南，恢复宋朝正统，并定都临安，为南宋。 南宋建朝后，岳飞、韩世忠等中兴四将北伐金国，颇有战果，岳飞日渐功高盖主。未数年，高宗与秦桧密谋与金国媾和，岳飞被陷害入狱，不幸于风波亭遇害。岳飞临终前，留下兵法遗书一部，并在书中勉励后人忠义报国，此书被收入宫中。 北伐大业远去，中兴四将死的死、老的老，韩世忠携梁红玉归隐西湖。原韩世忠部将上官剑南，此时已投入铁掌帮，并凭自身才干成为帮主。听闻岳飞遇害留书，上官剑南夜闯皇宫盗书，成功后将书献与韩世忠。 韩世忠年老心衰，与上官剑南商议暂将此书暗藏，等待后世英杰出现。上官剑南作诗「武穆遗书，在铁掌山，中指峰上，第二指节」，并附铁掌山画与岳飞诗作于纸上。此后上官剑南再入皇宫，将带有线索的纸卷留在原存遗书之处，等待将来的取书者发现。 此时黄裳已隐居二十余年，各正派年轻高手先被黄裳屠戮，复在天下大乱中丧生不少，武林衰微。河朔剑术高手独孤氏，于此二十年间日渐成长，在岳飞入狱那年创出「独孤九剑」。此后独孤氏持玄铁剑横扫天下，难觅敌手，自号「独孤求败」，寂寞惫懒，隐居山林与巨雕习剑。 又二十余年之后，黄裳终于尽破各派武功，自身所研习的武学大成，遂出山复仇。然则不想，距其入山隐居已过四十余年，大多数仇家均已故去，唯余一女，当年花季，已变花甲。黄裳有所悟，复仇心遂淡去。 此时黄裳亦年事已高，将毕生武功录下，编成《九阴真经》上下两部。因书中武功过于高妙，恐落于歹人之手而为恶，遂将总纲改写为难译的梵音汉文。复十余年，黄裳故去，而他留下的《九阴真经》成为武林中人抢夺之的，一时掀起无数腥风血雨。 独孤求败也在襄阳以北的深山中孤独的故去了。临终前，他将自己毕生所用之剑均存于高崖之上，为剑冢，而剑法秘籍另存。以短短数句话总结自己一生，刻于剑冢，以长抒自己毕生难求一败之遗憾。 而此二、三十年间，上官剑南中兴铁掌帮，使之成为与北方丐帮齐名的天下大帮。上官剑南晚年时，门下弟子收下一名幼徒，姓裘名千仞，武学天赋出众，才能机智过人。上官剑南等对裘千仞悉心培养，将自己改进后的铁掌功夫尽数传授，欲将之培养为接班人。 此时距方腊遇难、黄裳入山隐居已过五十年，黄裳、独孤求败均已故去，武林式微至极而始返。咸阳义士王喆，从大概岳飞遇害二十余年后时，开始在北方率民举义。王喆其人本为武林中年轻一辈的奇才高手，举义后一时聚拢了众多武林人士。 然义军在金国后方征战二十年，败多胜少，武林高手难敌大兵战阵，王喆虽武勇，却是难以回天。起兵二十年后，义军终于覆灭，王喆藏入在钟南山的地下基地，自名「活死人」，自谓居「活死人墓」。而后他终被多年相知的好友，女侠林朝英所激出墓。 王喆举义多年，一直与林朝英通过书信互通有无，二人感情笃厚，林氏颇有相从之意。然则王喆初时心系战事，义兵兵败后心灰意冷，而二人均心气高傲，于武学修为上互不相下。最终二人终于鸳盟未成，王喆将活死人墓让于林氏居住，自己却出家于钟南山前。 王喆此时自取道号「重阳」，从此名王重阳，在终南山上建重阳宫，手创道门新派全真教。初时跟随者，唯有好友师弟周伯通，与多年来收入门下的七大弟子而已。七大弟子学艺未成而闯荡江湖，行侠仗义，创下「全真七子」的名号。 王重阳手创全真教不久，少林寺遭际大变，一名火工头陀偷学武功多年后，造反大闹少林。火工头陀最终杀得数人后匿走，逃至西域，自行收徒立派。而少林苦慧禅师一怒之下，也去寺远走西域，手创西域少林，从此中原少林派衰微达数十年。 创全真数年后，王重阳偶然得到了黄裳留下的《九阴真经》，他武功本已高绝，从此更加精进。一日，与某无名云游僧人斗酒比武，论证《九阴真经》，无名僧人受到启发，创《九阳真经》。日后此僧于少林寺挂单期间，将手书的《九阳真经》藏入《楞伽经》，并假托为达摩祖师所作。 而林朝英隐居于钟南山后，毕生情愫难抒，爱极成恨，创下一系列克制全真武功的功夫。隐居十余年后，林朝英故去，仅留下一名丫鬟，五口棺材，以及满墓的武功墓刻。王重阳数次秘入古墓，尽知林氏所为，心中有愧，却将《九阴真经》中的部分武功刻于古墓示胜。 此时距离方腊遇难、黄裳隐居已过近八十年，距岳飞遇难近六十年，距王重阳出家近二十年。武林元气渐渐恢复，少林派虽衰微，江湖上却涌现出黄药师、洪七公、欧阳锋、裘千仞等高手。而西南大理国，已是段誉之孙段智兴在位年间，段智兴武学上虽未达祖父之就，亦颇有所成。 王重阳此时年事颇高，自觉不久于人世，却不愿《九阴真经》在自己死后继续危害武林。遂遍洒英雄帖，召集当世年轻英豪至华山绝顶比武，约定胜者得书，以正自己存书之名。黄药师、洪七公、欧阳锋、段智兴四人如约前来，而裘千仞功夫未成，自知不敌而婉拒。 华山绝顶之上，五人两两捉对，较量七日七夜，终究是王重阳技高一筹，其余四人拜服。从此王重阳名正言顺的保有《九阴真经》，此次校武也被后人称为「第一次华山论剑」。王重阳被称为中神通，余者为东邪黄药师、西毒欧阳锋、南帝段皇爷、北丐洪七公，称当世五绝。 王重阳察言观色，知洪、段二人心正，而黄虽邪而不恶，唯有西毒欧阳心术不正。为防自己身后，西毒盗取《九阴真经》为害，王重阳南赴大理，与南帝互传克制西毒的武功。此期间，随行的周伯通与南帝妃子瑛姑私通，酿下大祸，日后成为无数恩怨的源头。 返回钟南山后，王重阳诈死，骗得埋伏在周围的西毒，而王重阳骤起而以一阳指破了西毒蛤蟆功。西毒功破逃走，而王重阳灯枯油竭，真的就此仙去，留下了一部不愿毁去的《九阴真经》。随后周伯通外出藏书，被黄药师夫妇所骗，黄药师终也得到了一部《九阴真经》抄本。 为了在约定的时隔二十五年的第二次华山论剑上得胜，余下的东西南北四绝均倾尽全力的修炼。西毒与裘千仞暗通，设下毒计陷害南帝：裘千仞潜入大理将南帝的「幼子」打伤，引南帝毁功施救。谁知这「幼子」竟是瑛姑与周伯通所生，南帝不愿施救，幼子亡，瑛姑愤而出走，南帝愧而出家。 此际，黄药师隐居的桃花岛上也现巨变，其二徒陈玄风与三徒梅超风私通，偷《九阴真经》逃走。黄药师激怒之下自毁长城，将余下四徒曲灵风、陆乘风、武眠风、冯默风的武功俱废，赶出门外。黄药师妻子生女黄蓉难产，逢此变，又耗尽心力重默了一遍《九阴真经》，终因心力耗竭而亡。 而数年后，周伯通反应过来被黄氏夫妇所骗，上桃花岛寻黄药师索要经书抄本。二人一言不合，黄药师将丧妻之痛转而发泄在周伯通身上，周伯通受伤躲入山洞，二人僵持不下。从此黄药师与周伯通，以是否出洞为鉴别，打赌争胜负，二人洞里洞外，斗上了十余年。 此时，距方腊遇害九十年，距王重阳创立全真教三十年，距第一次华山论剑事过十年。王重阳林朝英已故，全真教在全真七子治下愈发昌盛，与洪七公治下的丐帮呼应，控制北方武林。黄药师一门已毁，与周伯通赌气，而南帝心冷出家，裘千仞则心术渐歪，率铁掌帮私通金国。 五绝行踪隐匿，少林派式微，明教西逃，武林中一时无大事。而南宋保得八十年的安宁岁月，北方金国虽虎视眈眈，但一时未曾南下。南宋朝廷陷于安逸，日益腐朽，向金国献媚，金国虽不敢大兵南下，铁骑亦也蹂躏了南宋边境。 这拢共近百年间，武林亦曾昌盛，然则天下陡变，大宋国势不振，屡遭北方游牧民族蹂躏。武林绝顶高手屡次出现，从黄裳、方腊、独孤求败，到王重阳、林朝英、无名僧。甚至还有南宋朝廷中的暗藏高手，手创《葵花宝典》的某无名太监。 留下的顶尖武功秘籍之多，亦是各代之最。从《九阴真经》到《独孤九剑》，从《九阳真经》到《葵花宝典》。然而再昌盛的武林，再顶尖的高手和秘籍，也无法挽回天下大势。 宋朝国力其实甚强，军力也非羸弱，但腐败之下，竟是无法抵挡外敌。一代代武林高手投身于救国救民或抗金大业之中，然则均以失败告终。随着高手们次第故去，武林一时无事，而更加磅礴的故事与历史，已在水下酝酿成熟，即将发生。 这就是《射雕三部曲》系列中，暗藏的真正的第一部。这等磅礴的背景，丰满的故事，跌宕的情节，完全可以独立成篇，丝毫不逊于三部曲。然而金庸却没有将之写出来，而只将这些情节隐藏入了以《射雕三部曲》为首的其他著作中，从不同的后世人物的口中，或是从旁白口中，回忆和转述出了这些剧情。 不止是《射雕三部曲》，其他的著作中也有类似的情况。《书剑恩仇录》开篇剧情之前，就已经发生了宫闱之变，乾隆被掉包等诸多重要剧情。《碧血剑》一书，真正的主角袁崇焕和金蛇郎君，在主线剧情开始前均已故去。《天龙八部》中，主线剧情之前，萧远山遇刺，段正淳滥情，段延庆失位，叶二娘情殇。《侠客行》中，从龙木二岛主到赏善罚恶二使，大量重要情节都发生在主线之前。《笑傲江湖》更不必说，全书主线基本都与数十年前华山派与魔教争抢的《葵花宝典》有关。《鹿鼎记》在剧情上承接《碧血剑》，但两书主线之间，也跳过了大量后来回忆出的重要剧情。 为什么总是不写？为什么总是前置隐藏剧情？金庸写书，总像是在一个宏大的历史线条中，截取其中一段。以真混假，以假乱真。越是主线人物和剧情，描写越细致，虚构也越夸张；越是次要人物和剧情，描写越粗略，也越贴近史实。 而只在一条漫长的历史线上，截取一小段作为主线剧情时间的手法，并没有使作品显得不够丰满。恰恰相反，金庸的这种手法使得整个故事更加引人入胜，更加有无限背景的神秘感，让人对其背后宏大的历史背景更感到畏惧和崇敬。 《射雕三部曲》最终只有三部，而藏匿了「真正的第一部」。从某种意义上，说这种藏匿手法使得整部系列剧情的境界，更上了一个台阶，也许也不为过。 这第一部的缺失，确是神来之笔。 前传拍成电影，估计会很好看吧，你说呢？]]></content>
  </entry>
  <entry>
    <title><![CDATA[乙未国庆赋]]></title>
    <url>%2F2015%2F10%2F07%2F%E4%B9%99%E6%9C%AA%E5%9B%BD%E5%BA%86%E8%B5%8B%2F</url>
    <content type="text"><![CDATA[岁在乙未，斯为国庆；节在清秋，九州欢情。 行路难兮，万车皆停；瞻彼大道，寸步不行。 忆昔股市，鲜血淋淋；割肉未已，赴彼东瀛。 新宿涩谷，战战兢兢；京都大阪，皆闻汉音。 九龙港岛，乏人问津；昨岁熙熙，今朝凄清。 呦呦食蒿，久传香馨；屠师获奖，且疑且庆。 虽有坎壈，不失太平；唯彼飓风，摧城伤民。 明日在迩，闹钟调鸣；身虽归来，心犹远行。 假不在长，七天则行；明年再来，说好再拼。]]></content>
  </entry>
  <entry>
    <title><![CDATA[为什么说长者是一个才华洋溢的人]]></title>
    <url>%2F2015%2F10%2F01%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E9%95%BF%E8%80%85%E6%98%AF%E4%B8%80%E4%B8%AA%E6%89%8D%E5%8D%8E%E6%B4%8B%E6%BA%A2%E7%9A%84%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[1985年的夏天，上海，江在音乐厅欣赏上海交响乐团的演出，当时江的头发依然乌黑，整齐地向后梳着，看起来精神矍铄，手情不自禁地在比划着，在音乐会休息时，江充满激情地说： 一个城市的交响乐水平标志着这个城市的文明程度。 彼时江刚刚上任上海市长，主政这座曾经的东方巴黎，而在同一个夏末，8月17日，上海往东800多公里的福冈县，苍井优出生，这一天出生的狮子男女们仿若都自带文艺气息，除了苍井优还有西恩•潘和罗伯特•德尼罗，当然还有江。 江的乐器谱时间倒回至1926年的8月17日，上海西北约200多公里的里下河平原，江出生在扬州当地一个优渥的家庭。扬州城中田家巷里有一座中间带有天井的传统中式大院，房子上面有着精美的石刻，这是江祖父一手打造的大家庭的院落。其祖父擅长诗文、书画、音乐，尤精箫笛、昆曲、山水画，其父和几位叔叔均学养深厚，多才多艺，完善的教育和叔伯们的熏陶使得他从小便兼顾了现代科学和传统文艺两方面完备的教育。 钢琴江在乐器演奏方面很有天赋。大学时期，「人们常常看到他在钢琴上敲打，俯身二胡拉唱，或者为抗议人群的高歌猛进做即兴指挥」江虽然从小学习钢琴，并颇为拿手，但直到上海任职时，才由妻子买了一台聂耳牌钢琴送给他。长期对钢琴的匮乏影响了江，他总是试图去接触「大家」的钢琴。 96年，在挪威卑尔根参观著名作曲家格里格的故居时，江坐在格里格当年谱曲用的钢琴前弹奏起《黄水谣》和北美民歌《红河谷》。 99年，奥地利萨尔茨堡市马卡特广场的莫扎特旧居，江走到莫扎特曾经谱曲的钢琴前说：「我想在莫扎特曾经使用过的钢琴上演奏一首描述丰收美景的中国湖北民歌《洪湖水浪打浪》，以表达一位万里之外的中国音乐爱好者对他的崇敬。」在哈萨克斯坦的冼星海旧居，江弹奏了他的《黄水谣》，江丝毫不掩饰对冼星海的喜爱，《黄水谣》是其最拿手的一首曲目。 在罗马尼亚，江还曾即兴用钢琴弹起罗马尼亚古曲《妈妈昨夜把家还》。 二胡大学时代，江的同学们演出小品剧时，江便给他们拉二胡伴奏，而在他任总书记后，他也没忘了这陪伴他一生的传统乐器，在其应金日成之邀访问朝鲜时，随身带的行李中，就有一把二胡。访问期间，偶得宽余，江就兴致勃勃地拉上一阵。 98年克林顿访华时，欢迎晚会结束后，江兴致盎然地从演员手里拿过二胡，拉了一曲美国民歌《稻草里的火鸡》。这次演奏不是江心血来潮，而是赴了五年之约，93年中美两国领导人某事之后在西雅图峰会第一次见面，江以音乐打破了尴尬，克林顿曾是萨克斯管业余乐手，江特地送了他一件中国制造的萨克斯管。江说，他也爱好音乐，但不会吹萨克斯管， 却会拉二胡。克林顿笑着说，「将来有机会，我吹给你听听」。江立即回答，「我可以拉二胡伴奏」。 笛子2001年，上合组织六国元首会议的演出上江与一位演员演奏了笛曲《梅花三弄》，这是这个国家的人民第一次公开见到领导人在表演自己的才艺，褪去了前两代革命领袖式政治家身上的卡利斯马人格，江试图用自己丰富的人格魅力来弥补自己的合法性。而梅花三弄，是江的保留笛曲，一年前，江在杭州一场音乐会后亦雅然地上台用笛子演奏了一曲《梅花三弄》。 88年的五一国际劳动节，江在上海市劳模大联欢上为大家表演了笛子演奏。当时一位记者在文章中记述了当时的场景： 只见市总工会主席江荣把笛子端给江，并关照工作人员拿些酒精来。「还要什么酒精，不用，不用。」江欣然端起笛子，似乎遇见了一位久违的伙伴。他用自己的手帕往笛子上擦了擦，就试吹了起来。 尤克里里尤克里里是门有故事的乐器，钢琴之外，大学时代江最早接触的西洋乐器就是夏威夷吉他，三四十年代，在南京及上海一些大学里，有很多夏威夷吉他社团，访美前半年，江便是托他大学同学在上海一家制造小提琴的乐器厂的仓库里找到了3把已损坏的夏威夷吉他，修好寄给了江，在夏威夷州长的欢迎宴会上，江主动向主人说起，他在交大念书的时候，曾学过一首夏威夷民歌，《alloha，hawaii》，并邀请曾是歌手的州长夫人伴唱，一时令美国人侧目。 此外，江还会演奏小提琴、管风琴、木琴。 95年，在赫尔辛基闻名欧洲的岩石教堂里，江即兴在管风琴上弹奏《黄水谣》，而管风琴被称为乐器之王。江还掌握了一门冷僻的乐器，道情筒，这是一种道教乐器，长约二尺，涂红漆，圆筒一头蒙上一张猪油皮。江退休后，曾回扬州唱了一段扬州道情，这是一种传统的地方曲艺，左手拿着类似快板的器具，右手拿着道情筒合拍而唱。当然，作为「二十四桥明月夜，玉人何处教吹箫」的扬凑人民，江还熟稔箫的吹奏。 江氏歌单江喜唱歌，嗓音浑厚，音质纯正，在江小时候，就经常在夏夜覆盖下的苏北稻花香里说丰年。出任要职后，他更多时候表现的像一名社会主义战士，挥舞着有力的手臂，指挥大家唱《歌唱祖国》，不管是在南加州指挥华侨还是在中南海指挥自己的同僚，江觉得这首歌能提振士气，这是他最喜欢的合唱曲目，他还与苏联老将军合唱《海港之夜》，在哈萨克斯坦演唱新疆民歌《可爱的玫瑰花》。 单曲方面，江最爱唱的是意大利歌曲《我的太阳》，在卡斯特罗面前、在布什夫妇面前、在同学聚会上，他多次用意大利语演唱这首歌。与喜欢的歌手见面是每一个小粉丝的愿望，江亦不例外，01年申奥前夕，北京，「三大男高音」在昔日皇家禁地为中国观众表演了一场盛大的音乐会。音乐会结束后，江特意宴请了三位歌手，面对帕瓦罗蒂，江丝毫没有怯场，与他合唱了《我的太阳》。 而当记者问帕瓦罗蒂，如果江主席改行当一个歌剧演员的话会怎么样。这位意大利超级巨星微笑着答道： 如果这个人能全心全意地表现自己，就算只在唱歌这件事上，他也肯定会成为一个巨星。 但接着他又补充了一句：「也许，他还需要练习。」 此外，江曾多次演唱过的还有约翰•施特劳斯作曲的《one day when we were young》，87年和97年两次访美，以及与老同学聚会时江都唱了这首歌，因为这是他们青年时喜欢的美国电影《翠堤春晓》里的一首插曲。99年江访问葡萄牙，唱了一首《教我如何不想她》，并即席唱出「微风吹动我的头发……」，引来全场一阵掌声。 江不认为在公开场合放声高歌有失体统，相反他觉得自己向世界展示了中国人性化的一面，中国的领导人是一个普通人，而不是一个皇帝。一个略显可笑的领导人要比一个骄傲自大、不近人情、自以为是的领导人好得多。 一个资深票友和曾经从沪到京一路搭班子的朱镕基一样，江亦深爱京剧，这个源自江祖籍地的戏种从江二十出头时就开始与其结缘。 97年访美时，在新老华侨和留学生中，江即兴演唱了捉放曹中的经典唱句「一轮明月照窗前」，而06年，在一群旧友中间他自拉自唱起了《捉放曹•宿店》。江的老同学补充了更多细节，「他特别喜欢京剧和歌咏，现在只要同学聚会，他都会唱上一段京剧片段，如《钓金龟》等名剧。」 在一汽的时候，江组织同事和当时援华的苏联专家开联欢会，江唱了拿手的京剧《四郎探母》，演出的时候，江把四郎「杨延辉」唱成了「杨延昭」，惹得同事一阵笑声，演出结束后江跟同事解释说「辉」字发音在俄文中是脏话，所以把「辉」改成了「昭」。东北的枯燥生活，使得江那段时间里一到晚上便从三楼宿舍跑到二楼唱上一段《捉放曹》以及《十五贯》，而后他甚至试图排练《天鹅湖》舞曲。 除了京剧，江对家乡的淮剧和昆剧亦情有独钟，江任上海市市长后，观看的第一部戏是淮剧，此后特意观看了昆剧《长生殿》的演出。而当中央歌剧院来上海汇演脍炙人口的歌剧《卡门》，江观看了首场演出。休息时，他绘声绘色地剖析了剧中主角吉普赛女朗卡门的个性和魅力，揭示了卡门鲜明而又复杂的性格，使在场的人惊讶不已。如果说在任内江有时还会迁就主旋律创作，去看《苍原》 《江姐》等特有的主旋律歌剧，退休后他便放任了自己对西洋歌剧的追求，他特别钟意意大利歌剧作曲家威尔第的作品。10年的6月，江在国家大剧院观看威尔第经典歌剧《茶花女》。 阳春白雪与流行文化1994年，这个文艺大年不仅仅是体现在罕见的电影佳作井喷式出现上，当年2月，江在在同山西劳动模范代表座谈时讲过这样一番话： 文化应该是丰富多彩的，能够满足人们多方面、多层次的需要。进行曲，战斗曲，小夜曲，抒情曲，都要有。 「既要有主旋律，又要多样化」，后来成为未来十年文化建设的基调。 江给予了艺术工作者很高的地位，他称艺术家为「灵魂的工程师」。他期望艺术家不仅要跟上世界先进文化的发展步伐，还要开拓和创新。他任内的文化部长孙家正曾发表了一篇讲话，指出中国电影不应该局限于现实生活中的英雄人物和全社会的模范人物。他说，「艺术家在选材时要有选择，要注重艺术性」。这席讲话在被意识形态裹挟的文化领域无疑是破天荒的。也是在那一年，中国终于开放了电影市场。这一年的年尾，中影公司在更高层级的首肯下，与美国片商完成了经年持久的谈判，开启了「进口分账大片」模式，好莱坞的电影自1949年之后，时隔45年重返中国大陆。 更多时间，这个苏北人在上海的几年扮演了一个更有腔调的人，他熟谙在这样的威权社会，一个领导人的审美会直接影响到普罗大众的审美，他像堂吉诃德一样一次次以一己之力努力提振这个城市的欣赏水平。 八十年代，江刚履新上海不久即授意市委办公厅和市委宣传部，为上海市二百多位局级以上领导干部举办音乐、戏剧、文学、艺术讲座，以提高他们的艺术欣赏能力，而讲座的第一课是《如何欣赏交响乐》。上海交响乐团赴北京调演，江除了拍电报祝贺外，还利用赴京开会的空隙，跑到北京音乐厅为乐团打气说：「交响乐代表了一个国家、一个城市的艺术水平，应该加以重视和扶持」。 88年7月，江出席贝多芬之魂交响音乐会，演出休息时，用外语同剧场内外宾交谈，介绍上海交响乐艺术，86年12月和87年2月他两次为上海交响乐团题词，86年8月15日为上海芭蕾舞团题词，88年11月会见北京人艺赴沪演出团，对大家说「我很喜欢话剧」。 江不认为古典音乐是阳春白雪，他甚至觉得中国的普通老百姓也可以接触古典音乐来陶冶情操，应予普及。在他的授意下，不到3个月时间，中央电视台就开播了一套新节目——第十五套。这套节目由一半中国古典音乐和一半外国古典音乐组合而成。基本是由中国交响乐团演奏的。节目开播时，江给当时的台长赵化勇打电话表示祝贺，说他已经欣赏了好几个小时了。在海南大学，面对围上来的学生，江作为长者给了他们一点人生经验，「学生应该具有广博的知识」，江提出忠告: 文学艺术，例如托尔斯泰、莎士比亚、巴尔扎克、但丁、莱昂纳多。达•芬奇的作品，可以提高你们的审美情趣，丰富你们的思想和生活。不要局限在你们的专业里面。 在江那里，良好的审美造就了宽容并包的心态，古典与流行并行不悖。 在马尼拉亚太合作论坛峰会上他曾高唱猫王普莱斯里的「温柔的爱我」（love me tender）。 在卸任总书记前，2002年10月日本视觉摇滚乐队GLAY在工体举行首次海外演唱会「ONE LOVE IN BEIJING」，演唱会前，江意外地接见了他们，而此前鲜有中国领导人接见外国娱乐明星的事情发生，面对明显画风不对的成员时，江没有丝毫违和。乐队成员问到江「主席阁下接见金发的日本人还是第一次吧」时，江主席不假思索的回答「这样的造型也不错么」。最后，江还说「预祝演唱会圆满成功，欢迎大家来中国」。GLAY也回答说将在演唱会上加倍努力，并向江主席赠送了礼物吉他。这也是符合江心意的一份礼物。 像所有的狮子男一样，八月出生的江继续保有着极其旺盛的精力和对喜爱事物的狂热追求，唱歌、弹琴、听音乐对他来说没有比这更能让他身心放松的事情了，他已构建起了自己的内心的精神世界，即使面对一些非议，他坚持自己的审美，他觉得审美能带来尊严，而爱与好奇支撑着他追求更好的生活方式， 就像江在回忆文革时说： 任何贬低和破坏美好文化艺术的荒谬行为都是完全错误的。]]></content>
  </entry>
  <entry>
    <title><![CDATA[叶良辰的女人不是你能惹得起的人]]></title>
    <url>%2F2015%2F09%2F29%2F%E5%8F%B6%E8%89%AF%E8%BE%B0%E7%9A%84%E5%A5%B3%E4%BA%BA%E4%B8%8D%E6%98%AF%E4%BD%A0%E8%83%BD%E6%83%B9%E5%BE%97%E8%B5%B7%E7%9A%84%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[继赵日天、龙傲天、福尔康“网红三少”之后，叶良辰一夜之间火于大江南北。其犀利的文风犹如鲁迅再世，一句： 你若是感觉你有实力和我玩，良辰不介意奉陪到底，兄台，别逼我动用在北京的势力，我本不想掀起一场腥风血雨! 更是成为有背景有实力的象征，日后定成为本年度金句之一。 一个多情却不滥情的纯情男子，为了让心爱的女人不做值日，叶良辰挺身而出，用言情小说男主角的语气和寝室长展开了一段充满魔性的对话，产生出极为强大的喜剧效果。 你们先感受下这浓浓的总裁画风： 《世宗语录》之《良辰本纪》有云： 良辰者，叶姓，京城人士，其妻者，因琐事恶室友，排挤之，辰遂与长者曰：“吾，京都良辰，百种薨，任汝选之无奈也，吾善战大能，此事若不及吾心意，不得完也！”何故，盖玛丽苏文之害也！众水友评曰慎看慎看！思聪闻之，赵姓日天者并不能服！]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何优雅地坐着]]></title>
    <url>%2F2015%2F09%2F28%2F%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E5%9D%90%E7%9D%80%2F</url>
    <content type="text"><![CDATA[上面这张是ziyang同学下台前，与时任魔都市委书记民民的旧照。此照一度在网络上流行甚广，「捧赵贬江」的构图暗合了一些年轻人「呲必中国」的心态，他们迷恋退休的领导人，他们致敬权力斗争的失败者，他们甚至以照片为据说民民对权力的媚俗。 那我们再看下面这张，按上述逻辑这张里民民几乎同样坐姿是不是意味着对知识的敬畏？ 其实如果稍有点常识，看看下面这张老照片，除了那鬼魅的眼神外就会发现这种双脚踝自然盘绕的坐姿什么也不代表，他只是民民一直以来的习惯而已，识得唔识得呀？]]></content>
  </entry>
  <entry>
    <title><![CDATA[中秋节要晒月亮要吟诗]]></title>
    <url>%2F2015%2F09%2F27%2F%E4%B8%AD%E7%A7%8B%E8%8A%82%E8%A6%81%E6%99%92%E6%9C%88%E4%BA%AE%E8%A6%81%E5%90%9F%E8%AF%97%2F</url>
    <content type="text"><![CDATA[习大大中秋访美气宇轩昂小伙伴们群发祝福晒月亮港囧褒贬不一票房真滴棒衷心祝你我都能人月两圆]]></content>
  </entry>
  <entry>
    <title><![CDATA[习大大中秋访美，阜博通迷情月宴]]></title>
    <url>%2F2015%2F09%2F25%2F%E4%B9%A0%E5%A4%A7%E5%A4%A7%E4%B8%AD%E7%A7%8B%E8%AE%BF%E7%BE%8E%EF%BC%8C%E9%98%9C%E5%8D%9A%E9%80%9A%E8%BF%B7%E6%83%85%E6%9C%88%E5%AE%B4%2F</url>
    <content type="text"><![CDATA[中秋节不发月饼的领导不是好领导中秋将近，朋友圈又被刷屏，《人民日报》说：“中秋节不发月饼的领导不是好领导” 。这下好了，员工转给小领导看，小领导转给大领导看，大家各怀鬼胎，互相敲打，反正是《人民日报》的尚方宝剑，可不能说是我们没有政治觉悟和奉献精神了吧。 小明又在没出息地想，今年我大阜博通发不发中秋福利呢？ 我为什么会有这种想法呢，这是有根据的，端午节就冷冷地什么也没有呀？去年好歹有 100 呢（一个棒棒糖 + 两个咸鸭蛋）。 左顾右盼地观望了一个礼拜后，直到昨天，公司也没有半点要发的意思。这几天我下班回到家都要跟老婆唠叨下：“看来今年只能沦落到自己去买月饼吃咯……” 看那边在银行、国企工作的小伙伴们，在朋友圈晒： 左手一盒月饼、右手一桶油，挤上公车、挤下地铁，历尽千辛万苦哼哧哼哧拎回家，满头大汗中洋溢着沉甸甸的成就感。 心酸~咦？你一个大老爷们，怎么还出眼泪了？ 是在下输了，居然还在乎过节领导发不发月饼。 阜博通祝全体员工：中秋快乐 有好事者吟诗为证： 我司中秋花样多，月饼礼盒真不错。猜谜中奖送惊喜，男女老少都快活。]]></content>
  </entry>
  <entry>
    <title><![CDATA[文件上传哪家强]]></title>
    <url>%2F2015%2F09%2F24%2F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%93%AA%E5%AE%B6%E5%BC%BA%2F</url>
    <content type="text"><![CDATA[金轮好法王最近的项目开发中，需要在网页应用中实现“文件上传”功能。 话说“文件上传”，是一个古老得不能再普通的问题，说简单也简单，但是要把它做到极致、完美，那就要考虑很多方面的问题，下面是我列举的几个功能及用户体验上的问题： 是否支持一次选择多个文件 是否支持添加文件夹 是否支持文件拖曳、粘贴版复制 是否支持暂停、恢复、取消上传 是否支持断点续传 是否有上传进度提示 多平台、多浏览器支持问题 服务端配合工作是否简单 本着 “90% 的问题，前人都已经有解决方案”的思路，加上我不想也暂时没有那个功力去“重复造轮子”，于是先上 Google 找“轮子”。 一钻进去，发现了另一片广阔的天地：得益于 HTML5 开发技术的流行，还真有不少做得很精致的文件上传库。 比如 jQuery File Upload 这个插件就可以轻松地实现方便灵活、用户友好的文件上传功能，它几乎完美地解决了跟文件上传相关的每一个问题。 下图是官方 Demo 的截图： 它强有多强多文件支持 允许一次选择多个文件或文件夹。 拖放支持 可以从您的桌面或文件管理器中拖放他们在您的浏览器窗口中上传文件。 上传进度条 显示一个进度条显示为单独的文件和所有上传组合上传进度。 可取消上传 单个文件上传可以取消来停止上传进度。 可恢复上传 中止的上传可以与浏览器支持的 Blob API 进行恢复。 分块上传 大文件可以上传较小的块与浏览器支持的 Blob 的 API 。 客户端图像大小调整 图像可以自动调整大小，显示缩略图。 预览 支持对图像、音频和视频文件的实时预览和播放。 没有浏览器插件要求 该实现是基于开放的标准，如 HTML5 和 JavaScript 的，不需要额外的浏览器插件（例如 Adobe 的 Flash ）。 跨站点的文件上传 支持上传文件到不同的域与跨站点的 XMLHttpRequest 或 iframe 重定向。 多个插件 允许在同一个网页上的使用多个插件实例。 可定制和可扩展 提供了一个 API 来设置各个选项，并定义回调方法的各种重载事件，能跟其他前端框架（比如 Angular）无缝衔接。 多重和文件内容流上传 文件可以被上传为标准的“多部分/窗体的数据”或文件内容流（ HTTP PUT 文件上传） 完备的浏览器支持 支持的桌面浏览器： Google Chrome Apple Safari 4.0+ Mozilla Firefox 3.0+ Opera 11.0+ Microsoft Internet Explorer 6.0+ 支持的手机浏览器： Apple Safari on iOS 6.0+ Google Chrome on iOS 6.0+ Google Chrome on Android 4.0+ Default Browser on Android 2.3+ Opera Mobile 12.0+ 兼容任何服务器端应用平台 适用于任何服务器端平台（PHP, Python, Ruby on Rails, Java, Node.js, Go etc.） ，支持标准的 HTML 表单文件上传。 Tutorial下载压缩包，解压到网站或者使用 npm、bower 等前端库管理工具就可打造跟官方 Demo 一样的客户端 + 服务端环境。 简单应用网页上需要一个 input 元素： 1&lt;input id="fileupload" type="file" name="file[]" multiple&gt; 需要加载的 js 文件有: jquey-1.11.3.min.js jquery-ui-widget.js jquery.iframe-transport.js jquery.fileupload.js 代码： 1234567891011121314151617181920212223242526&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;jQuery File Upload Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input id="fileupload" type="file" name="files[]" data-url="server/php/" multiple&gt;&lt;script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="js/vendor/jquery.ui.widget.js"&gt;&lt;/script&gt;&lt;script src="js/jquery.iframe-transport.js"&gt;&lt;/script&gt;&lt;script src="js/jquery.fileupload.js"&gt;&lt;/script&gt;&lt;script&gt;$(function () &#123; $('#fileupload').fileupload(&#123; dataType: 'json', done: function (e, data) &#123; $.each(data.result.files, function (index, file) &#123; $('&lt;p/&gt;').text(file.name).appendTo(document.body); &#125;); &#125; &#125;);&#125;);&lt;/script&gt;&lt;/body&gt; &lt;/html&gt; 这样就实现了一个基础版的文件上传功能。 显示进度条插件支持显示单个文件的上传进度 (progress) 显示和所有文件的总体上传进度(progressall) 显示： 123456789$('#fileupload').fileupload(&#123; progressall: function (e, data) &#123; var progress = parseInt(data.loaded / data.total * 100, 10); $('#progress .bar').css( 'width', progress + '%' ); &#125;&#125;); 需要一个容器用来显示进度条： 123&lt;div id="progress"&gt; &lt;div class="bar" style="width: 0%;"&gt;&lt;/div&gt;&lt;/div&gt; 给进度条显示不同颜色，可以通过 CSS 来设置： 1234.bar &#123; height: 18px; background: green;&#125; 显示上传的文件名你可以经常要将上传的文件显示到特定的元素上，这个可以通过 add 回调函数来实现： 12345678910$('#fileupload').fileupload(&#123; dataType: 'json', add: function (e, data) &#123; data.context = $('&lt;p/&gt;').text('Uploading...').appendTo(document.body); data.submit(); &#125;, done: function (e, data) &#123; data.context.text('Upload finished.'); &#125;&#125;); 点击开始上传在上例基础上，可以通过按钮点击事件来触发上传（上例是自动上传） 1234567891011121314$('#fileupload').fileupload(&#123; dataType: 'json', add: function (e, data) &#123; data.context = $('&lt;button/&gt;').text('Upload') .appendTo(document.body) .click(function () &#123; $(this).replaceWith($('&lt;p/&gt;').text('Uploading...')); data.submit(); &#125;); &#125;, done: function (e, data) &#123; data.context.text('Upload finished.'); &#125;&#125;); 参考 http://blog.csdn.net/violet_day/article/details/17231425]]></content>
  </entry>
  <entry>
    <title><![CDATA[Lost and Found]]></title>
    <url>%2F2015%2F09%2F23%2FLost-and-Found%2F</url>
    <content type="text"><![CDATA[之前写过一篇 《那些相见恨晚的 Mac 使用技巧》（点击【阅读原文】），列举了几个实用的 Mac 小技巧。 上周，小明挤公交时，一不小心， iPhone 被小偷摸走了，为此，我曾怀着悲愤的心情怒诗一首（回复关键字【20150914】）。 今天给大家再分享一个冷门但很实用的 Mac 小技巧。 试想以下场景在一个阳光明媚的午后，你背着心爱的 MacBook 出门，准备再去星巴克体验一把一边喝卡布奇诺一边玩 Mac 的逼格，无奈，粗心的你，回来时不小心把小白 「遗落」 在出租车或者店里，说来也巧了，你的 Mac 本恰好被某位好心人捡到打算交还给你，Only to find 找不到你的联系方式，打开电脑发现有开机密码，全剧终。 好不容易遇到好心人，这最后的一线希望也要泡汤了。 并不是每个”好心人”捡到东西都会归还吧？解：不妨试试悬赏，酬谢，又做好事又有钱拿，何乐而不为呢。 更何况，电脑内的资料和隐私对于失主来讲，其价值往往远胜机器本身。 使用技巧通过设置「锁屏显示信息」，让笔记本在屏幕锁定时额外显示一段文字，如下图： 这段文字往往会是 Mac 失而复得的关键，它往往能在你百密一疏的时候带来一丝希望。 设置方法  - System Preferences - Security &amp; Privacy - General - Set Lock Message 作为一个细心体贴的好老湿，考虑到读者您不识 English 或者您的系统语言为中文，小明为你翻译下对应的中文语言版本：  - 设置 - 安全性与隐私 - 通用 - 设定锁定信息 当然我们也可以自由发挥，把它当做一个「公告牌」来用，在公共场所往往能游刃有余，看看下面的招式： 如果捡到本本，请联系 xxx ，必有重谢。主人去 WC 了，稍安勿躁。密码很好很强大，一般人破解不了，Enjoy!充电中，勿扰！美女请忽略这条提示……约吗？@hxzqlh 小结建议大家动手设置一下这个锁屏信息，如果不慎遗失了心爱的 Mac ，说不定会因此遇到好心人送回来，说不定会因此偶遇个帅哥美女，说不定……相信，还是好人多吧。 什么？你是 iMac/ Mac mini 台式机？当我没说~]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>MacBook</tag>
        <tag>Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《毛骗》| 中国最大农村石家庄的重大贡献]]></title>
    <url>%2F2015%2F09%2F22%2F%E3%80%8A%E6%AF%9B%E9%AA%97%E3%80%8B-%E4%B8%AD%E5%9B%BD%E6%9C%80%E5%A4%A7%E5%86%9C%E6%9D%91%E7%9F%B3%E5%AE%B6%E5%BA%84%E7%9A%84%E9%87%8D%E5%A4%A7%E8%B4%A1%E7%8C%AE%2F</url>
    <content type="text"><![CDATA[世界上分为两种人：一种是喜欢看《毛骗》的，另一种是不知道《毛骗》的。 《毛骗》，这是一个难登大雅之堂的片名，它故在说骗，内里其实是讲人、说义、言信、传情。 9 月 10 日，断更 20 个月后，它索性带着终结篇回归。可喜的是，它没有步一般续集狗尾续貂之后尘，并且还带来了不少惊喜。历史、地理、古文、中医、物理、化学，引经据典，布局推理，一步一步，环环相扣，计中计中计，局中局中局，套中套中套，它把全剧最大的反转特色玩转得炉火纯青，令人拜服，看完全集我真是一个大写的服气！ 凡你所看到的，都不是真的；你所看到的反转，也未必都是真的；至于你所看到的反转的反转，呵呵，你猜……这就是传说中的「若见诸相非相，即见如来」吧。 《毛骗》第一季开播于2010年，五年来，对大多数的该剧粉丝来说，这是他们或美好或不美好的青春记忆。你可以从这停更的一年半来剧组人员微博下面的评论中，了解到这五年中粉丝们都经历了些什么。从高中到大学到毕业工作，从单身狗到谈恋爱到换的男（女）朋友十个指头都数不过来，从结婚到生子到离婚到二婚……大抵如此。 在大二时就与同学自组影视团队，拍摄网络短片和广告。而团队中每个人都身兼导演、编剧、摄像、剪辑多职，靠的仅仅是问同学借的小 DV，和满腔的热情，满腹的才华，满脑的创意。所以你在他们毕业后拍摄的《毛骗》第一季中，看到的是连现在的手机拍摄效果都不如的渣画质，以及简陋的道具，场景等。 李洪绸是这样形容的：「回想起我们一开始拍片那会儿，往往是一个导演，一个摄像，一个录音，几个演员就搞定一场戏。群演？无所谓，找身边的朋友，实在不行，现场现抓，再不行，录音上，演员举杆，录音出现过了？那摄像上，固定机位或者导演扛机；场景？无所谓，酒店用不了，用旅馆，再不行就日租房；光？能看清脸就行了，晚上的外景怎么办？哪里路灯多就上哪拍。我靠，有些地方的路灯十二点就灭了，改戏，改另一条街；道具？导演，你要的青花瓷的瓶子不好找啊，你看这个怎么样？导演：这太像痰盂了吧。道具：这就是痰盂。导演：……。众人：没事，拍吧，观众看不出来。」 这一切都掩盖不了李洪绸才华的展现，尤其是扎实的原创剧本，他是一个你给他资金他能还你奇迹的人。 在之后两季中随着投资的引入，画质道具场景剧情等全面升级，单集长度也逐渐逼近一部电影的长度。而这，正是这部剧的独特之处：你可以清楚地看到在这五年内，这群刚从河北传媒学院毕业不久的大学生是如何从当初青涩的演技、生硬的台词、简陋的硬件装备中一步步走到今天，从那个网剧始开垦的荒芜时代，一步步走到今天，最终将《毛骗》终结版这部两年磨一剑，无论从剧本、演员、表演角度，还是画面、声音、剪辑、音乐层面都堪称网剧甚至是国产剧良心之作，毫不夸张地说，随便拉个单集出来都碾压大多数院线电影。 不信？豆瓣评分可以说明一切： 感谢中国最大农村石家庄，这里，一个年轻的狠导，拍了一部至今我看过的最棒的国产剧。]]></content>
  </entry>
  <entry>
    <title><![CDATA[一款完美的 Ubuntu 用户 MAC 主题]]></title>
    <url>%2F2015%2F09%2F21%2F%E4%B8%80%E6%AC%BE%E5%AE%8C%E7%BE%8E%E7%9A%84-Ubuntu-%E7%94%A8%E6%88%B7-MAC-%E4%B8%BB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[如果你喜欢 MAC 主题，且正在寻找一款支持 Ubuntu 桌面的 MAC 主题，这个主题将会达成你的愿望：Zukimac，一款 MAC OS x-inspired gtk3 主题，这是一款不可思议的主题。 zukimac 是一款免费下载可用的 GNOME 外观，新增提供了 GTK 3.10 和 GTK 3.12 支持。完全集成 Unity 桌面，做工精细。 主题下载(因微信屏蔽外链，点击【阅读原文】可看到下载链接) 下载 Zukimac 下载 Zukimac for GTK 3.10 主题 下载 Zukimac for GTK 3.12 主题 关于安装 先下载主题包； 解压主题包； 将解压的主题文件夹拷贝到/usr/share/themes/目录下； 使用 Unity tweak tool 启用新主题。 图标可选择：Feanza 下载 Feanza 图标安装包 心旷神怡下面再给大家分享一些漂亮的 Mac 和桌面布置美图：]]></content>
  </entry>
  <entry>
    <title><![CDATA[低智商的善良]]></title>
    <url>%2F2015%2F09%2F20%2F%E4%BD%8E%E6%99%BA%E5%95%86%E7%9A%84%E5%96%84%E8%89%AF%2F</url>
    <content type="text"><![CDATA[善良是人类最高的智慧。 善良也是很难达成的成就，情商、智商缺一不可，否则轻则弄巧成拙，重则遭人记恨。 有人昨天支持「人贩子死刑」，今天又被「最美山村女教师」感动；昨天在转发「马云说给年轻人的十句话」，今天又在微博上对马云逼捐。 什么是「低智商善良」？ 「低智商善良」，是一种在对事物的基本规律缺乏尽可能完整客观的认知，同时又不对事物发展规律进行尽可能详尽的调查情况下，做出的自认为符合「善」的做法。它往往和道德绑架、自视清高以及圣母心的思维相关。 比如： 没有知识水平的善良为生病的人推荐各种未加验证的「偏方」。 把陆龟放生到水里，把毒蛇放生到公园。 《法证先锋1》里，高彦博（欧阳震华饰）的妻子古泽瑶（刘锦玲饰），瘫痪且患上癌症，被好心的玉姐喂了十天的民间偏方，因此「斑蝥素」中毒导致心脏衰竭而死。 道德绑架，特别是针对富人的马云这么富有，他应该为天津爆炸事故捐上几亿！ 不过就是撞坏他的豪车吗？他这么有钱就不应该让穷人赔钱。 善恶不分，不去同情受害方，反而同情作恶方周立波在节目上逼迫女孩原谅当年抛弃她的生父生母。 白冰冰在综艺节目里谈到，在女儿白晓燕被杀害后，有人来劝她原谅绑匪陈进兴。 作家白小帆有一个从不做家务乱丢垃圾的室友，在白小帆忍无可忍发飙后，有人反认为白小帆对室友不宽容。 和稀泥式的调解方式虽然他抢了你客户，但好歹是一个部门的同事，就算了算了吧。 哎呀，他不就是打你几拳吗，打是疼骂是爱呀，又不是出去乱搞，你看他都跟你跪下了，这还没有诚意吗？快原谅他。 哎呀，他就是出去玩玩，都不是真心的，逢场作戏啦，又不是把她们带回家来，你生个孩子他就收心啦。 哎呀，你们孩子都有啦，孩子要爸爸呀，他再怎么不对，你还得考虑孩子嘛。忍忍吧。 自虐式的善良：对恶人善良，甚至是对害过自己的人善良新闻：「初三女生扶老太被讹后不计前嫌反资助其千元」 在韩国电影《今天》里，宋慧乔饰演女主角多惠，她有一个恩爱的未婚夫。但未婚夫在雨夜里被少年开摩托车撞伤，肇事少年怕承担责任，干脆将多惠的未婚夫撞死。多惠选择原谅肇事少年，替对方写了请愿书向法官求情。但多惠后来得知，她的善良没有感化肇事少年，肇事少年在学校里再次因嫉妒杀害了同班同学。多惠因此陷入沉重的痛苦中。 无节制地帮助《儒林外史》里的杜少卿对谁都慷慨，久而久之，周围人什么事都找他要钱。杜少卿最终散尽家财，一无所有。 百度「升米恩,斗米仇」或「斗米恩，担米仇」或是「养仇人」等关键词，可以看到很多个反应自己一心一意帮助亲戚朋友，最后亲戚朋友却跟他反目成仇的帖子。 不恰当地表达同情心对穷人、残疾人表示出强烈的同情，其实会让他们内心很不舒服。 王小波在《我看老三届》一文里，提到自己有一个先天残疾但很自强的老师。文中王小波提出了一个观点： 对残疾人的最大尊重，就是不把他当残疾人。 法国电影《触不可及》里，瘫痪在床的白人富翁菲利普炒掉了多位「同情他」的看护，唯独留下了做事毫不细心的黑人德希斯，因为德希斯常常忘记他是个残疾人。 不要，让善良感动了自己，而难为了别人。罗素说过的一句话： 不管你是在研究什么事物，还是在思考任何观点，只问自己事实，以及这些事实证实的真理。永远不要让自己被自己更愿意相信的，或者认为人们相信了会对社会更有益的东西影响。只是单单去审视，什么是事实。 真正的善是在充分的研究和审视了事实之后做出的能带来最好结果的选择。 很多时候，真正的善在当下看起来甚至是邪恶的、冷血的，比如说丘吉尔在 Enigma 被破译之初选择不对德军袭击村庄做出任何行动。 真正的善良，是用有限的资源，以正确的方式，帮助那些需要帮助的人。 他不会：赠人遗憾再劝人珍惜。 他不会：赠人不幸再劝人坚强。 他不会：赠人嫉妒再劝人自信。 他不会：赠人恶意再劝人宽容。 他不会：赠人冷漠再劝人热情。 他不会：赠人危险再劝人强大。 他不会：赠人刀光剑影，劝人绝处逢生， 他不会：赠人千辛万苦，劝人云淡风轻。 他不会： 为求一个心有所好的美好，给他人做囚牢。以至于欣赏着开在泥潭里的花，赞美它的不屈不挠时，连自己当初把花拖进泥潭时的「良苦用心」，都一并赞美了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[你的 Xcode 已签收，签收人：草签]]></title>
    <url>%2F2015%2F09%2F19%2F%E4%BD%A0%E7%9A%84-Xcode-%E5%B7%B2%E7%AD%BE%E6%94%B6%EF%BC%8C%E7%AD%BE%E6%94%B6%E4%BA%BA%EF%BC%9A%E8%8D%89%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[从昨天上午开始，关于 「XcodeGhost 病毒」的信息充斥了 IT 圈，一石激起千层浪，其火爆程度丝毫不亚于一颗炸弹扔进了粪坑，分量十足。 作为一个嗅觉灵敏的技术男，我也心安理得地放下手上正在码的代码，过去凑了会热闹。 又作为一个循循善诱育人不倦的好老师，小明先给技术盲普及下计算机基础知识： 你现在常用的电脑软件、手机 APP，都是由那群号称「技术改变世界」的程序猿编好代码（这个快乐而痛苦的过程俗称「码代码」，这群苦逼的程序猿俗称「码农」），然后用某款神通广大的编译器编译成可执行程序，然后打包、发布，最后你通过各种渠道下载对应的软件、APP 装到电脑或手机上执行。 下面再科普「病毒」和「漏洞」： 病毒，好比癌细胞，它会繁殖、感染，往一切可能被渗透的地方扩散，更要命的是，它还会自身复制，一生二，二生四，四生八，八方万物……「天下武功，为快不破」，病毒都是主动出击，寻找自己的肉鸡。软件要是中病毒了，如果放任不管，不但自身被吸血，最后变成行尸，还会连累跟你做邻居的其他软件。所以，为了所谓的安全，一般电脑上都要装安全防护软件，用大家都听得懂的人话来讲就是「杀毒软件」（Mac 用户请不要觉得惊讶） 漏洞，则是由于软件本身的 Bug 导致的，由于程序员也不是万能的，大脑也有缺氧短路的时候，谁能保证自己的代码百分百正确呢，一时的逻辑混乱就可能挖下一个巨大的坑，导致软件日后被人利用，这种就是「漏洞」。 自从软件诞生的那一天起，病毒、漏洞这对夺命双头鲨就和它相伴相随，不离不弃，弃而不舍，剪不断理还乱……没有一款软件胆敢号称终身无病毒无毒副作用，当然，也没有哪一种漏洞、病毒能号称能百发百中、侵之四海而皆准。 软件和病毒到底谁能干掉谁？这就涉及到各自「术」的能力高低了，两大阵营之间的斗争从上世纪四五十年代一直延续至今。这对冤家的关系好比「道」和「魔」： 道高一尺，魔高一丈，道挡不过马上穿金钟罩铁布衫护体，魔诡魅一笑放出三分归元气，道感觉到一阵强烈的地震波袭来，马上用降龙第十八掌降龙有悔回击，魔见正面久攻不进，改用暗器，刷刷刷，五枚冰魄银针射出，说时迟那时快，在距离眼睫毛只有 0.01 公分的一刹那…… 好吧，天亮了，梦醒了，别意淫了。 醒来继续说说今天的主题，什么是 XCodeGhost？ 9 月 17 日上午 9 点，著名的 iOS 开发工程师唐巧老师发了一篇微博： 在非官方渠道下载的 Xcode（苹果软件开发必备工具）居然自带病毒文件？！这种事小明老师还是第一次知道： 这个 XcodeGhost 病毒颇有创新意识，它不走传统病毒传播的老路，而是独辟蹊径，直接把病毒代码嵌入了开发工具源头，只要用了注入病毒的 Xcode 来开发软件，任凭你代码如何健壮，照样毒入真身。 造成的结果是，通过这些 Xcode 编译出来的 App 会被注入不知名的第三方代码，并且向一个陌生的可疑的非苹果官方网站： http://init.icloud-analysis.com 发送数据。 众所周知，由于车迟国互联网与世隔绝，车池国人民访问海外网站的速度只能用「你懂的」蜗速形容。有些程序员急于开发，就想偷懒从国内的某鸟类图标的下载软件搜索下载 Xcode，而木马作者，将他开发的带有木马的编译器发布到了各种平台上，提供种子，导致不明真相的程序员下载到了包含木马的版本，当然，其中有些人也大意得忘了去和官网的版本校验比对。 程序员号称智商一流，没想到啊没想到，在他们都完全不知情的情况下，乐呵呵地发布了包含木马的 APP，而苹果公司在审核过程中，居然也没有能检测出这些恶意代码，因此这些包含恶意代码的 APP 顺利登录了 Appstore，并被数百万甚至数千万用户下载…… 这个中招的名单非常恐怖，截止目前，包括但不限于这些 iPhone 上的 APP 均中枪： 网易云音乐 网易公开课 12306 移动端 中信银行动卡空间 下厨房 中国联通手机营业厅 高德地图 简书 豌豆荚开眼 滴滴打车 51卡保险箱 同花顺 细思恐极，后背发凉。 已经有各种技术宅通过代码逆向等方式（详见：http://drops.wooyun.org/news/8864）对该木马挖坟鞭尸，从目前来看，在 Xcode 中莫名加入的这段代码并没有什么恶意，只是收集一些 iPhone 和 APP 相关的时间、包名、应用名称、系统版本、语言、国家等部分数据，但是不得不防的是，未来很可能出现更加带有攻击性的病毒注入 Xcode，那么对于用户手机安全，这其中存在巨大的隐患。 在此，严重建议： 所有使用苹果手机的用户，请密切关注有关报道，尽快卸载公告名单中的软件，并跟踪乌云：http://drops.wooyun.org 或其他安全组织最新的公告寻求解决方案，安全起见，建议修改 Apple ID 及 iCloud 密码。]]></content>
  </entry>
  <entry>
    <title><![CDATA[偶遇一只尤物]]></title>
    <url>%2F2015%2F09%2F16%2F%E5%81%B6%E9%81%87%E4%B8%80%E5%8F%AA%E5%B0%A4%E7%89%A9%2F</url>
    <content type="text"><![CDATA[低调出世 Node-Webkit（现已正式改名为 NW.js），一个用 HTML5/CSS/Javascript 等 Web 技术来写跨平台桌面客户端应用程序的开源框架（跟移动终端上的 PhoneGap 等项目的原理类似），开发者只需写一份代码，就能编译出可同时跑在 Windows、Linux 和 Mac 上的桌面应用程序。 让我意外的是， Node-Webkit 项目的发起人居然是国人， Rogerwang，真名王文睿，英特尔开放源码技术中心（OTC）的软件架构师。最开始，node-webkit 只是他的一个业余项目，该项目从 2011 年开始，截至目前，在 GitHub 上已经有 24000 多个 Star，2600 多个 Fork。 从 nw.js 官网 可以看出，使用 Node-Webkit 开发的应用领域非常丰富，其中也不乏一些设计精良体验优美的软件。很大程度上，这得益于目前硬件的性能提升和 Web 技术的发展，动画、图形、音频、视频、2D、3D、WebGL 等等，都让基于 HTML5 的应用开发充满了想象力。 Node-Webkit 是通过 Node.js 和 WebKit 技术的融合，让开发者可以用 HTML5/CSS/Javascript 技术编写 UI，同时又能利用 Node.js 平台上众多 library 访问本地 OS 甚至跨域访问 ，最终达到用 Web 技术就可以编写桌面应用的目的。 具体实现的内部原理，作者这样解释道： 核心思想是把 Node.js 的消息循环（libuv）和 Chromium Renderer 进程的消息循环合并到一起，这样从 DOM（HTML）中可以直接调用 Node.js 提供的函数；把 Node.js 使用的 V8 引擎和 Chromium 的 V8 引擎合并，使得 Node.js 的 Javascript 和 DOM 里面的 Javascript 可以互相访问。 传统的桌面应用开发中，用户界面的复杂性一直是一个难题，而 node-webkit 方式可以降低很多用户界面开发的复杂性，将界面开发交给更加灵活、更加容易编写和调试的方式：HTML + CSS。 小试牛刀nw.js 框架下的开发流程是： 编写一个 HTML 页面（作为程序入口），然后在这个页面上引入额外的 CSS（界面风格）和 JavaScript（动作），然后将这些资源交给工业级浏览器内核 Webkit 来渲染 。 我们来通过一段最简单的 HelloWorld 程序，窥探一下 Node-webkit 的样子: 示例代码:下面一段简单的 HTML 文本，显示一个”Hello World!”的问候，它将是我们这个应用程序的入口。 123456789&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Sample App&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello World!&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 再新建一个配置文件：package.json 123456789101112&#123; "main": "index.html", "name": "sample-app", "description": "demo app of node-webkit", "version": "0.1.0", "window": &#123; "toolbar": false, "resizable": false, "width": 800, "height": 500 &#125;&#125; 该文件是 node-webkit 的应用描述文件，一个完整的 node-webkit 应用程序必须包含这样一个文件。它用于定义应用程序的基本信息以及运行相关的参数，比如名称、介绍、入口文件名称以及应用程序窗口的各项配置，如窗口的显示尺寸、显示位置、是否显示工具栏等等。 运行安装好 nw.js 后，nwjs 添加到系统的环境变量，只需在当前目录下运行 nw .命令，就会看到如下窗体： 上图是 Windows 平台下效果，再看 Mac OS X 平台下的效果： 以及 Linux 平台下的效果（请忽略虚拟机界面）： Look it，So easy~真正实现了一份代码适用各种平台。 从这个简单的实例可以看出： 页面运行在一个「桌面应用程序」中。没有地址栏，状态栏，菜单栏等，看起来更像是一个桌面应用。 用户界面开发的复杂性被「外包」给一个更简单的 Web 环境。这就是传说中的混合（hybrid）开发模式，比如现在移动开发中的 cordova 就是采用这种模式，使得本来被视为天堑的原生的用户界面开发变为坦途。 展望未来用 Web 技术来开发桌面应用，其实这条路老早就有人在走，比如： 跨平台+多终端毫无疑问，这货会成为桌面开发的神器。因为它具备了以下这些无可比拟的优势： 人力成本最低招一个会 C++ 的码农要花多少钱？招一个牛逼哄哄的既会 C++ 还对 QT、MFC 等了如指掌的码农又要花多少钱？对比一下，招一个会 JS + CSS 的呢？如果你是老板，你怎么想？再说了，市面上会 C++ 的码农更多，还是会 JS + CSS 的码农更多？无需小僧多言，其中的奥妙您自个儿体会。 APP 的体积更小列位一定还记得当年大明湖畔的疼讯 QQ 只有十几 M 的体积，俗话说，岁月是把杀猪刀，在集成了疼讯的各种应用之后，如今的 QQ 身材早已发福走形。可以想象，如果 QQ 不使用嵌入浏览器内核的方式，恐怕体积早就超过 100M 了吧！ 不需要整体更新 APP如果是按照传统的方式开发桌面应用，每次升级的时候都需要用户重新下载整个应用，比如疼讯 QQ。但是用 node-webkit 的这种方式，可以很好地避免这个问题，就像网站一样，网站内容可以不断更新，但是浏览器本身的更新不需要那么频繁。 跨平台不多说了，显而易见的优势。 多终端由于 node.js 和 chromium 本身都是可以在桌面平台和移动平台上运行的，因此用这货来支持多终端开发，保持技术栈的一致性是非常合适的。 完善的工具链由于 node.js 的兴起，它下面的 npm 模块数量已经有几十万个；而各种基于chrome 内核的定制版浏览器就不用再介绍了。加上传统 B/S 开发模式下已经具备的完整开发和设计工具，用 node-webkit 来开发桌面应用已经具备了完善的工具链。 总结node-webkit 很大程度上简化了桌面程序的开发，为 Web 前端以及桌面客户端的开发人员提供了一个新的舞台。 就是啊，这货 2011 年就出来了，我们去年还在殚精竭虑地搞 web client，想想真是欲哭无泪 ~ 最近，我司因战略发展需要，亟需给客户研发出一款「跨平台、易扩展」的客户端软件，刚好在这个时机，乔帮主地下显灵，让我捡到了 nw.js 这只尤物，好巧啊，怎么会这么巧呢，要我说啊，这事真是活活给巧死了……呜呼~这下又有事做了……]]></content>
  </entry>
  <entry>
    <title><![CDATA[iPhone 6 Plus 丢了，怒诗一首]]></title>
    <url>%2F2015%2F09%2F14%2FiPhone-6-Plus-%E4%B8%A2%E4%BA%86%EF%BC%8C%E6%80%92%E8%AF%97%E4%B8%80%E9%A6%96%2F</url>
    <content type="text"><![CDATA[今天傍晚下班路上 熟悉的 37 路公交车 我的 iPhone 6 Plus 不慎遗失 打电话过去 宁波的号码已关机 是真的丢了 是真的被偷了 世界突然静下来 手足无措的荒草爬满心坎 我试着腾空一切 让自己做一个思想者 一不小心的悔恨 不可名状的紧迫感 成为被派来的说客 堵塞了心口 我第一次这样刻骨铭心地纪念 这一串代表我个人的数字 但一遍一遍打不出亲 也骂不出爱 家中领导怒上红颜 抓我几个红手印 亏老娘省吃俭用一个月 你就是没有用爱疯的命 最后问题来了 手机防盗哪家强 小心为上 只能骂娘]]></content>
      <categories>
        <category>心旷神怡</category>
      </categories>
      <tags>
        <tag>iPhone</tag>
        <tag>小偷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一部看完后你会自觉把裤子穿好的香艳大片]]></title>
    <url>%2F2015%2F09%2F13%2F%E4%B8%80%E9%83%A8%E7%9C%8B%E5%AE%8C%E5%90%8E%E4%BD%A0%E4%BC%9A%E8%87%AA%E8%A7%89%E6%8A%8A%E8%A3%A4%E5%AD%90%E7%A9%BF%E5%A5%BD%E7%9A%84%E9%A6%99%E8%89%B3%E5%A4%A7%E7%89%87%2F</url>
    <content type="text"><![CDATA[前不久，韩国上映了一部很不错的情色片《奸臣》（想看的朋友，回复关键字【奸臣】，推送百度云影片链接），今天，本着艺术鉴赏的初衷，我来小叙一下关于韩国情色片的那些事儿。 虽然「情色片」和「色情片」本质都是：「废纸」， 但「情色片偏重艺术，色情片偏重技术」，还是一语道破了二者的区别，而将这一区别展现得淋漓尽致的，在东亚三雄中，非韩国的情色片莫属。 岛国的成人片多半是剧情简单、直奔主题，男主角丑爆、女的一上来就雅玛碟，来也匆匆，去也匆匆，偶尔泄欲看上一两部还可以，欣赏就谈不上了。 中国香港的情色片，往往取材并乱改于古典文学名著，过度夸张、极度意淫、品质低劣，缺乏上乘之作。即便有，手段也并不高明，比如展现女性美好胴体，港片一般只有「洗浴」和「艳舞」两招。说到重头戏男欢女爱，则更是草草而成，布景简单、动作夸张并且千篇一律，有时甚至加进些低俗笑料，哪有半点唯美情境可言？ 韩国的情色电影，因为社会体制的关系，没有发展成日本的 AV 影片，又不像中国电影在表现情欲方面束手束脚，因而打出了一片独特的天地…… 如果要用一两个词来概括韩国情色片的话，「唯美、精致」应该是最好的形容。韩国情色片在营造男女的情爱气氛上下足功夫，对音乐、灯光、布景、颜色都极有考究，那精雕细刻出的优美画面与片中唯美激情的氛围契合得天衣无缝。观之足以让人于心神激荡、心旷神怡：「男女的床第之欢被拍到如此境界，还真不好说是卖弄色情了」。 细论《奸臣》这部情色片依然保持了韩国电影制作精良、剧情考究的优良传统。 从成色上看，丝毫不逊于中国的张艺谋大胸片《满城尽带黄金甲》。哗啦啦，满屏满屏的华服丽人酥胸美腿，香艳、妖艳、美艳，美的让人痴迷，艳得让人口水直流。有图为证： 在剧情上，为了表现淫乱暴政，影片充斥了大量大胆犀利的情色桥段，比如昏庸的燕山王一边让女人口活之一边射杀女人父亲一段，尺度之大，简直是叹为观止。 但，《奸臣》并没有沦为简单的泄欲型影片，非但如此，还拍出了民族大义的高度：它不仅是脱裤子的事情，而是提起裤子，去思考这个民族的走向问题。 在主题上，《奸臣》其实是情色片的面子，伦理片的里子。看到最后，有一股说不清道不明的孤独、哀怨、痛惜的感觉，它是在思考：「这个民族何以沦入如此昏庸溃烂？」，更是疾吁：「这个民族不能重蹈覆辙！」 影片为什么叫《奸臣》？其实影片所谓的「奸臣」并不单单指任崇载任士洪父子，在那样的暴政时期，每个人都是「奸臣」，每个「忠臣」都会为了自己想要的利益去做「奸臣」，所谓的「忠臣」和「奸臣」根本没办法分的清楚，而君王也只不过是他们手中的一个傀儡而已。 究竟是先有昏君，还是先有奸臣？是昏君毁了忠臣的效忠之心，还是奸臣毁了明君的王道之志？ 电影没有给出答案，将问题抛给了观众。 这句台词，引人深思： 你把我当成傻瓜吗？你认为让朕成为昏君的是谁？王犯错时，臣子是该拼命谏言还是豁出性命来顺从？朕所作所为暗合敌人之意，你都不为之担忧，你就是奸臣！用一件血衣蒙蔽君主眼睛、毁了国家，你就是亡国之臣！朕的朝廷里没有忠臣，只有忠犬而已。]]></content>
  </entry>
  <entry>
    <title><![CDATA[你中有我，我中有你。]]></title>
    <url>%2F2015%2F09%2F12%2F%E4%BD%A0%E4%B8%AD%E6%9C%89%E6%88%91%EF%BC%8C%E6%88%91%E4%B8%AD%E6%9C%89%E4%BD%A0%E3%80%82%2F</url>
    <content type="text"><![CDATA[今天分享下最近学习到的：在 Mac OS X 平台上，实现 Javascript 与 Objective-C 两种编程语言的交互机制。 你侬我侬，忒煞情多。情多处热如火。把一块泥，捻一个你，塑一个我，将咱两个，一齐打破，用水调和，再捻一个你，再塑一个我。我泥中有你，你泥中有我，与你生同一个衾（qin），死同一个椁（guo）。 背景现在很多视频或者音乐的客户端，比如 QQ Music For Mac。往往通过在客户端嵌入网页的方式来展现内容，并通过 Javascript 调用客户端的一些功能，比如下载视频或者播放音乐等。 嵌入网页基本都是采用 WebView 控件来展示网页，这时客户端好像内嵌了一个微型的浏览器。 用嵌入网页的方式，好处是显然的： 网页可以轻易做出很炫丽的效果，当然客户端通过艰难的自绘也可以做出很华丽的效果，但开发时间跟开发难度跟网页比起来没得比。 网页可以随时更改，更改后可以实时更新到你发出去的每一个客户端版本，这种扩展性在实战中是很重要的。 Javascript 与 Objective-C 双方是对等的，也就是 JS 可以调用 OC，反过来 OC 也可以调用 JS。 Demo 官方例子： CallJS ，详细了介绍上面所述的所有技术细节。 你也可以在 GitHub 上直接下载我写的这个 Demo：JS-OC-Communicate-Tutorial 技术细节类型转换从 Demo 中可以看出，在 OC 与 JS 通信时，变量的类型会自动进行转换，基本类型都会自动转换，如 JS 中的 number、boolean 都会转换成 OC 中的 NSNumber 类型，而 String 类型会自动转换成 NSString 类型，JS 中的对象会转换成 WebScriptObject 对象，而相关的属性信息可以通过 Key-Value 的方法读取和写入。 OC 调用 JS：1、OC 执行一段 JS 代码，使用下面的函数： - (NSString *)stringByEvaluatingJavaScriptFromString:(NSString *)script; 2、OC 调用 html 页面里面的 JS 函数 比如 js 端有一个函数 JSFunction： function JSFunction(parameter) { //显示OC返回的值 document.getElementById(&apos;view&apos;).value = parameter; //返回成功的消息 var result = {&apos;message&apos;:&apos;Web page has received msg！&apos;}; return result; } OC 端可以用下面的方法来调用： - (IBAction)doAction:(id)sender { //设置对象 WebScriptObject *result = [[self.webView windowScriptObject] callWebScriptMethod:@&quot;JSFunction&quot; withArguments:@[self.textField.stringValue]]; NSString *message = [result valueForKey:@&quot;message&quot;]; } JS 调用 OC:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/* 当页面加载完成，将要执行JS之前，didClearWindowObject 消息将会发送给 webview 的frameLoadDelegate。我们可以在这个最完美的时机里，设置一个属于我们自己的JS对象 */- (void)webView:(WebView *)sender didClearWindowObject:(WebScriptObject *)windowObject forFrame:(WebFrame *)frame&#123; /*将当前对象加到JS里面的window全局对象里面，并命名为native。 之后可以在JS通过使用native变量来使用当前的对象 */ [windowObject setValue:self forKey:@"native"];&#125;/* 返回是否阻止响应该方法, 返回NO即能响应该方法 */+ (BOOL)isSelectorExcludedFromWebScript:(SEL)selector&#123; if (selector == @selector(status:)) &#123; return NO; &#125; return YES;&#125;/* 返回本地方法在JS中的名称 */+ (NSString *)webScriptNameForSelector:(SEL)sel&#123; if (sel == @selector(status:)) &#123; return @"ocMethod"; &#125; return nil;&#125;/* 返回是否阻止获取该属性, 返回NO即能获取该属性*/+ (BOOL)isKeyExcludedFromWebScript:(const char *)property&#123; if (strcmp(property, "sharedValue") == 0) &#123; return NO; &#125; return YES;&#125;/* 返回本地属性在JS中的名称*/+ (NSString *)webScriptNameForKey:(const char *)name&#123; if (strcmp(name, "sharedValue")) &#123; return @"oc_sharedValue"; &#125; return nil;&#125; JS 中代码如下： 12345678910111213function CallNative()&#123; if (native) &#123; //将当前显示的文本组装成对象发给OC var consoleValue = document.getElementById('view').value; var parameter = &#123;'message':consoleValue&#125;; var result = native.ocMethod(parameter); //显示OC返回的结果 document.getElementById('view').value = result['message']; &#125;&#125; 总结利用 Javascript 与 Objective-C 的通信机制，可以通过 HTML、Javascript、CSS 等 Web 技术实现炫丽的 UI ，而通过原生 API 实现与本地相关的操作。这对于 OSX 平台上的桌面客户端开发者而言是大大的福音。 参考 http://blog.csdn.net/pjk1129/article/details/6936545]]></content>
  </entry>
  <entry>
    <title><![CDATA[手把手教你开发浏览器[一]]]></title>
    <url>%2F2015%2F09%2F11%2F%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%BC%80%E5%8F%91%E6%B5%8F%E8%A7%88%E5%99%A8-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[浏览器大家都不陌生，想要上网，就不得不用到浏览器。 国内网民计算机上常见的网页浏览器有，QQ 浏览器、Internet Explorer、Firefox、Safari，Opera、Google Chrome、百度浏览器、搜狗浏览器、猎豹浏览器、360 浏览器、UC 浏览器、傲游浏览器、世界之窗浏览器等。 Safari 浏览器、Opera 浏览器、谷歌浏览器用的都是 WebKit 引擎，其他浏览器引擎还有 Gecko（Mozilla Firefox 等使用）和 Trident（也称 MSHTML，IE 使用） 什么是 WebKit？WebKit 是开源的 Web 浏览器引擎，它就像一个黑盒，我们把 HTML、CSS、JS 和其他一大堆东西丢进去，然后 WebKit 魔法般的以某种方式把一个看起来不错的网页展现给我们。 WebKit 内核在手机上的应用也十分广泛，例如 Android、iPhone、Nokia’s 60 系列的手机浏览器所使用的内核引擎，都是基于 WebKit。 一个浏览器的诞生既然是开发浏览器，很重要的一点就是如何展示浏览器界面，WebView 控件是 OS X 平台上负责展现 Web 内容、实现和用户交互的核心控件，相比 IOS 平台上同类型的 UIWebView，它功能更强大（先挖个坑，以后有机会再介绍手机浏览器上的 UIWebView）。 下面用一个 Demo（源码：https://github.com/hxzqlh/WebView-Tutorial）来说明一下 WebView 主要的 api 接口, 最终效果如下图所示： 该 Demo 实现的是一个微型浏览器，包含了基本的前进、后退、刷新、回车访问 url，点击 Go 按钮访问 url，在标题栏显示网站的标题等功能。 实现过程：一、首先要引入 WebKit.framework。 #import &lt;WebKit/WebKit.h&gt; 二、从 Library 面板拉一个 WebView 控件，在程序创建该 WebView 控件的object，比如名字为 webView，并通过 IBOutlet 关联起来。通过发送下面的消息让 WebView 控件加载一个网页。 [[webView mainFrame] loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;www.google.com&quot;]]; 至此，WebView 控件就可以展示网页了。也就是说只要一行代码就可以简单实现一个浏览器展示页面的功能。 三、跟踪 WebView 整个 loading 的过程，用到 WebFrameLoadDelegate。 1.加载过程： 在访问一个网页的的整个过程，包括开始加载、加载标题、加载结束等。webkit 都会发送相应的消息给 WebFrameLoadDelegate 。 webView:didStartProvisionalLoadForFrame:—开始加载，我们可以在这里获取加载的 url，并展示出来 webView:didReceiveTitle:forFrame:—获取到网页标题 webView:didFinishLoadForFrame:—加载完成，我们可以在这里设置前进后退按钮的状态 2.错误的处理： 加载的过程当中，有可能会发生错误。错误的消息也会发送给WebFrameLoadDelegate。我们可以在这两个函数里面对错误信息进行处理 webView:didFailProvisionalLoadWithError:forFrame: 这个错误发生在请求数据之前，最常见是发生在无效的URL或者网络断开无法发送请求 webView:didFailLoadWithError:forFrame: 这个错误发生在请求数据之后 3.显示 loading 状态： 网页只有在加载完成后，才会被展示出来。加载过程如果很久的话，会一片空白然后才出来网页。为了让我们的网页更加人性化，可以在webView:didStartProvisionalLoadForFrame: 加一些 loading 的状态 四、处理加载策略，用到 WebPolicyDelegate 在 safari 浏览器，对于网页里面有 target=_blank 的链接，默认行为是点击后会弹出新的标签窗口。 如果在我们的 webView 控件里面点击此类链接的时候，会触发该消息并会发送给 WebPolicyDelegate，然后我们可以在这里控制对该事件的处理。比如我们可以使用我们自定义的控件打开该url。 12345678910//网页里面target=_blank的链接，在这里捕获，并在这里控制对该事件的处理。- (void)webView:(WebView *)sender decidePolicyForNewWindowAction:(NSDictionary *)actionInformation request:(NSURLRequest *)request newFrameName:(NSString *)frameName decisionListener:(id &lt; WebPolicyDecisionListener &gt;)listener&#123; NSURL *URL = [request URL]; //在当前窗口打开 [[webView mainFrame] loadRequest:[NSURLRequest requestWithURL:URL]]; //也可以用默认浏览器打开 //[[NSWorkspace sharedWorkspace] openURL:URL]; //或者也可以加代码，新建一个tab打开&#125; 前进，后退，刷新等按钮的事件，可以直接绑定到 WebView 控件的 goForward、goBack、reload 事件，而不需要我们自己写事件去处理。 主要代码：12345678910111213141516171819202122232425//// AppDelegate.h// WebView-Tutorial//// Created by hxz on 9/9/15.// Copyright (c) 2015 vobile. All rights reserved.//#import &lt;Cocoa/Cocoa.h&gt;#import &lt;WebKit/WebKit.h&gt;@interface AppDelegate : NSObject &lt;NSApplicationDelegate&gt;@property (weak) IBOutlet NSWindow *window;@property (weak) IBOutlet WebView *webView;@property (weak) IBOutlet NSButton *btnGoBack;@property (weak) IBOutlet NSButton *btnGoForward;@property (weak) IBOutlet NSButton *btnReload;@property (weak) IBOutlet NSTextField *navBar;@property (weak) IBOutlet NSButton *btnGo;- (IBAction)clickGo:(id)sender;- (IBAction)enterTogo:(id)sender;@end 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111//// AppDelegate.m// WebView-Tutorial//// Created by hxz on 9/9/15.// Copyright (c) 2015 vobile. All rights reserved.//#import "AppDelegate.h"@implementation AppDelegate@synthesize btnGoBack;@synthesize btnGoForward;@synthesize btnReload;@synthesize navBar;@synthesize webView;- (void)applicationDidFinishLaunching:(NSNotification *)aNotification &#123; // Insert code here to initialize your application&#125;- (void)applicationWillTerminate:(NSNotification *)aNotification &#123; // Insert code here to tear down your application&#125;- (void) awakeFromNib &#123; //设置delegate [webView setFrameLoadDelegate:self]; [webView setPolicyDelegate:self]; [[webView preferences] setPlugInsEnabled:YES]; [navBar setStringValue:@"http://www.baidu.com"]; [self onGo];&#125;//加载网站- (void)onGo&#123; NSString *urlString = [navBar stringValue]; if(![urlString hasPrefix:@"http://"])&#123; urlString = [NSString stringWithFormat:@"http://%@",urlString]; &#125; NSLog(@"onGo url:%@",urlString); [[webView mainFrame] loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:urlString]]];&#125;- (IBAction)clickGo:(id)sender&#123; [self onGo];&#125;//回车访问网站- (IBAction)enterTogo:(id)sender&#123; [self onGo];&#125;//开始加载,可以在这里加loading- (void)webView:(WebView *)sender didStartProvisionalLoadForFrame:(WebFrame *)frame&#123; NSString * currentURL = [webView mainFrameURL]; [navBar setStringValue:currentURL]; NSLog(@"webview url:%@",currentURL);&#125;//收到标题，把标题展示到窗口上面- (void)webView:(WebView *)sender didReceiveTitle:(NSString *)title forFrame:(WebFrame *)frame&#123; NSLog(@"receive title:%@",title); // Report feedback only for the main frame. if (frame == [sender mainFrame])&#123; [[sender window] setTitle:title]; &#125;&#125;//加载完成- (void)webView:(WebView *)sender didFinishLoadForFrame:(WebFrame *)frame&#123; //设置前进，后退按钮的状态 if (frame == [sender mainFrame])&#123; [btnGoBack setEnabled:[sender canGoBack]]; [btnGoForward setEnabled:[sender canGoForward]]; &#125;&#125;//错误处理:如无效的URL或者网络断开无法发送请求- (void)webView:(WebView *)sender didFailProvisionalLoadWithError:(NSError *)error forFrame:(WebFrame *)frame&#123; &#125;//错误处理- (void)webView:(WebView *)sender didFailLoadWithError:(NSError *)error forFrame:(WebFrame *)frame&#123; &#125;//网页里面target=_blank的链接，在这里捕获，并在这里控制对该事件的处理。- (void)webView:(WebView *)sender decidePolicyForNewWindowAction:(NSDictionary *)actionInformation request:(NSURLRequest *)request newFrameName:(NSString *)frameName decisionListener:(id &lt; WebPolicyDecisionListener &gt;)listener&#123; NSURL *URL = [request URL]; //在当前窗口打开 [[webView mainFrame] loadRequest:[NSURLRequest requestWithURL:URL]]; //也可以用默认浏览器打开 //[[NSWorkspace sharedWorkspace] openURL:URL]; //或者也可以加代码，新建一个tab打开&#125;@end]]></content>
  </entry>
</search>
