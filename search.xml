<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[论微服务架构及其应用]]></title>
    <url>%2F2020%2F11%2F12%2FOn-Microservice-Architecture-and-Its-Application%2F</url>
    <content type="text"><![CDATA[近年来，随着互联网行业的迅猛发展，公司或组织业务的不断扩张，需求的快速变化以及用户量的不断增加，传统的单体（Monolithic）软件架构面临着越来越多的挑战，已逐渐无法适应互联网时代对软件的要求。在这一背景下，微服务架构模式(Microservice Architecture Pattern)逐渐流行，它强调将单一业务功能开发成微服务的形式，每个微服务运行在一个进程中；采用HTTP等通用协议和轻量级API实现微服务之间的协作与通信。这些微服务可以使用不同的开发语言以及不同数据存储技术，能够通过自动化部署工具独立发布，并保持最低限制的集中式管理。 请围绕“论微服务架构及其应用”论题，依次从以下三个方面进行论述。 概要叙述你参与管理和开发的、采用微服务架构的软件开发项目及在其中所担任的主要工作。 与单体架构相比较，微服务架构有哪些特点？请列举至少4个特点并进行说明。 结合你参与管理和开发的软件开发项目，描述该软件的架构，说明该架构是如何采用微服务架构模式的，并说明在采用微服务架构后，在软件开发过程中遇到的实际问题和解决方案。 试题出自试卷《2016年下半年系统架构设计师考试论文真题》 摘要2018年1月，我所在的部门因公司业务发展需要，承担了公司的实时消息平台的研发工作。该平台提供了即时通讯、消息推送、社交圈等功能，满足C2C（用户对用户）、C2B（用户对商家）、B2C（商家对用户）的沟通需求，同时为公司内其它业务子系统间消息流转提供支持。该项目于2018年6月开始投产运行，但经过一段时间的运行后，单体架构的1.0版本系统无法适配业务的高速迭代，模块间很容易互相影响，版本发布成本非常高。因此，2018年9月，公司任命我为该项目的系统架构师兼开发负责人，负责项目的架构评审、改造设计及实现。本文结合作者的实践，以消息平台为例，讨论微服务架构及其应用，包括微服务的基本概念及特点，如何从单块架构迁移到微服务架构，以及在实现微服务架构的过程中遇到的问题及其解决方案等。 正文随着移动互联网技术的迅猛发展，我所在的公司的在各业务子系统的开发过程中发现，用户、商户、客服之间进行沟通的需求越来越大，各业务子系统间进行消息流转的需求愈加频繁，且使用起来十分繁琐不便。为此，公司于2018年1月开始研发设计通用的实时消息平台（以下简称为“系统“）。该系统致力于为公司内各业务产品线提供基础通用的消息服务，降低公司内各业务子系统间进行信息交互的复杂度，满足C2C（用户对用户）、C2B（用户对商家）、B2C（商家对用户）的沟通需求。该系统为C端用户提供了私聊、群聊、密聊、聊天室、漂流瓶等多形式多场景的即时通讯功能，同时，该系统还支持公司内各业务子系统间进行消息流转，如B端商家通过该系统可以定向地为用户实时推送各种业务消息，如订单消息、活动促销消息等。 该项目于2018年6月开始上线运行，由于V1.0版本开发过程中存在明显的赶工现象，模块间的解耦设计没有做到位，整体修改成本比较大。另一方面，随着时间的推移，系统的并发业务量也越来越大，业务对于系统的可靠性、高并发等要求也越来越高。单体架构的V1.0版本无法进行动态扩展，难以满足业务的高速迭代需求。因此，2018年9月，公司任命我为该项目的系统架构师兼开发负责人，主持项目的架构评审，改造设计及实现。根据项目的当前情况以及业务需求，经过研发团队的探讨，我决定采用微服务架构来对项目进行改造。 微服务，顾名思义，就是将原应用程序拆分成一个个细粒度的服务，服务单独部署，服务之间通过标准的API接口进行相互通信。与单体架构相比较，微服务架构具有以下特点： （1）通过服务实现组件化。由于单个微服务实现简单，能够聚焦于一个指定的业务功能或业务需求，每个服务对外提供统一的轻量级REST接口，实现组件化。 （2）功能明确，易于理解。微服务更容易被开发人员理解、修改和维护，这样小团队能够更关注自己的工作成果，降低沟通成本。 （3）围绕业务功能构件开发团队。采用微服务架构，围绕业务功能来构件开发团队，这样更符合企业的分工与组织结构，便于管理，避免出现一个开发团队负责维护多个系统服务的情况。 （4）支持多种开发语言与多种平台。不同的微服务能使用不同的语言进行开发，运行在不同的操作系统平台上，服务之间通过标准的REST接口和统一的轻量级JSON数据格式进行交互与协作。 （5）离散化数据管理。在微服务架构中，无法创建或维护统一的数据模型或结构，全局数据模型将在不同的系统之间有所区别，需要进行数据模型的离散化管理。 （6）基础设施自动化。微服务强调以灵活的方式集成自动部署，通过CI持续集成工具实现基础设施自动化，所以一般微服务都离不开DevOps。 在决定采用微服务架构之后，第一步要进行的是服务划分。这是一个持续演化的过程，一方面小步快跑、有节奏地对老系统进行服务化拆分，拆分的原则是高内聚低耦合以及保持服务的粗粒度；另外一方面，现有的技术团队当时比较缺乏微服务的实践经验，还需要一定的时间去适应一套新的技术架构。综合这两个因素，我首先选择了一个最简单的群组管理模块来实现微服务，并新建了一个单独的Git分支，进行独立的代码管理，而不是在原有系统分支上进行克隆改造，避免受到原有代码的影响。 第二步是组建微服务团队。高效的微服务团队需要是一个全栈的团队，跨职能的团队，应该包含整个项目周期的所有技能，前后端开发、UI设计、测试、构建部署、上线与运维都是必须技能。也就是说，微服务团队除了熟练的业务逻辑开发之外，还需要有DevOps能力、服务的快速构建、良好的团队文化等等。所以在这一步，我从其他团队中调配了一名熟悉DevOps工程师过来，搭建Jenkins，集成Gitlab，Sonarqube，实现代码的自检、应用的自动化构建和自动化部署。另外，也从原有开发团队抽出相应的前后端开发人员、UI以及测试人员，建立一个独立于原系统的开发团队，即实现了一个团队维护两套系统到两个团队维护两个系统的转变。 第三步是技术栈选型。原项目使用的是Java技术体系的SpringMVC架构，鉴于开发效率、团队开发人员的语言熟悉度、部署方便等因素，最终我改用Go语言进行重写，选择Go-micro微服务框架。运行时支撑服务选型方面，服务注册和配置中心选择使用在 Kubernates 经过大规模生产验证的 Etcd；服务网关选择的是Gin框架。服务监控方面，主要包括日志监控，调用链监控，Metrics 监控，健康检查和告警通知等产品。日志监控采用ELK（Elasticsearch+Logstash+Kibana），调用链监控业内比较流行的Jaeger。服务容错方面，采用Hystrix，把熔断、隔离、限流和降级等能力封装成组件，任何依赖调用（数据库，服务，缓存）都可以封装在 Hystrix 的 Command 之内，封装后自动具备容错能力。 第四步是改造实现。首先针对原来的群组管理模块进行分析整理，抽取一些可以复用的设计，达到资源的最大利用。由于群组管理模块相对比较独立，与其他模块的耦合依赖较少，所以对原系统的改造也比较少。最终，经过两个星期的改造，群组管理模块的所有功能成功迁移到微服务架构中。 完成了第一个微服务的迁移之后，我利用Nginx进行灰度发布，不断地进行迭代演化，逐渐提高微服务的整体占比，最终，消息平台V2.0于2019年1月份成功完成了微服务架构的迁移，原系统的所有服务都有序地整合到对应的微服务中，整个团队也成功实现了微服务转型。 结尾在整个微服务团队的齐心协力之下，原有的单体系统逐步被改造成了微服务架构，2019年1月，消息平台V2.0正式上线运行，至今已稳定运行了接近2年时间，改造后的系统相比V1.0更灵活、更加可扩展，能快速响应业务方的需求迭代演化，达到了项目的预期目标，获得了领导和同事的认可。但在微服务实践中，我们也遇到些问题，一是运维开销及成本增加，因为每个微服务需独立运行，这将导致资源开销大；第二个问题是难以可视化及全面测试，在动态环境下服务间的交互会产生非常微妙的行为。因此，首先服务划分应尽量合理，控制好“粒度”，不要划分得太细太多；其次，微服务可通过监控发现生产环境的异常，进而快速回滚，弥补可测性不足的问题。这些是我今后在微服务实践中需要注意的问题，我也将在后续的工作实践中不断地学习总结，提高自身素质和能力，带领技术团队为公司提供更高质量的技术服务，为业务保驾护航。]]></content>
      <categories>
        <category>即时通讯</category>
        <category>软考</category>
        <category>架构</category>
      </categories>
      <tags>
        <tag>消息平台</tag>
        <tag>系统架构设计师</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论软件可靠性设计技术的应用]]></title>
    <url>%2F2020%2F11%2F11%2FOn-the-Application-of-Software-Reliability-Design-Technology%2F</url>
    <content type="text"><![CDATA[随着软件的日益普及，系统中软件成分不断增加，使得系统对软件的依赖越来越强。软件的可靠性对系统可靠性的影响越来越大。而实践证明，保障软件可靠性最有效、最经济、最重要的手段是在软件设计阶段采取措施进行可靠性控制，为此提出了软件可靠性设计的概念。软件可靠性设计就是在常规的软件设计中，应用各种方法和技术，使软件设计在兼顾用户功能和性能需求的同时，全面满足软件的可靠性要求。软件可靠性设计应和软件的常规设计紧密结合，贯穿于软件设计过程的始终。 请围绕“软件可靠性设计技术的应用”论题，依次从以下三个方面进行论述。 概要叙述你参与管理和开发的软件项目以及你在其中所承担的主要工作。 结合项目实际，论述你在项目开发过程中，进行软件可靠性设计时遵循的基本原则；论述你在该项目中所采用的具体可靠性设计技术。 阐述你在具体的可靠性设计工作中，为了分析影响软件可靠性的主要因素，所采用的可靠性分析方法。 试题出自试卷《2013年下半年系统架构设计师考试论文真题》 摘要2018年9月，我所在的部门因公司业务发展需要，承担了公司的实时消息平台的研发工作。该平台提供了即时通讯、消息推送、社交圈等功能，满足C2C（用户对用户）、C2B（用户对商家）、B2C（商家对用户）的沟通需求，同时为公司内其它业务子系统间消息流转提供支持。我在该项目中担任系统架构设计师的职务，主要负责设计平台的系统架构和技术选型。本文以该系统为例，主要论述了软件系统可靠性的具体应用：通过架构设计风格降低软件系统的复杂度；通过集群和负载均衡技术实现系统容错；通过程序防卫式编程技术解决软件的容错和避错。事实证明，采用这些技术后，系统在可靠性、可扩展性、可用性等方面都达到了预期目标。系统自2019年2月上线后运行平稳，得到了领导和用户的一致好评。 正文随着移动互联网技术的迅猛发展，我所在的公司的在各业务子系统的开发过程中发现，用户、商户、客服之间进行沟通的需求越来越大，各业务子系统间进行消息流转的需求愈加频繁，且使用起来十分繁琐不便。为此，公司于2018年9月开始研发设计通用的实时消息平台（以下简称为“系统“）。该系统致力于为公司内各业务产品线提供基础通用的消息服务，降低公司内各业务子系统间进行信息交互的复杂度，满足C2C（用户对用户）、C2B（用户对商家）、B2C（商家对用户）的沟通需求。该系统为C端用户提供了私聊、群聊、密聊、聊天室、漂流瓶等多形式多场景的即时通讯功能，同时，该系统还支持公司内各业务子系统间进行消息流转，如B端商家通过该系统可以定向地为用户实时推送各种业务消息，如订单消息、活动促销消息等。 我作为单位技术骨干之一，主持并参与了项目计划制定、需求分析、整体架构设计与技术选型、底层设计、部分编码等多项工作。下面，我将首先介绍几种目前比较主流的软件可靠性分析和设计技术，然后详细介绍“消息平台”的分析和设计过程中所采用的可靠性设计技术及其原因。 在软件可靠性设计之前，需要采用软件可靠性分析和预测方法，来确定当前系统中的主要可靠性因素和目标。常见的可靠性分析方法包括故障树分析方法、失效模式与效应分析方法等。我在项目实践中，带领团队采用故障树分析方法进行可靠性分析。故障树分析方法是一种自顶向下的软件可靠性分析方法，从软件系统不希望发生的事件向下逐步追查导致事件发生的原因，直至基本事件，从而确定软件故障的原因。经过团队分析，我们找出了以下可能导致故障发生的几个主要因素： 一、运行环境：由于我们的应用是部署在第三方公有云上，系统所依赖的运行硬件是第三方云服务厂商提供，并不是完全可靠的，且厂商只提供了基本的服务器主机，外围安全环境（防火墙、集群搭建等）需由我们自己的运营团队负责维护； 二、软件规模及内部结构的复杂度：软件规模大小程度、内部结构复杂程度，都会影响系统的可靠性和开发测试的难度。因此，我们需要尽量降低主流程的复杂度，让整个架构实现更加可控； 三、开发人员水平：团队中各开发人员编码水平不一，对整个系统的业务理解层次也不一样，开发出的系统中难以避免会出现各类bug，进而影响系统的可靠性。 在完成可靠性分析后，我们接着评估了主流常见的可靠性设计技术：容错设计、检错设计和降低复杂度设计等。软件容错技术主要有恢复块设计、N版本程序设计和冗余设计三种方法，主要适用于软件失效后果特别严重的场合。恢复块设计就是选择一组操作作为容错设计单元，从而把普通的程序块变为恢复块。一个恢复块中包含有若干功能相同、设计差异的程序块，每一时刻有一个程序块处于运行状态，一旦某程序块出现故障，则用备份程序块予以替换。N版本程序设计的核心是通过设计出多个模块或不同版本，对于相同初始条件和相同输入的操作结果进行多数表决，防止因其中某一软件模块的故障而提供了错误的服务，以实现软件容错。软件冗余设计技术是采用多种不同路径、不同算法或不同实现方法的模块或系统作为备份，在出现故障时进行替换，维持系统的正常运行。检错设计主要应用于无需在线容错的地方或不能采用冗余设计技术的部分，出现故障后及时发现并报警。降低复杂度设计的思想就是在保证实现软件功能的基础上，通过简化软件结构，缩短程序代码长度，优化软件数据流向，来降低软件复杂度，从而提高软件可靠性。 由于消息平台的核心功能是为业务子系统传递消息，对可靠性有着较高的要求，一旦系统出现故障，将影响其它业务子系统的正常运行。我根据系统本身的特点，结合以上几点影响软件可靠性的主要因素，采取了提高系统可靠性的三点措施： 一、应用分层架构设计风格，降低软件设计的复杂度。 好的设计是成功的一半，在进行系统架构设计时，我认为采用分层架构比较符合实际情况。我通过技术调研和讨论分析，决定采用分层架构风格，将系统划分为接入层，逻辑层，数据层。其中，接入层负责处理来自客户端（PC/H5/App）的连接、断开请求，它不含具体的业务逻辑，因此可以实现动态水平扩展；逻辑层负责实现核心的消息处理逻辑，如私聊、群聊、密聊、漂流瓶、聊天室、消息推送等核心业务场景的实现；数据层负责提供数据存储访问服务，如数据库服务，缓存服务，文件服务，搜索服务等。系统层次结构清晰，各层职责明确，降低了系统的复杂度和维护成本。 二、集群和负载均衡技术实现系统容错。 我们采用了集群部署的方式，来提升应用系统的可靠性。由于我们系统采用了前后端分离的方式构建，前端采用主流的Vue框架，后端采用Gin框架。前端相关的Vue页面经过编译后，会生成html、javascript、css等静态资源，这些静态资源会部署在由两个Nginx实例组成的集群中。为了便于访问和提高Nginx集群的可靠性，Nginx集群的两台主机配置了VIP，同时通过keepalived实现双机热备。消息平台的接入层是无状态的，可以通过水平扩展的方式在业务高峰期提升处理能力，整个应用系统的部署架构上不存在单点故障。在数据层，为了解决MySQL的高可用问题，我们采用一主两从的主从部署模式，主节点负责读写操作，从节点只负责读操作，提高数据访问性能和效率。当主库发生问题时，可快速由其他的从库升级为主库，继续服务，达到容错的效果。 三、通过防卫式编程进行软件的容错与避错。 根据以往的架构经验，系统的不可靠大部分是由于程序内部的设计或者网络请求参数的配置或者连接池参数的配置不当所导致的，所以通过程序设计方面进行软件的容错是非常重要的。在程序设计方面的容错用的最普遍的就是防卫式程序设计。该系统在业务逻辑层的API接口中采用panic/defer/recover机制捕获异常，然后转换成统一的异常编码和描述信息，防止直接将业务异常和程序异常暴露给用户，提高用户的系统感知。同时在系统出现故障时，通过异常编码能快速地定位到后端具体的异常堆栈信息。为了解决网络或对方服务不稳定等因素的影响，我们采用了重试机制，如果出现接口调不通的情况，会分3次，每次按30秒、1分钟、2分钟逐级重试，如果3次都调不通，则跳过该次调用，等待下一次调用。 结尾最终项目成功上线，凭借软件设计过程中出色的可靠性设计，系统正常运行了近一年，收到各方好评。通过本次开发实践，我明白了软件的可靠性在实际应用中的重要地位，学习了提高可靠性相关的分析方法和设计技术，也深刻体会到了系统架构设计中可靠性和安全性的重要性。这些都是我在今后的系统架构设计工作中需要注意与改进的地方，也是日后我应该努力的方向。]]></content>
      <categories>
        <category>即时通讯</category>
        <category>软考</category>
        <category>架构</category>
      </categories>
      <tags>
        <tag>消息平台</tag>
        <tag>系统架构设计师</tag>
        <tag>可靠性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论信息系统的安全性与保密性设计]]></title>
    <url>%2F2020%2F11%2F10%2FOn-the-Security-and-Confidentiality-Design-of-Information-System%2F</url>
    <content type="text"><![CDATA[在企业信息化推进的过程中，需要建设许多的信息系统，这些系统能够实现高效率、低成本的运行，为企业提升竞争力。但在设计和实现这些信息系统时，除了针对具体业务需求进行详细的分析，保证满足具体的业务需求之外，还要加强信息系统安全方面的考虑。因为如果一个系统的安全措施没有做好，那么系统功能越强大，系统出安全事故时的危害与损失也就越大。 请围绕“信息系统的安全性与保密性”论题，依次从以下3个方面进行论述: 简述你参与设计的信息系统以及你所担任的主要工作。 详细论述你采用的保障网络安全和信息安全的技术和方法，并着重说明你所采用的软件、硬件安全产品以及管理措施的综合解决方案。 分析和评估你所采用的网络安全措施的效果及其特色，以及相关的改进措施。 摘要2018年9月，我所在的部门因公司业务发展需要，承担了公司的实时消息平台的研发工作。该平台提供了即时通讯、消息推送、社交圈等功能，满足C2C（用户对用户）、C2B（用户对商家）、B2C（商家对用户）的沟通需求，同时为公司内其它业务子系统间消息流转提供支持。我在该项目中担任系统架构设计师的职务，主要负责设计平台的系统架构和技术选型。本文以该项目为例，主要论述了安全技术和解决方案在项目中的具体应用。通过设置防火墙和加密技术保证内部网络的安全；在应用层采用RBAC模型和Token机制，解决了系统认证环节安全性；在数据层采用容灾备份和加密机制，解决数据抗突发风险的安全性问题。事实证明，采用这些安全技术后，系统在安全性、可扩展性、实时性等方面都达到了预期目标。系统自2019年2月上线后运行平稳，得到了领导和用户的一致好评。 正文随着移动互联网技术的迅猛发展，公司在各业务子系统的开发过程中发现，用户、商户、客服之间进行沟通的需求越来越大，各业务子系统间进行消息流转的需求愈加频繁，且使用起来十分繁琐不便。为此，公司于2018年9月开始研发设计通用的实时消息平台（以下简称为“系统“）。该系统致力于为公司内各业务产品线提供基础通用的消息服务，降低公司内各业务子系统间进行信息交互的复杂度，满足C2C（用户对用户）、C2B（用户对商家）、B2C（商家对用户）的沟通需求。该系统为C端用户提供了私聊、群聊、密聊、聊天室、漂流瓶等多形式多场景的即时通讯功能，同时，该系统还支持公司内各业务子系统间进行消息流转，如B端商家通过该系统可以定向地为用户实时推送各种业务消息，如订单消息、活动促销消息等。本项目组全体成员共10人，我在里面担任系统架构设计师职务，主要负责项目计划制定，需求分析，整体架构设计与技术选型。 信息安全体系结构包括鉴权服务、访问控制、数据完整性、数据机密性和抗抵赖性。其中鉴权服务提供了实体身份鉴别，防止身份冒用，一般采用“用户名+口令“、数字证书等方式实现；访问控制决定实体被授权使用哪些资源，它包括自主访问控制（DAC），强制访问控制（MAC）和基于角色的访问控制（RBAC）；数据完整性保证数据不以未授权方式进行修改或损毁，包括阻止对介质访问的机制和探测非授权修改的机制，前者一般采用隔离、访问控制列表、路由控制，后者一般采用数据签名、数据指纹等方式；数据机密性通过访问控制或加密机制实现确保信息仅仅是对被授权者可用；抗抵赖性主要通过数字签名等技术实现。 项目启动后，在架构设计工作的开始阶段，我们便意识到软件的安全性和保密性设计对系统有着重要的影响。根据以往类似系统的经验，系统的安全性需要从物理安全、网络安全、系统安全、应用安全和安全管理等多维度共同保障，缺失任何一环都可能会导致安全的漏洞。消息平台的核心功能是满足用户的基本的即时通讯需求和为公司内各业务子系统间进行消息流转，对信息的可靠性和安全性有着较高的要求，这些核心数据必须在安全可控的环境下访问。所以我们在设计阶段考虑从网络部署、数据库和应用层三个维度采取相对应的解决方案，具体阐述如下： 一、网络部署安全。 网络和硬件是系统的运行基础，也是很多外部攻击的首要目标，所以我们在设计阶段合理规划，将网络拓扑划分为外部网络、DMZ区和内部DCN网络三部分。我们将应用服务器和数据库服务器统一部署在内部DCN网络中，在DMZ区域部署反向代理服务器Nginx集群，Nginx负载均衡到应用服务器。为了防止来自外部的恶意攻击，我们再在外部网络和DMZ区网络之间设置了硬件防火墙。在Nginx集群中，我们配置只需要暴露的VIP，这样可以尽量降低我们内部应用服务器被攻击的可能性。由于我们应用采用前后端分离方式开发，前端静态页面和其他资源都部署在Nginx集群中，所以我们在Nginx中启用了HTTPS安全协议，通过建立信息安全通道，来保证数据传输的安全，防止内容被第三方冒充或者篡改，确保数据的完整性。对于DCN网络中的应用服务器和数据库服务器，我们限制不能直接通过IP地址访问，必须在4A系统登录认证后，通过跳板机才能访问，阻止了外界通过内部客户端代理的访问对服务器发起攻击。 二、应用层安全。 我们整个系统采用微服务架构风格，每个子系统采用了3层B/S架构风格。由于涉及的子系统人员和角色众多，我们采用RBAC授权模型，这样既增强了系统安全性，满足业务需求，同时也减轻了角色维护的负担。我们直接采用公司的架构中心已封装了统一认证组件，该组件在登录页面提供了用户名、密码和验证码，或者手机和动态验证码结合的访问方式，以此来达到防止非法访问的系统认证安全。密码在入库时采用MD5+salt加密，这样即使数据库中的密码泄露，也不会被解密。用户登录后访问具体的功能，需要调用API地址，所以API接口设计是该系统通信的安全基础，为了验证访问的有效性和时效性，防止外部人员非授权登录直接调用和窃取信息，我们采用Token机制保障每次调用的安全性，即在统一认证组件登录后，会生成token令牌，然后经过微服务的API网关组件调用API时，会获取到该token，解析出其中的时间戳和用户ID，然后调用统一认证组件的接口来验证其是否已登录和时间戳的有效性,充分保障了接口调用的安全。 三、数据层安全。 数据是整个消息平台的核心，其中涉及大量重要的信息资产，安全不容忽视。我们主要从数据存储、数据访问和数据容灾几方面进行了设计。由于该系统实现了配置数据的集中管理，包含了例如用户信息和服务器访问信息等敏感数据，为了防止泄露，我们在存储时进行了加密处理。虽然在处理中损失些性能，但是，提高了数据的安全性和保密性。在数据访问层面，我们的应用程序经过统一访问层组件UDAL才能访问MySQL数据库，在统一访问层设置了分表、分片策略和路由控制机制，实现了逻辑透明性，具有很好的伸缩性；同时在统一访问层设置了允许接入的应用服务器和容器的IP列表；设置了允许访问的IP白名单列表，同时开启了安全认证。通过限制IP列表的方式可以有效提升数据的完整性。针对我们采用的MySQL数据库，采用主备集群的方式部署，还制定了定期的全量、增量、差量的备份计划，保证数据能及时恢复，充分保证数据抗突发风险的安全。 实践证明，上述安全性和保密性方案的使用，极大的提高了系统的安全性，对维持系统的稳定运行起到了很好的效果。但在实施过程中也遇到过问题：随着各子业务系统用户量的快速增长，系统的性能下降很快，后经排查发现原因在于使用HTTPS协议虽然提高了安全性，但相比HTTP协议在交互过程中涉及到握手、建立安全通道、加密和解密等操作，消耗了大量的资源，因此，我决定在相对安全的内网环境仍然使用HTTP协议来提高通信效率、降低资源开销。事实证明以上方案行之有效，因处理及时没有对系统造成实质的影响。 结尾2019年1月，该系统正式上线运行，至今已稳定运行了接近2年时间，满足了用户常用的即时通讯需求，同时为公司内各大业务子系统提供了稳定、安全、可靠的消息服务支撑。截至目前系统运行稳定、安全可控，没有出现过明显的安全漏洞，得到了领导的认可和好评。通过这个项目本人更进一步了解到系统安全性和保密性的重要性。在今后的工作中我将不断总结和提升专业技术能力，争取为我国信息化事业贡献一份力量。]]></content>
      <categories>
        <category>即时通讯</category>
        <category>软考</category>
        <category>架构</category>
      </categories>
      <tags>
        <tag>消息平台</tag>
        <tag>系统架构设计师</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论软件系统架构风格]]></title>
    <url>%2F2020%2F11%2F09%2FOn-the-Architecture-Style-of-Software-System%2F</url>
    <content type="text"><![CDATA[系统架构风格（System Architecture Style）是描述某一特定应用领域中系统组织方式的惯用模式。架构风格定义了一个词汇表和一组约束，词汇表中包含一些构件和连接件类型，而这组约束指出系统是如何将这些构件和连接件组合起来的。软件系统架构风格反映了领域中众多软件系统所共有的结构和语义特性，并指导如何将各个模块和子系统有效地组织成一个完整的系统。软件系统架构风格的共有部分可以使得不同系统共享同一个实现代码，系统能够按照常用的、规范化的方式来组织，便于不同设计者很容易地理解系统架构。 请以“软件系统架构风格”论题，依次从以下三个方面进行论述： 概要叙述你参与分析和开发的软件系统开发项目以及你所担任的主要工作。 分析软件系统开发中常用的软件系统架构风格有哪些？详细阐述每种风格的具体含义。 详细说明在你所参与的软件系统开发项目中，采用了哪种软件系统架构风格，具体实施效果如何。 试题出自试卷《2017年下半年系统架构设计师考试论文真题》 摘要2018年9月，我所在的部门因公司业务发展需要，承担了公司的实时消息平台的研发工作。该平台提供了即时通讯、消息推送、社交圈等功能，满足C2C（用户对用户）、C2B（用户对商家）、B2C（商家对用户）的沟通需求，同时为公司内其它业务子系统间消息流转提供支持。我在该项目中担任系统架构设计师的职务，主要负责设计平台的系统架构和技术选型。本文以消息平台为例，论述了软件架构风格在项目中的应用，并阐述了选择层次结构、管道/过滤器和数据库系统三种架构风格在项目中组合应用的原因和效果，最后总结了在开发过程中遇到的问题及解决方式。实践证明，通过适当的架构风格选择和组合应用使开发工作取得了成功，消息平台于2019年1月验收上线，目前已稳定运行近2年时间，得到了领导和同事的一致认可和好评。 正文随着移动互联网技术的迅猛发展，我所在的公司的在各业务子系统的开发过程中发现，用户、商户、客服之间进行沟通的需求越来越大，各业务子系统间进行消息流转的需求愈加频繁，且使用起来十分繁琐不便。为此，公司于2018年9月开始研发设计通用的实时消息平台（以下简称为“系统“）。该系统致力于为公司内各业务产品线提供基础通用的消息服务，降低公司内各业务子系统间进行信息交互的复杂度，满足C2C（用户对用户）、C2B（用户对商家）、B2C（商家对用户）的沟通需求。该系统为C端用户提供了私聊、群聊、密聊、聊天室、漂流瓶等多形式多场景的即时通讯功能，同时，该系统还支持公司内各业务子系统间进行消息流转，如B端商家通过该系统可以定向地为用户实时推送各种业务消息，如订单消息、活动促销消息等。本项目组全体成员共10人，我在里面担任系统架构设计师职务，主要负责项目计划制定，需求分析，整体架构设计与技术选型。下面，我将首先介绍软件系统开发中常用的软件架构风格及具体含义，然后详细介绍在“消息平台”的分析和设计过程中所采用的架构风格及原因。 在架构设计开始阶段，我意识到选择合适的架构风格对架构设计的重要性，因此在基本需求确定后，首先对常用的经典架构风格进行了分析： 数据流风格：数据以流的形式进行处理，构件之间相对独立，包括管道过滤器和批处理程序两种架构风格。它的特点是每个构件都有一组输入和输出，构件读输入的数据流，经过内部处理，产生输出数据流。优点是构件具有良好的隐蔽性、高内聚低耦合、维护简单、支持重用；缺点是不适合处理交互的应用。 调用返回风格：利用分治法思想，将大问题拆分为小问题解决。包括主程序/子程序、面向对象和层次结构三种架构风格。它的特点是将系统划分多个层组成一个层次结构，每一层为上层服务，并调用下层接口，优点是支持功能增强和软件重用，缺点是分层困难。 独立构件风格：每个构件都是独立的个体，构件之间不能直接通信，有效降低耦合。包括进程通信和事件驱动系统两种架构风格，它的特点是构件不直接调用过程，而是触发一个或多个事件后自动调用。优点是支持并发执行和实时/增量响应；缺点是放弃了对系统计算的控制。 虚拟机风格：虚拟机风格包括解释器风格和基于规则的系统风格，其具有良好的灵活性，可自定义规则。具有解释器风格的软件中含有一个虚拟机，可以仿真硬件的执行过程和一些关键应用；缺点是执行效率较低。 数据仓储风格：由中央共享数据结构和独立构件构成。包括数据库系统、黑板风格和超文本系统三种架构风格，它的特点由中央数据源来保持当前数据状态，由独立构件对数据进行操作，优点是支持多种数据格式、扩展方便。缺点是需要一定的同步/加锁机制来保障数据结构的完整性和一致性。 软件架构风格可以为我们的系统提供架构级的通用解决方案，这种架构级的软件重用可以极大地提高系统开发效率。但是，单个架构风格的应用只能解决某一类问题，对于大型复杂业务系统往往需要多种架构风格混合并用。结合常用架构风格的适用场景和消息平台本身的业务特点，在本项目中我选择了层次结构、管道过滤器风格和数据库系统三种架构混合使用来满足系统要求。下面我将分别说明采用各架构风格的原因和具体应用： 分层架构风格，从提升系统的安全性、降低系统的开发和维护难度、保障系统的稳定性等维度考虑，我决定采用三层分层架构，将系统划分为接入层，逻辑层，数据层。其中，接入层负责处理来自客户端（PC/H5/App）的连接、断开请求，主要负责统一鉴权、保持长连接、初步攻防、加解密、压缩解压缩、限流等功能，接入层本身不含业务逻辑，它是无状态的，因此可以很方便地进行水平扩展。逻辑层，负责实现消息平台本身的核心业务逻辑处理，如私聊、群聊、密聊、聊天室、漂流瓶等业务场景，逻辑层还支持各个业务子系统接入到消息平台，实时推送业务消息给终端用户。数据层，负责提供数据存储访问服务，如数据库服务，缓存服务，文件服务，搜索服务等。 管道过滤器架构风格，消息平台中的核心业务逻辑是处理来自客户端发送的消息，其中，消息只有在接入层各组件校验通过后，才会转发到逻辑层进行后续处理，每一步的处理结果会带入到下一环节中，经过分析，以上特点符合管道过滤器架构风格。比如，在接入层中，用户发送的私聊信息，首先要经过解压缩过滤器得到压缩前数据，然后由解密过滤器解密出原始的消息内容，消息解析器得到符合我们平台消息协议的消息体，再经过限流器判断该发送者发送消息频率是否在正常阀值内，最后解析出消息中的接受者信息，根据接收者是否在线进行后续业务逻辑处理。从实际效果看，管道过滤器风格的应用，高效地解决了接入层中消息的解压缩、解密、限流等过程的性能问题，系统易于维护扩展。 数据库系统架构风格，消息平台中按照业务维度来划分主要有用户信息模块、群组信息模块、好友关系模块、即时通讯模块、消息推送模块等，为了保证业务处理的准确和及时，各模块间彼此需要共享数据，中央数据结构维护当前状态，业务逻辑组件在存储上执行操作，经过分析以上特点符合数据库系统风格。因该系统中各模块间数据存在大量复杂的逻辑关系，因此项目中使用了MySql关系型数据库。由于用户对数据的访问具有集中性，我们基于Redis实现了缓存服务，将用户访问频率较高的用户信息、群组信息、好友关系等置于缓存，减少对数据库的访问压力。从我们系统的业务特性来看，数据库操作是“读多写少”，所以我们对数据库进行了一主多从读写分离，提高数据访问效率，保障数据库服务的高可用。 结尾实践证明，多种架构风格的组合应用，使系统模块间耦合度降低，增强了系统的可扩展性，提升了程序的稳定性和可靠性。2019年1月，该系统正式上线运行，至今已稳定运行了接近2年时间，满足了用户常用的即时通讯需求，同时为公司内各大业务子系统提供了稳定可靠的消息服务支撑，获得了领导和同事的好评。但开发过程中也遇到过问题，如我们接入层采用的负载均衡算法是加权轮转算法，过于简单，常常出现资源分配不合理的现象，可将算法改进为加权最小连接数算法来解决。在今后的工作中我将不断总结和提升专业技术能力，带领技术团队为公司业务保驾护航。]]></content>
      <categories>
        <category>即时通讯</category>
        <category>软考</category>
        <category>架构</category>
      </categories>
      <tags>
        <tag>消息平台</tag>
        <tag>系统架构设计师</tag>
        <tag>架构风格</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论软件系统分层架构]]></title>
    <url>%2F2020%2F11%2F08%2FOn-the-Layered-Structure-of-Software-System%2F</url>
    <content type="text"><![CDATA[软件架构风格是描述一类特定应用领域中系统组织方式的惯用模式，反映了领域中诸多系统所共有的结构特征和语义特征，并指导如何将各个模块和子系统有效组织成一个完整的系统。分层架构是一种常见的软件架构风格，能够有效简化设计，使得设计的系统结构清晰，便于提高复用能力和产品维护能力。由于大量企业应用系统都由界面呈现、业务逻辑、数据存储三类功能构成，因此广泛采用分层架构风格进行系统设计。 请围绕“企业应用系统的分层架构风格”论题，依次从以下三个方面进行论述。 概要叙述你参与管理和开发的企业应用系统建设项目以及你在其中所承担的主要工作。 请结合项目实际情况，指出应用系统都有哪些层次以及每个层次的主要功能。 请结合项目实际情况，指出设计每个层次时需要注意的问题及相应的解决方案。 试题出自试卷《2013年下半年系统架构设计师考试论文真题》 摘要2018年9月，我所在的部门因公司业务发展需要，承担了公司的实时消息平台的研发工作。该平台提供了即时通讯、消息推送、社交圈等功能，满足C2C（用户对用户）、C2B（用户对商家）、B2C（商家对用户）的沟通需求，同时为公司内其它业务子系统间消息流转提供支持。我在该项目中担任系统架构设计师的职务，主要负责设计平台的系统架构和技术选型。本文以实时消息平台为例，讨论了软件分层架构的选择和应用。在该项目中，我结合实际业务需要，从开发和维护难度、稳定性、可靠性和可扩展性等方面综合衡量，为平台选择了接入层、逻辑层、数据访问层的三层分层架构。平台的研发耗时4个月，目前，系统已稳定运行了近2年。实践证明，这种架构设计有效的降低了系统的维护和开发成本，增强了系统的稳定性和可靠性，提高了系统的可扩展能力。 正文随着移动互联网技术的迅猛发展，我所在的公司的在各业务子系统的开发过程中发现，用户、商户、客服之间进行沟通的需求越来越大，各业务子系统间进行消息流转的需求愈加频繁，且使用起来十分繁琐不便。为此，公司于2018年9月开始研发设计通用的实时消息平台（以下简称为“系统“）。该系统致力于为公司内各业务产品线提供基础通用的消息服务，降低公司内各业务子系统间进行信息交互的复杂度，满足C2C（用户对用户）、C2B（用户对商家）、B2C（商家对用户）的沟通需求。该系统为C端用户提供了私聊、群聊、密聊、聊天室、漂流瓶等多形式多场景的即时通讯功能，同时，该系统还支持公司内各业务子系统间进行消息流转，如B端商家通过该系统可以定向地为用户实时推送各种业务消息，如订单消息、活动促销消息等。本项目组全体成员共10人，我在里面担任系统架构设计师职务，主要负责项目计划制定，需求分析，整体架构设计与技术选型。本文结合作者的实践，以消息平台系统为例，对比分析两层架构和三层架构，讨论三层架构中接入层、逻辑层和数据层的设计过程和实施方法。 在传统的C/S两层体系结构中，客户端用户界面和业务逻辑耦合在一起，用户界面层直接调用数据库访问实现。两层体系结构只适用于那些比较简单的企业应用系统中，但难以适应新的需求、不易维护、安全性差。三层结构则由表示层/接入层、业务逻辑层、数据访问层构成，表示层/接入层为用户提供交互操作界面，业务层负责关键业务的处理和数据传递，数据访问层实现数据访问。优势是当数据库或用户界面发生改变是不需要重新开发，只做简单的调整即可。基于三层结构来架构的应用系统具有稳定性、安全性和处理能力较高等特性，同时拥有可扩展性强、开发周期短等优点。 作为一个通用的实时消息平台，系统首先必须具备高可用性和高可靠性，其支持业务子系统对接的特点又决定了其必须具有良好的扩展能力。我通过技术调研和讨论分析，决定将系统划分为接入层，逻辑层，数据层。 接入层，是客户端接入消息平台的门户，主要负责统一鉴权、保持长连接，初步攻防，加解密，压缩解压缩等功能。为了防止DDOS等恶意网络攻击，我们采用了“WAF+DDos高防”安全策略来保护消息平台。接入层本身不含业务逻辑，它是无状态的，因此可以很方便得进行水平扩展，出于对成本与技术成熟度等方面的考虑，我们采用了基于Ngnix的负载均衡技术，以应对日益增长的数据吞吐量，提高平台的可用性。由于系统的核心业务是实现消息的实时传递，对连接的可靠性非常敏感，我们采用了“WebSocket技术 + 心跳机制”，保持客户端和消息平台的长连接。为防止恶意用户对消息平台进行洪泛攻击，在不影响正常业务功能的前提下，我们采用了令牌桶机制来限制客户端发送消息的频率，保障平台的稳定性和可用性。出于节省带宽流量方面的考虑，客户端与消息平台之间进行交互的消息都是经过加密、压缩过的，因此，接入层还需要对收到的客户端消息进行解压缩、解密，对推送给客户端的消息进行加密、压缩处理。 逻辑层，负责实现消息平台本身的核心业务逻辑处理，如私聊、群聊、密聊、聊天室、漂流瓶以及业务子系统的消息推送等业务场景。为增强系统的可用性和可扩展性，逻辑层也保持了无状态性，同样支持水平扩展。为解决无线环境下网络不稳定导致的“消息丢失”问题，系统收到消息后，先持久化到数据库，再进行相关的业务逻辑处理，以保证消息不会丢失。针对客户端“重复发送”消息的问题，我们采用了客户端和消息平台协同处理方案，具体为：客户端在发送的的消息体里带上唯一的消息标示码（如根据“用户Uid+当前时间戳毫秒”规则生成UUID），若逻辑层根据根据该标示码在数据层查询到该消息已存在，则直接返回消息重复错误给客户端。逻辑层还支持各个业务子系统接入到消息平台，具体实践中，我们通过引入kafka消息队列，将客户端发送的消息，根据业务方注册时绑定的主题，发送到相应的业务消息主题队列，以达到消息平台和业务模块的解藕。 另外，业务子系统也可通过逻辑层开放的RPC接口实时推送业务消息给客户端，实现了业务子系统和消息平台间的解耦。消息平台和业务子系统间进行双向消息传递均实现了解藕，新增业务子系统，消息平台无需改动代码，增强了系统的可扩展性，同时也降低了系统的维护成本。 数据层，涉及缓存，文件系统，数据库，搜索系统等模块。由于用户对数据的访问具有集中性，所以我们基于Redis实现了缓存机制，将用户访问频率较高的用户信息、群组信息等置于缓存，减少对数据库的访问压力。从我们系统的业务特性来看，数据库操作是“读多写少”，所以我们对数据库进行了一主多从读写分离。数据库访问采用了数据库连接池的技术，以固定的连接池大小为限，使用有限的数据库连接，提高对数据库操作的性能，保障数据库服务的高可用。开发实践中，我们采用了比较成熟的Gorm组件，用于实现数据和模型的绑定，该方法开发高效，敏捷，成本较低，而且兼容多种主流数据库，开发人员不必再去写大量繁琐的SQL语句，节省了开发成本。 结尾2019年1月，该系统正式上线运行，至今已稳定运行了接近2年时间，满足了用户常用的即时通讯需求，同时为公司内各大业务子系统提供了稳定可靠的消息服务支撑。系统所采用的三层分层架构在降低开发与维护难度、加强平台可用性、提高系统稳定性、增强系统可靠性等方面都发挥了重要的作用，获得了领导和同事的好评。当然，这种架构也存在一些不足，如我们接入层采用的负载均衡算法是加权轮转算法，过于简单，常常出现资源分配不合理的现象，可将算法改进为加权最小连接数算法来解决。分层架构所具有的优点和面临的问题将是我今后在同类系统的架构决策方面需要重点考虑的因素。]]></content>
      <categories>
        <category>即时通讯</category>
        <category>软考</category>
        <category>架构</category>
      </categories>
      <tags>
        <tag>消息平台</tag>
        <tag>系统架构设计师</tag>
        <tag>分层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[去中心化社交聊天架构]]></title>
    <url>%2F2020%2F06%2F13%2Fdecentralized-social-IM-arch%2F</url>
    <content type="text"><![CDATA[在传统的中心化的社交系统（如微信/QQ/微博/Twitter）中，有两大弊端： 匿名/隐私性问题：用户信息、通讯录信息完全掌握在聊天服务提供商中，用户无法真正自主掌控个人信息。 可用性问题：聊天服务的可靠性易受所在地区的政策、法律等不可抵外力因素的影响，一旦服务器被攻击或查封，用户数据也就丢失了。 为此，我们提出一种基于区块链的去中心化社交系统。 该系统由三部分组成： 区块链：利用其去中心化的本质特征，将用户最关心的用户信息、通讯录信息记录到区块链上，其他人无法篡改、伪造、查封其账号，用户可真正自主掌握个人信息。 客户端：直接面向用户的聊天App，一方面从区块链读写用户信息、一方面和聊天服务器建立长连接，收发消息。 聊天服务器：为用户提供消息发送、存储服务。只要遵从一定的协议，服务节点可随意加入、退出。面向各类终端用户群体，不同机构、企业可部署不同的聊天服务节点，这样各机构、企业节点可自主掌握其服务器产生的聊天数据。 下面，分别针对这三部分详细阐述： 区块链基于chain33开发框架的bty区块链支持各种平行链，我们的通讯录合约就是运行在一条平行链中。 合约记录内容： 个人信息：昵称、手机号等 好友关系：好友可设置tag实现分组 黑名单：可设置周期，如永久、一段时间 隐私权限：公开（默认，即任何人皆可根据地址查询该用户信息）、私有（只有本人才可查看）、规则（按照用户定义的某种规则确定其他人是否有权限查看其用户信息，比如：A设置了tag为“朋友”的用户才可查看其用户信息） 最近登录的聊天服务节点：我们假设，用户转移聊天服务节点的频率是比较低的。当用户连接上某个可用的聊天节点时，会将该节点写入合约，其他用户方可通过合约查询到该用户目前在哪个聊天节点，从而调用该聊天节点的发消息接口给该用户。这样，实现了不同服务器节点间用户的通讯机制。 客户端假设用户为A： 生成、导入用户身份：能唯一标示用户身份的是区块链地址（助记词–&gt;私钥–&gt;公钥–&gt;地址） 登录、退出服务器：A登录（助记词/手机号/邮箱）时，若客户端本地缓存了用户上次登录过的服务器节点，假设为 srv-A，则向该节点建立连接，否则，将到区块链查询A最近登录的服务器节点。 收发消息：和服务器节点建立连接后，A只会在该服务器节点接收消息。假设此时有另外一个用户B要发消息给A，B需先得知目前A在哪个服务器节点（同样可通过查询合约获得）： B和A在同一个服务器：B通过长连接往 srv-A 发消息给 A B和A不在同一个服务器：B调用 srv-A 的 rpc 接口发消息给 A 客户端不应将区块链节点或聊天服务器节点写死，而应分别做成配置： 区块链节点列表 聊天服务节点列表 初始化时，从官方提供的注册中心拉取节点列表，若节点列表均不可用，要能支持用户手动输入某个节点。 客户端按照某种策略（如轮询、加权轮询、哈希、随机）自主选择某个区块链节点或服务器节点进行相关服务请求。这里之所以采用客户端进程内负载均衡也是为了避免某服务端节点故障导致客户端不可用。 客户端连接上某个服务器节后，应缓存在本地，以便下次复用，避免频繁写入区块链合约。 服务器一个最简单的聊天服务器只需提供三个功能： 鉴权：客户端跟服务器建立连接后，客户端调用该接口验证身份，客户端和服务器保持ws长连接，方便推送消息 发送消息：例如 A → B 箭头方向 推送消息：通过ws长连接推送消息给接受者所在客户端]]></content>
      <categories>
        <category>Blockchain</category>
        <category>即时通讯</category>
        <category>架构</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>架构</tag>
        <tag>社交</tag>
        <tag>IM</tag>
        <tag>去中心化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[千万气象，天高水长]]></title>
    <url>%2F2019%2F12%2F24%2Fhigh-weather-and-long-water%2F</url>
    <content type="text"><![CDATA[结婚四周年快乐😊 圣诞夜快乐😊 感谢老婆大人一路的陪伴和支持😊 往后余生期待我们更加坚实地一起走过😊 借用《鹤唳华亭》里面的经典台词，以应此景。 云山苍苍，江水泱泱，千万气象，天高水长。在此山河不必登仙，心亦宽广。]]></content>
      <categories>
        <category>心旷神怡</category>
      </categories>
      <tags>
        <tag>结婚</tag>
        <tag>圣诞夜</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数字货币交易所后台架构]]></title>
    <url>%2F2019%2F12%2F14%2Fexchange-backend-arch%2F</url>
    <content type="text"><![CDATA[基于区块链技术的数字资产交易系统，为全球用户提供7x24小时数字资产交易服务。类似国内的火币/Okex交易所，交易平台为用户提供充币、提币、下单、撤单、查询订单记录、行情信息等业务功能。 本系统的特色在于，底层戳和引擎是基于区块链技术，将用户资产和交易记录写入区块链，既可避免出现传统去中心化交易系统被黑客攻击导致的用户资产损失现象，保障用户资产安全，也可保证用户的每笔交易记录都是无法篡改的。 后台参考架构如下： 关键模块 gate：提供对用户资产、订单记录、行情、深度、k线、成交记录的查询接口，部分接口支持ws parse：交易解析程序，拉取区块链最新交易信息（挂单、撤单、转账、成交记录）至数据库 redis：缓存区块链行情、深度、用户近3月订单历史、最新成交记录 mysql：解析数据库，存储用户信息、资产信息、交易记录、成交记录 mq: 消息队列 ops: 异步下单子模块，接收客户端的交易请求，生成订单信息写入用户订单表，发送到mq rfs：异步下单子模块，从mq消费客户端交易请求，将请求转发到区块链戳和引擎 缓存 market（深度、行情）：每隔0.5s从区块链合约读取，丢到缓存 订单记录：缓存用户近3月至多1000条记录 最新成交记录（提供给机器人）：缓存最近5分钟内的成交细节 活跃订单： 若只显示已经上链的订单，可以从区块链合约读取 若显示挂单中和已经上链的订单，则必须从 db 中读取（目前采用此方式） 分表老版的解析数据库是按照交易对进行分表，一个交易对的历史订单存在一个表里面，此法的缺点是： 历史订单数据只会越来越多，影响查询（实际查询只需返回近3月历史） 交易历史分散在不同的交易对表，如果要追踪一个用户的交易行为，需要查询多个表 改动：订单和成交记录按月分表，“缺点”是查询需要同时查多个表数据后汇总（这个对开发人员来说小菜一碟），优点： 历史数据不会影响查询效率 所有用户的交易历史固定在一个表（单个月而言），方便追踪用户的交易行为 方便迁移（最快只需拷贝近3/4个月数据） 异步下单老版系统的用户下单接口是同步的，直接将用户交易请求发送给区块链并等待区块链打包、共识、出块响应交易处理结果，TPS明显不高。 异步模式： ops 模块：接收客户端的交易请求，生成订单信息写入用户订单表，发送到 mq，这样交易请求就算是成功接收了，直接返回用户订单id给客户端。内部利用定时/定量的批量入库机制，每0.5秒或累计接收1000笔交易就往数据库写一次盘，提升写数据库的效率。 rfs 模块：从mq消费客户端交易请求，将请求转发到区块链戳和引擎处理，并更新对应用户订单的处理结果。 ops 写入 instructionId（即客户端拿到的用户订单id），rfs 查询到该交易戳和完成后更新 instructionId 对应的区块链订单id。 instructionId 区块链订单id 193034729012 2035 用户的 真实资产 记录在区块链合约中，由于采用了异步下单机制，用户的 实际可用资产 需要根据用户下单后立即更新（即使该订单还未进戳和引擎或未被戳和引擎处理完），防止用户的实际可用资产不足挂一些无效单，根据订单状态的变化，及时更新资产（冻结、可用） 用户的可用资产 = 从区块链读到的可用资产 - 异步下单冻结的买单部分资产 用户的冻结资产 = 从区块链读到的冻结资产 - 异步下单冻结的卖单部分资产 TODO ops/rfs异步下单流程 戳和流程 风控模块设计思路]]></content>
      <categories>
        <category>架构</category>
        <category>交易所</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>数字货币</tag>
        <tag>exchange</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通用消息平台架构]]></title>
    <url>%2F2019%2F07%2F16%2Fcommon-im-message-arch%2F</url>
    <content type="text"><![CDATA[消息平台是高可用、高并发、可伸缩的分布式系统，致力于为公司内各业务产品线提供基础通用的消息服务，降低公司内各业务子系统间进行信息交互的复杂度，满足C2C（用户对用户）、C2B（用户对商家）、B2C（商家对用户）的沟通需求。 消息平台为C端用户提供了私聊、群聊、密聊、聊天室、漂流瓶等多形式多场景的即时通讯功能，同时，平台还支持公司内各业务子系统间进行消息流转，如B端商家通过该系统可以定向地为用户实时推送各种业务消息，如订单消息、活动促销消息等。 1.0消息平台第一个版本为了快速响应业务需求，是一个单体架构： 接入层、逻辑层、存储层全部在一个进程内实现，最大缺点就是无法水平扩展。 2.0系统将接入层、逻辑层、数据层微服务化，实现水平可扩展。架构如下： 关键模块 comet：消息平台的接入门户(支持 ws/tcp)，保持长连接，初步攻防（消息频率限制），加解密，压缩解压缩，水平可扩展 logic：消息平台内部对消息的处理逻辑，无业务逻辑（app-server部分负责），只维持用户在线状态，对消息进行在线投递或离线存储，水平可扩展 cache：高可用redis集群，存储用户在线状态，以及用户在哪一台comet接入（如果在线） mq： 消息队列，logic将消息投递到mq中对应业务方的topic队列，业务方从它订阅topic队列中消费消息，即不同业务方的消息会投递到不同的主题队列 job: 消费mq里的发往客户端的消息，将消息发送到comet，水平可扩展 etcd：服务注册发现/配置中心 业务对接 APP/PC/Web：业务方客户端，可以有多个，如聊天客户端、交易所客户端、电商客户端 app-server：业务方服务端，可以有多个，如聊天服务端、OTC服务端、电商服务端等，负责处理消息对应的具体业务逻辑。 comet 接口 PushMsg： 往msg接收方对应的连接写msg logic 接口 Connect：用户建立连接 Disconnect：用户关闭连接 HeartBeat：连接保持心跳 Receive：接收客户端消息 Push：业务服务端推送消息给客户端 TODO 消息不丢不重 端对端加密聊天]]></content>
      <categories>
        <category>即时通讯</category>
        <category>架构</category>
      </categories>
      <tags>
        <tag>消息平台</tag>
        <tag>分布式</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fabric 简介]]></title>
    <url>%2F2019%2F04%2F18%2FIntroduce-to-Fabric%2F</url>
    <content type="text"><![CDATA[Fabric 是超级账本联盟(Hyperledger)的主要项目之一，其作为一个私有或“许可”型区块链网络，目前它主要被用于金融和供应链等行业。至今，Fabric已获得了阿里巴巴、AWS、Azure、百度、谷歌、华为、IBM、甲骨文、腾讯等互联网巨头的支持。 Fabric 是一个分布式账本解决方案平台，采用 模块化 架构，支持不同组件的 可插拔 实现，以适应业务系统的复杂性。 架构设计 三大组件：区块链服务（Blockchain）、链码服务（Chaincode）、成员权限管理（Membership）。 区块链服务 提供一个分布式账本平台。 多个交易被打包进区块中，多个区块构成一条区块链。 区块链代表的是账本状态机发生变更的历史过程。 交易意味着围绕着某个链码进行操作，交易可以改变世界状态。 世界观：世界状态, 用于存放链码执行过程中涉及到的 状态变量，是一个键值数据库。典型的元素为 [chaincodeID, ckey]: value 结构。 链码服务在 Fabric 中，智能合约叫做链码 (Chaincode)，它包含所有的业务处理逻辑，并对外提供接口，外部通过调用链码接口来改变世界观。 链码需要实现 Chaincode 接口，以被 VP（Validating Peer,验证节点）节点调用，目前支持的交易类型包括：部署（Deploy）、调用（Invoke）和查询（Query）。不同链码之间可能互相调用和查询。 在实现上，链码需要运行在隔离的 容器 中，超级账本采用了 Docker 作为默认容器。对容器的操作支持三种方法：build、start、stop，对应的接口为 VM。 链码部署成功后，会创建连接到部署它的 VP 节点的 gRPC 通道，VP 节点和容器之间通过 gRPC 消息来交互。 成员权限管理通过基于 PKI 的成员权限管理，平台可以对接入的节点和客户端的能力进行限制。证书有三种: 注册证书 ECert：颁发给提供了注册凭证的用户或节点，一般长期有效； 交易证书 TCert：颁发给用户，控制每个交易的权限，一般针对某个交易，短期有效。 通信证书 TLSCert：控制对网络的访问，并且防止窃听。 角色管理节点角色是 Fabric 设计中的一大创新，根据性能和安全需求，不同的节点可以由不同的组织分别管理，彼此协作完成整个区块链系统的记账功能： 背书节点（Endorser Peer）：负责对交易的提案（Transaction Proposal）进行验证并进行 模拟 执行。背书节点相当于中立的第三方，用来保证交易的合法性； 记账节点（Committer Peer）：负责维护账本，检查排序后交易结果合法性，接受合法修改，并写入到本地账本结构，目前所有 Peer 默认都是记账节点； 排序节点（Orderer）：正式交易会发给排序节点，排序节点负责对网络中所有交易进行排序处理，并整理为区块结构，之后被记账节点拉取提交到本地账本； 证书节点（CA）：提供标准的 PKI 服务，负责对网络中所有的证书进行管理，包括签发和撤销。 通道网络账本的基本单位是 通道（Channel），每个通道内的成员可以共享账本，不同通道内账本则彼此隔离。客户端可以向网络内发送交易，交易经过共识后被通道内的 Peer 节点接收并更新本地对应的账本。类似 chain33 的平行链概念。 交易流程 上图中，客户端（App）使用 SDK 与 Fabric 网络进行交互。 客户端先通过证书服务获取合法的身份并加入到应用通道（Channel）中。 客户端构造交易请求（Proposal）提交给背书节点（Endorser）。 背书节点对交易进行验证和模拟执行后（并不真正更新账本），反馈给客户端。 客户端收到足够的背书支持后将交易发送给排序节点（Orderer）。 排序节点（Orderer）对网络中的交易进行全局排序，并将排序后的交易打包成区块，然后广播给网络中的记账节点（Committer）。 记账节点（Committer）负责维护区块链和账本结构，对交易进行最终检查（交易结构的合法性、交易背书签名是否符合背书策略等），检查通过后写入账本。]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>Fabric</tag>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个简单的消息路由器v2.0]]></title>
    <url>%2F2019%2F03%2F01%2Flevel-msg-queue%2F</url>
    <content type="text"><![CDATA[先回顾下，消息路由器v1.0 的主要特征如下： 每个消息在生成时指定消息类型 不同类型的消息分发到不同的消息队列 不同类型的消息由不同的消息处理器消费 消息消费完成后可以执行回调逻辑 第二版主要新增了一个功能： 支持多优先级消息队列 在某些业务系统中，接收到消息后，为了确保系统宕机后，之前未处理成功的消息也能恢复出来，一般是先把消息写入一个日志队列，成功后，然后再把消息写入业务逻辑队列。 来看下具体的代码改动： IQueue 接口增加返回优先级方法 1234type IQueue interface &#123; Send(msg *Message) GetLevel() int&#125; 规定：GetLevel() 返回的数值越小，优先级越高。 消息路由器生成新消息时，可以指定该消息路由的顺序：从优先级高的队列链式执行到优先级低的队列，处理完成后执行回调函数 cb。 这里，msgTypes 必须保持增序，比如，[]{1,2,3}， 同优先级的可以并列出现，比如，[]{1,2,2,3} 1func (s *QueueSwitch) NewMessage(data interface&#123;&#125;, cb MessageCB, msgTypes ...MessageType) (*Message, error) 看下具体的代码细节： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950func (s *QueueSwitch) NewMessage(data interface&#123;&#125;, cb MessageCB, msgTypes ...MessageType) (*Message, error) &#123; ... var fn func(*Message) for i := len(msgTypes) - 1; i &gt;= 0; i-- &#123; if i == len(msgTypes)-1 &#123; fn = s.createLastFn(msgTypes[i], cb) &#125; else &#123; level1 := s.queues[msgTypes[i]].GetLevel() level2 := s.queues[msgTypes[i+1]].GetLevel() if level1 &gt; level2 &#123; return nil, ErrMessageLevel &#125; fn = s.createFn(msgTypes[i], msgTypes[i+1], fn, cb) &#125; &#125; var msg Message msg.Type = msgTypes[0] msg.Fn = fn msg.Data = data return &amp;msg, nil&#125;func (s *QueueSwitch) createFn(msgType, nextType MessageType, nextFn func(*Message), cb MessageCB) func(*Message) &#123; return func(msg *Message) &#123; //执行自己的handle msg, err := s.handles[msgType](msg) if err != nil &#123; if cb != nil &#123; cb(msg, err) &#125; return &#125; //把消息发送给下一个channel msg.Type = nextType msg.Fn = nextFn s.Send(msg) &#125;&#125;func (s *QueueSwitch) createLastFn(msgType MessageType, cb MessageCB) func(*Message) &#123; return func(msg *Message) &#123; // 执行自己的 handle msg, err := s.handles[msgType](msg) if cb != nil &#123; // 回调处理结果 cb(msg, err) &#125; &#125;&#125; 下面我们来看一下2.0版本的测试示例： 测试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package queueimport ( "fmt" "testing")var ( MessageType_MsgA MessageType = 0 MessageType_MsgB MessageType = 1)type TradeServer struct &#123; sw *QueueSwitch logq *Queue matchq *Queue&#125;func NewTradeServer() *TradeServer &#123; s := &amp;TradeServer&#123;&#125; s.sw = NewQueueSwitch() s.logq = NewQueue(1) s.matchq = NewQueue(2) s.RegistMsgA() s.RegistMsgB() return s&#125;func (s *TradeServer) RegistMsgA() &#123; s.sw.SetRoute(MessageType_MsgA, s.logq) s.sw.SetHandle(MessageType_MsgA, func(msg *Message) (*Message, error) &#123; fmt.Println("recv log msg:", msg) return msg, nil &#125;)&#125;func (s *TradeServer) RegistMsgB() &#123; s.sw.SetRoute(MessageType_MsgB, s.matchq) s.sw.SetHandle(MessageType_MsgB, func(msg *Message) (*Message, error) &#123; fmt.Println("recv match msg:", msg) // some logic... msg.Data = "tx-result" return msg, nil &#125;)&#125;func TestQueueSwitch(t *testing.T) &#123; ch := make(chan interface&#123;&#125;, 1) s := NewTradeServer() var msg *Message msg, _ = s.sw.NewMessage("tx-data", func(msg *Message, err error) &#123; fmt.Println("in callback") ch &lt;- msg.Data &#125;, MessageType_MsgA, MessageType_MsgB) s.sw.Send(msg) fmt.Println(&lt;-ch)&#125; 测试结果： 123456recv log msg: &amp;&#123;tx-data 0x10f0e50 0&#125;recv match msg: &amp;&#123;tx-data 0x10f0f50 1&#125;in callbacktx-resultPASSok github.com/hxzqlh/queue 0.008s 可以看到，该消息会先发送到 A 类型对应的消息队列 logq 中，然后再发送到 B 类型对应的消息队列 matchq 中。 具体细节可参考源码 github.com/hxzqlh/queue:v2.0]]></content>
      <categories>
        <category>Coder</category>
      </categories>
      <tags>
        <tag>消息</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个简单的消息路由器v1.0]]></title>
    <url>%2F2019%2F02%2F28%2Fa-simple-msq-queue-switch%2F</url>
    <content type="text"><![CDATA[最近在整理代码，看到不少在设计、实现上有意思的模块，这里总结记录下，将别人的东西消化成自己的，或许以后用得着呢。 这里介绍下一个简单的消息路由器，第一版很简单，主要特征如下： 每个消息在生成时指定消息类型 不同类型的消息分发到不同的消息队列 不同类型的消息由不同的消息处理器消费 消息消费完成后可以执行回调逻辑 使用说明初始化流程： qs := NewQueueSwitch()生成消息路由器实例 调用 qs.SetRoute和qs.SetHandle 对不同类型的消息设置消息路由和消息处理器 消息发送流程： 构造消息： 1234ch := make(chan interface&#123;&#125;, 1) // 消息处理结果会写入该管道msg, _ = qw.NewMessage("Hello World!", func(msg *Message, err error) &#123; ch &lt;- msg.Data&#125;, MessageType_MsgA) 发送消息到路由器： 1qw.Send(msg) 等待消息处理完成： 12result := &lt;-chfmt.Println(result) 下面我们来看一下该消息模型的测试示例： 测试1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package queueimport ( "fmt" "testing")var ( MessageType_MsgA MessageType = 0 MessageType_MsgB MessageType = 1)type TradeServer struct &#123; sw *QueueSwitch q *Queue&#125;func NewTradeServer() *TradeServer &#123; s := &amp;TradeServer&#123;&#125; s.sw = NewQueueSwitch() s.q = NewQueue() s.RegistMsgA() s.RegistMsgB() return s&#125;func (s *TradeServer) RegistMsgA() &#123; s.sw.SetRoute(MessageType_MsgA, s.q) s.sw.SetHandle(MessageType_MsgA, func(msg *Message) (*Message, error) &#123; fmt.Println("A type msg:", msg) // some logic... msg.Data = "Hello, MsgA" return msg, nil &#125;)&#125;func (s *TradeServer) RegistMsgB() &#123; s.sw.SetRoute(MessageType_MsgB, s.q) s.sw.SetHandle(MessageType_MsgB, func(msg *Message) (*Message, error) &#123; fmt.Println("B type msg:", msg) // some logic... msg.Data = "Hello, MsgB" return msg, nil &#125;)&#125;func TestQueue(t *testing.T) &#123; ch := make(chan interface&#123;&#125;, 1) s := NewTradeServer() var msg *Message msg, _ = s.sw.NewMessage("test-A", func(msg *Message, err error) &#123; fmt.Println("in msg-A callback") ch &lt;- msg.Data &#125;, MessageType_MsgA) s.sw.Send(msg) fmt.Println(&lt;-ch) msg, _ = s.sw.NewMessage("test-B", func(msg *Message, err error) &#123; fmt.Println("in msg-B callback") ch &lt;- msg.Data &#125;, MessageType_MsgB) s.sw.Send(msg) fmt.Println(&lt;-ch)&#125; 测试结果： 123456789hxzdeMac-mini:~/workspace/golang/src/github.com/hxzqlh/queue (master) $ go testA type msg: &amp;&#123;test-A 0x10f0bf0 0&#125;in msg-A callbackHello, MsgAB type msg: &amp;&#123;test-B 0x10f0bf0 1&#125;in msg-B callbackHello, MsgBPASSok github.com/hxzqlh/queue 0.005s 具体细节可参考源码 github.com/hxzqlh/queue 总结从代码可以看出，消息路由器主动硬编码它所支持的消息类型和消息处理器，并将消息路由到不同队列，这种模式: 优点： 消息分发、处理的逻辑清晰明朗 缺点： 消息发送者必须知晓消息路由器支持的消息类型，否则无法构造消息，增加了消息发送者的负担。]]></content>
      <categories>
        <category>Coder</category>
      </categories>
      <tags>
        <tag>消息</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三年之痒：习惯了被你养成一个「废物」]]></title>
    <url>%2F2018%2F12%2F24%2Fthree-year-itch%2F</url>
    <content type="text"><![CDATA[今天对大多数人来说是圣诞夜，对我们而言，意义更特殊，结婚纪念日。 三十而立之年，我虚长你一岁多，我们已经结婚三年，女儿也三岁了。 还谈不上有什么三年之痒，彼此还没有腻烦，在我眼里，你还似邻家小妹妹一样可爱迷人。 宝宝都是外公外婆帮带，少了一份亲子之乐，多了的是二人世界，日子不咸不淡，顺其自然。 三年了，我的每个生日你都会给我准备意外的惊喜； 三年了，周末有空你都会周五提前买好菜做饭给我吃； 三年了，家务事我几乎不用操心，顶多洗下碗扫个地晒个衣服； 三年了，穿衣打扮都是你帮我搞定，我好像就没有自己去买过衣服了； 似乎，我已经习惯了被你养成一个“废物”。 有段时间我们俩一到周末就吵架，为一点鸡毛蒜皮的小事怄气：我性格有点倔强，你是个辣妹子，针尖对麦芒，就容易发火。是我不够包容，固执地争对错，不会及时哄老婆，偏要打冷战，这也体现了我的性格缺陷，生气时敏感而执拗，比老水牛还倔。 出去陪你逛街，我老是时不时看手机而忽略了你在说什么，因为这个事，你生我气好多次，今后要努力修正这个坏毛病。比如陪你逛街买东西，我除了拎包还可以发挥男人的第六感帮你挑选，给点参考意见。 我这人生活上太随意了，你说什么我都说好，就这个也经常惹你不开心，在你眼里我的“随便，都可以”就是不关心，不热情。其实我也可以圆滑点，面对无关痛痒的选择，也可以明面上一本正经地给老婆大人参考意见，毕竟女人大都有选择困难症的嘛。 于这个小家，老婆付出比我多，而我给老婆的还不够，除了在买衣服化妆品上我都随你意，其他好像就没对你奢侈过：出国旅游，一直没机会兑现，钻戒也拖到最近才给你买上，着实有愧。 今后除了继续努力工作外，还是要多花点心思在老婆身上：比如每年来它一个钻戒，过不了几年，十个手指都可以闪闪烁烁了，蛤蛤～偶尔创造些小惊喜，来点小情调，不至于把日子过得平淡乏味。 还是要忍住，不要和老婆吵架。每次一吵架，她就买买买…… 万一真的吵架了呢，无论对错，我都要主动和老婆和好啊。 顺颂圣祺，敬请期待七年之痒。 我是搞区块链开发的，把这个记录到bty链上吧: 0x60686caff549d95616081f3719ccdd63ae0fd266373442a6df35db47f1faa839]]></content>
      <categories>
        <category>心旷神怡</category>
      </categories>
      <tags>
        <tag>结婚</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[限流 | Go 实现速率限制]]></title>
    <url>%2F2018%2F09%2F12%2Fgo-rate-limit%2F</url>
    <content type="text"><![CDATA[在开发高并发系统时，为了保证系统的高可用和稳定性，业内流传着“三把斧”： 缓存：提升系统访问速度，增大系统处理容量 降级：当服务出现故障或影响到核心业务时，暂时屏蔽掉，待高峰期过后或故障解决后再打开 限流：通过对并发（或者一定时间窗口内）请求进行限速来保护系统，一旦达到限制速率则拒绝服务（定向到错误页或告知资源没有了）、排队等待（比如秒杀、评论、下单）、降级（返回兜底数据或默认数据） 最近，由于我负责的一个项目后端这边需要控制 API 的访问频率，于是研究了下 限流 相关的技术。 一般来说，限流的常用处理手段有： 计数器 滑动窗口 漏桶 令牌桶 计数器计数器是一种比较简单粗暴的限流算法： 在一段时间间隔内，对请求进行计数，与阀值进行比较判断是否需要限流，一旦到了时间临界点，将计数器清零。 讨论两种通用做法。 方案一当请求频率过快时，直接抛弃后续请求。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package mainimport ( "fmt" "sync" "time")type LimitRate struct &#123; rate int //计数周期内最多允许的请求数 begin time.Time //计数开始时间 cycle time.Duration //计数周期 count int //计数周期内累计收到的请求数 lock sync.Mutex&#125;func (l *LimitRate) Allow() bool &#123; l.lock.Lock() defer l.lock.Unlock() if l.count == l.rate-1 &#123; now := time.Now() if now.Sub(l.begin) &gt;= l.cycle &#123; //速度允许范围内， 重置计数器 l.Reset(now) return true &#125; else &#123; return false &#125; &#125; else &#123; //没有达到速率限制，计数加1 l.count++ return true &#125;&#125;func (l *LimitRate) Set(r int, cycle time.Duration) &#123; l.rate = r l.begin = time.Now() l.cycle = cycle l.count = 0&#125;func (l *LimitRate) Reset(t time.Time) &#123; l.begin = t l.count = 0&#125;func main() &#123; var wg sync.WaitGroup var lr LimitRate lr.Set(3, time.Second) // 1s内最多请求3次 for i := 0; i &lt; 10; i++ &#123; wg.Add(1) fmt.Println("Create req", i, time.Now()) go func(i int) &#123; if lr.Allow() &#123; fmt.Println("Respon req", i, time.Now()) &#125; wg.Done() &#125;(i) time.Sleep(200 * time.Millisecond) &#125; wg.Wait()&#125; 例子里面每 200ms 创建一个请求，速率明显高于 1s内最多3个 的限制， 我们把请求的创建时间和结果返回时间打印出来，方便观察。运行显示： 123456789101112131415Create req 0 2018-09-12 17:03:43.759413 +0800 CST m=+0.000297262Respon req 0 2018-09-12 17:03:43.759539 +0800 CST m=+0.000422748Create req 1 2018-09-12 17:03:43.961558 +0800 CST m=+0.202436188Respon req 1 2018-09-12 17:03:43.961637 +0800 CST m=+0.202515351Create req 2 2018-09-12 17:03:44.165453 +0800 CST m=+0.406321427 xCreate req 3 2018-09-12 17:03:44.365722 +0800 CST m=+0.606573032 xCreate req 4 2018-09-12 17:03:44.567892 +0800 CST m=+0.808749192 xCreate req 5 2018-09-12 17:03:44.769219 +0800 CST m=+1.010065632Respon req 5 2018-09-12 17:03:44.769377 +0800 CST m=+1.010231224Create req 6 2018-09-12 17:03:44.970477 +0800 CST m=+1.211325152Respon req 6 2018-09-12 17:03:44.970539 +0800 CST m=+1.211387021Create req 7 2018-09-12 17:03:45.171685 +0800 CST m=+1.412526161Respon req 7 2018-09-12 17:03:45.171741 +0800 CST m=+1.412583132Create req 8 2018-09-12 17:03:45.372879 +0800 CST m=+1.613709972 xCreate req 9 2018-09-12 17:03:45.573016 +0800 CST m=+1.813845388 x 平均每秒最多只显示 3 次 “Respon req”，请求 2、3、4、8、9 被丢弃，说明限速成功。 方案二当请求频率太快时，后续的请求等待之前的请求完成后才进行，稍微修改下 Allow 方法： 123456789101112131415161718192021func (l *LimitRate) Allow() bool &#123; l.lock.Lock() defer l.lock.Unlock() if l.count == l.rate-1 &#123; for &#123; now := time.Now() if now.Sub(l.begin) &gt;= l.cycle &#123; //速度允许范围内， 重置计数器 l.Reset(now) return true &#125; else &#123; // wait &#125; &#125; &#125; else &#123; //没有达到速率限制，计数加1 l.count++ return true &#125;&#125; 运行显示，10 次请求总共花费了 3s 多，符合预期，超过请求速率的后续请求依次被排队处理成功，最明显的是请求 9，创建后等待近 2s 才返回结果： 123456789101112131415161718192021222324Create req 0 2018-09-12 17:09:26.177354 +0800 CST m=+0.000317504Respon req 0 2018-09-12 17:09:26.177489 +0800 CST m=+0.000452028Create req 1 2018-09-12 17:09:26.377706 +0800 CST m=+0.200662813Respon req 1 2018-09-12 17:09:26.377743 +0800 CST m=+0.200700428Create req 2 2018-09-12 17:09:26.577843 +0800 CST m=+0.400793565Create req 3 2018-09-12 17:09:26.778119 +0800 CST m=+0.601064014Create req 4 2018-09-12 17:09:26.978772 +0800 CST m=+0.801710852Respon req 2 2018-09-12 17:09:27.177392 +0800 CST m=+1.000325104Respon req 4 2018-09-12 17:09:27.177469 +0800 CST m=+1.000401716Respon req 3 2018-09-12 17:09:27.177439 +0800 CST m=+1.000372204Create req 5 2018-09-12 17:09:27.179018 +0800 CST m=+1.001942192 Create req 6 2018-09-12 17:09:27.379832 +0800 CST m=+1.202758661Create req 7 2018-09-12 17:09:27.580378 +0800 CST m=+1.403297124Create req 8 2018-09-12 17:09:27.781084 +0800 CST m=+1.603998402Create req 9 2018-09-12 17:09:27.981209 +0800 CST m=+1.804117865 //Respon req 5 2018-09-12 17:09:28.177425 +0800 CST m=+2.000323426Respon req 6 2018-09-12 17:09:28.177456 +0800 CST m=+2.000358896Respon req 7 2018-09-12 17:09:28.177473 +0800 CST m=+2.000375963Respon req 8 2018-09-12 17:09:29.177453 +0800 CST m=+3.000326135Respon req 9 2018-09-12 17:09:29.177477 +0800 CST m=+3.000350214 //real 0m3.302suser 0m1.802ssys 0m1.021s 计数器算法存在“时间临界点”缺陷。比如每一分钟限速 100 个请求（也就是说每秒最多 1.7 个请求），在 00:00:00 到 00:00:58 这段时间内没有用户请求，然后在 00:00:59这一瞬时发出100个请求，这是允许的，然后在 00:01:00 这一瞬时又发出了 100 个请求，短短 1s 内发出了 200 个请求，系统可能会承受恶意用户的大量请求，甚至击穿系统。 滑动窗口针对计数器存在的临界点缺陷: 滑动窗口把固定时间片进行划分，并且随着时间的流逝，进行移动，固定数量的可以移动的格子，进行计数并判断阀值。 格子的数量影响着滑动窗口算法的精度，依然有时间片的概念，无法根本解决临界点问题。 漏桶漏桶算法描述如下： 一个固定容量的漏桶，按照固定速率流出水滴； 如果桶是空的，则不需流出水滴； 可以以任意速率流入水滴到漏桶； 如果流入水滴超出了桶的容量，则溢出（被丢弃） 通俗点来说，我们有一个固定容量的桶，有水流进来，也有水流出去。对于流进来的水（请求）来说，我们无法预计一共有多少水会流进来，也无法预计水流的速度。但是对于流出去的水来说，这个桶可以固定水流出的速率（处理速度），从而达到 流量整形 和 流量控制 的效果。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package mainimport ( "fmt" "math" "sync" "time")type LeakyBucket struct &#123; rate float64 //固定每秒出水速率 capacity float64 //桶的容量 water float64 //桶中当前水量 lastLeakMs int64 //桶上次漏水时间戳 ms lock sync.Mutex&#125;func (l *LeakyBucket) Allow() bool &#123; l.lock.Lock() defer l.lock.Unlock() now := time.Now().UnixNano() / 1e6 eclipse := float64((now - l.lastLeakMs)) * l.rate / 1000 //先执行漏水 l.water = l.water - eclipse //计算剩余水量 l.water = math.Max(0, l.water) //桶干了 l.lastLeakMs = now if (l.water + 1) &lt; l.capacity &#123; // 尝试加水,并且水还未满 l.water++ return true &#125; else &#123; // 水满，拒绝加水 return false &#125;&#125;func (l *LeakyBucket) Set(r, c float64) &#123; l.rate = r l.capacity = c l.water = 0 l.lastLeakMs = time.Now().UnixNano() / 1e6&#125;func main() &#123; var wg sync.WaitGroup var lr LeakyBucket lr.Set(3, 3) //每秒访问速率限制为3个请求，桶容量为3 for i := 0; i &lt; 10; i++ &#123; wg.Add(1) fmt.Println("Create req", i, time.Now()) go func(i int) &#123; if lr.Allow() &#123; fmt.Println("Respon req", i, time.Now()) &#125; wg.Done() &#125;(i) time.Sleep(100 * time.Millisecond) &#125; wg.Wait()&#125; 这里初始化桶容量为 3 个单位，桶内无水，1s 内创建了 10 个请求，随着请求往里面“滴水”，桶按照每秒3 个单位的速率流出水，处理时，部分请求被丢弃： 123456789101112131415Create req 0 2018-09-12 20:13:47.742497 +0800 CST m=+0.000314490Respon req 0 2018-09-12 20:13:47.742634 +0800 CST m=+0.000451781Create req 1 2018-09-12 20:13:47.847836 +0800 CST m=+0.105648928Respon req 1 2018-09-12 20:13:47.847971 +0800 CST m=+0.105785251Create req 2 2018-09-12 20:13:47.948029 +0800 CST m=+0.205839614Respon req 2 2018-09-12 20:13:47.948093 +0800 CST m=+0.205901092Create req 3 2018-09-12 20:13:48.053237 +0800 CST m=+0.311044273 xCreate req 4 2018-09-12 20:13:48.153545 +0800 CST m=+0.411304284 Respon req 4 2018-09-12 20:13:48.153564 +0800 CST m=+0.411369118 Create req 5 2018-09-12 20:13:48.254636 +0800 CST m=+0.512437744 xCreate req 6 2018-09-12 20:13:48.355816 +0800 CST m=+0.613609405 xCreate req 7 2018-09-12 20:13:48.456968 +0800 CST m=+0.714763347Respon req 7 2018-09-12 20:13:48.457017 +0800 CST m=+0.714812815Create req 8 2018-09-12 20:13:48.557203 +0800 CST m=+0.814995585 xCreate req 9 2018-09-12 20:13:48.658431 +0800 CST m=+0.916216265 x 令牌桶由于漏桶的出水速度是恒定的，如果瞬时爆发大流量的话，将有大部分请求被丢弃掉（溢出）。 为了解决这个问题，令牌桶进行了算法改进，算法描述如下： 有一个固定容量的桶，桶一开始是空的； 以固定的速率 r 往桶里填充 token，直到达到桶的容量，多余的令牌将会被丢弃； 每当一个请求过来时，就尝试从桶里移除一个令牌，如果没有令牌的话，请求无法通过。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package mainimport ( "fmt" "sync" "time")type TokenBucket struct &#123; rate int64 //固定的token放入速率, r/s capacity int64 //桶的容量 tokens int64 //桶中当前token数量 lastTokenSec int64 //桶上次放token的时间戳 s lock sync.Mutex&#125;func (l *TokenBucket) Allow() bool &#123; l.lock.Lock() defer l.lock.Unlock() now := time.Now().Unix() l.tokens = l.tokens + (now-l.lastTokenSec)*l.rate // 先添加令牌 if l.tokens &gt; l.capacity &#123; l.tokens = l.capacity &#125; l.lastTokenSec = now if l.tokens &gt; 0 &#123; // 还有令牌，领取令牌 l.tokens-- return true &#125; else &#123; // 没有令牌,则拒绝 return false &#125;&#125;func (l *TokenBucket) Set(r, c int64) &#123; l.rate = r l.capacity = c l.tokens = 0 l.lastTokenSec = time.Now().Unix()&#125;func main() &#123; var wg sync.WaitGroup var lr TokenBucket lr.Set(3, 3) //每秒访问速率限制为3个请求，桶容量为3 time.Sleep(time.Second) for i := 0; i &lt; 10; i++ &#123; wg.Add(1) fmt.Println("Create req", i, time.Now()) go func(i int) &#123; if lr.Allow() &#123; fmt.Println("Respon req", i, time.Now()) &#125; wg.Done() &#125;(i) time.Sleep(200 * time.Millisecond) &#125; wg.Wait()&#125; 类似的，这里初始化桶容量为 3 个单位，桶内无令牌，每 1s 产生 3 个令牌，主程序阻塞 1s 以便让桶中储备好 3 个令牌，而后每 1s 创建 5 个请求，获取访问令牌： 1234567891011121314151617Create req 0 2018-09-12 20:56:30.926267 +0800 CST m=+1.002077637Respon req 0 2018-09-12 20:56:30.926512 +0800 CST m=+1.002322722Create req 1 2018-09-12 20:56:31.127552 +0800 CST m=+1.203356343Respon req 1 2018-09-12 20:56:31.127643 +0800 CST m=+1.203445860Create req 2 2018-09-12 20:56:31.328242 +0800 CST m=+1.404040714Respon req 2 2018-09-12 20:56:31.328311 +0800 CST m=+1.404110620Create req 3 2018-09-12 20:56:31.529957 +0800 CST m=+1.605746538Respon req 3 2018-09-12 20:56:31.530069 +0800 CST m=+1.605862175Create req 4 2018-09-12 20:56:31.734506 +0800 CST m=+1.810291673 xCreate req 5 2018-09-12 20:56:31.938578 +0800 CST m=+2.014347368 xCreate req 6 2018-09-12 20:56:32.141289 +0800 CST m=+2.217061017Respon req 6 2018-09-12 20:56:32.141379 +0800 CST m=+2.217153670Create req 7 2018-09-12 20:56:32.341492 +0800 CST m=+2.417260734Respon req 7 2018-09-12 20:56:32.341571 +0800 CST m=+2.417339558Create req 8 2018-09-12 20:56:32.543497 +0800 CST m=+2.619259765Respon req 8 2018-09-12 20:56:32.543554 +0800 CST m=+2.619317332Create req 9 2018-09-12 20:56:32.746344 +0800 CST m=+2.822096642 x 由于桶中可以储备令牌，这使得令牌桶算法支持一定程度突发的大流量并发访问，也就是说，假设桶内有 100 个 token 时，那么可以瞬间允许 100 个请求通过。这点，对用户比较友好，因而业内多半采用该算法。 当然，不论是对于令牌桶拿不到令牌被拒绝，还是漏桶的水满了溢出，都是为了保证大部分流量的正常访问，而牺牲掉了少部分流量，这是合理的。 rate包Go 语言中的 golang.org/x/time/rate 包采用了令牌桶算法来实现速率限制，简单介绍下这个包的用法： 这个包的核心部分在 Limit 类型和 NewLimiter接口： 12345678// Limit 定义了事件的最大频率。// Limit 被表示为每秒事件的数量。// 值为0的Limit不允许任何事件。type Limit float64// 返回一个新的Limiter实例，// 事件发生率为r，并允许至多b个令牌爆发。func NewLimiter(r Limit, b int) *Limiter 在 NewLimiter 中，我们看到了两个熟悉的参数：r 和 b，b 是我们之前讨论过的桶的深度。 rate 包还定义了一个有用的帮助函数 Every，将 time.Duration 转换为Limit对象： 12// Every 将事件之间的最小时间间隔转换为 Limit。func Every(interval time.Duration) Limit 创建 Limiter 对象后，我们使用 Wait,Allow或 Reserve 方法来阻塞我们的请求，直到获得访问令牌： 123456789101112131415161718192021222324252627282930// WaitN(ctx, 1)的简写。func (lim *Limiter) Wait(ctx context.Context)// WaitN 会发生阻塞直到 lim 允许的 n 个事件执行。// 如果 n 超过了令牌池的容量大小则报错。// 如果 ctx 被取消或等待时间超过了 ctx 的超时时间则报错。func (lim *Limiter) WaitN(ctx context.Context, n int) (err error)// AllowN(time.Now(), 1)的简写。func (lim *Limiter) Allow() bool// AllowN 标识在时间 now 的时候，n 个事件是否可以同时发生，// 意思就是 now 的时候是否可以从令牌池中取 n 个令牌，func (lim *Limiter) AllowN(now time.Time, n int) bool// ReserveN(time.Now(), 1)的简写。func (lim *Limiter) Reserve() *Reservation// ReserveN 返回对象 Reservation ，标识调用者需要等多久才能等到 n 个事件发生，// 意思就是 等多久令牌池中至少含有 n 个令牌。func (lim *Limiter) ReserveN(now time.Time, n int) *Reservation// eg:r := lim.ReserveN(time.Now(), 1)if !r.OK() &#123; // Not allowed to act! Did you remember to set lim.burst to be &gt; 0 ? return&#125;time.Sleep(r.Delay())Act() 如果要使用context 的截止日期或 cancel 方法的话，使用 WaitN。 如果需要在事件超出频率的时候丢弃或跳过事件，就使用 Allow,否则使用 Reserve 或 Wait。 如果事件发生的频率是可以由调用者控制的话，可以用 ReserveN 来控制事件发生的速度而不丢掉事件。 使用 rate 包来实现一个简单的 http 限流中间件: 1234567891011121314151617181920212223242526272829package mainimport ( "net/http" "golang.org/x/time/rate")var limiter = rate.NewLimiter(2, 5) func limit(next http.Handler) http.Handler &#123; return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) &#123; if !limiter.Allow() &#123; http.Error(w, http.StatusText(http.StatusTooManyRequests), http.StatusTooManyRequests) return &#125; next.ServeHTTP(w, r) &#125;)&#125;func okHandler(w http.ResponseWriter, r *http.Request) &#123; w.Write([]byte("OK\n"))&#125;func main() &#123; mux := http.NewServeMux() mux.HandleFunc("/", okHandler) http.ListenAndServe(":4000", limit(mux))&#125; 测试： 12345678910111213141516171819hxzdeMac-mini:~ $ while true; do&gt; curl http://localhost:4000/&gt; sleep 0.1s&gt; doneOKOKOKOKOK //首次爆发5个请求OKToo Many RequestsToo Many RequestsToo Many RequestsOK //之后每秒2个请求Too Many RequestsToo Many RequestsToo Many RequestsOK... 稍微修改下这个程序还可以实现 用户粒度的限流，基于IP地址或API密钥等标识符为每个用户实施速率限制器。 更健全的 http 限流中间件推荐看看这个库：https://github.com/didip/tollbooth 最后上面的几种算法实现比较直白，只是算法语言的翻译，没有充分利用 Go 语言里面 goroutine、channel、定时器等特性，感兴趣的读者可以改造下。 另外，《聊聊高并发系统之限流特技》的两篇文章，非常棒，详细介绍了各种限流算法以及应用级限流、分布式限流、接入层限流等非常实用的技术。 参考 聊聊高并发系统之限流特技-1 聊聊高并发系统之限流特技-2 rate-limit-example-in-go]]></content>
      <categories>
        <category>Coder</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>限流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨链三部曲-3：IBC]]></title>
    <url>%2F2018%2F07%2F22%2Fcross-chain-3-IBC%2F</url>
    <content type="text"><![CDATA[Cosmos Network 中最令人兴奋的特色是 InterBlockchain Communication (IBC) 协议，允许不同区块链之间进行资产转移。IBC 已经实现为一个 basecoin 插件，本节我将介绍如何使用它进行不同区块链间的资产互转。 IBCIBC 的目的是让区块链彼此之间充当一个轻量级的客户端。由于我们使用经典的拜占庭一致性容错算法，在客户端上进行验证是简单可行的：只须校验最新块的签名并验证 ABCI 应用的默克尔树根。 在 Tendermint 共识引擎中，多个校验节点在处理新的区块之前会先达成一致。这意味着在下一个区块来临之前，当前区块的签名及其根状态不会加入到区块链中。每个区块包含一个 LastCommit （用于确认前一个区块的投票信息）和 AppHash（在区块头部，指处理完前一个区块的交易后的默克尔树根的 hash）。 因此，如果我们要从高度 H 验证 AppHash，我们需要高度 H+1 节点的 LastCommit 的签名（请记住：AppHash 只包含了从叶子节点到 H-1 高度节点的所有交易结果）。 不像 PoW，轻量级客户端协议不需要下载并检查所有区块链节点的头部信息，客户端总是能够直接跳跃到最新的头部，只要 validator 节点集还没有变更。如果 validator 节点集发生了变动，客户端需要跟踪这些变化，这个时候才需要从变更点开始下载所有区块点头部。这里，简单起见，我们假设这些 validator 节点集是静态不变的。 现在，让我们来演示 IBC 是如何工作的。假设我们有两条链：chain1 和 chain2，从 chain1 发送数据到 chain2，我们需要这么几个步骤: 在 chain2 上注册 chain1 的信息（chainID、genesis 配置等） 在 chain1 上，广播一条将要外发给 chain2 的 IBC 交易 广播一条交易给 chain2 告诉它 chain1 的最新状态（header和commit信息） chain1 向 chain2 发送 IBC 交易（区块高度、数据以及并默克尔证明），由于 chain2 已经知道了 chain1 的最新状态，它只需验证这个默克尔证明就可以了。 最重要的部分是： 在 chain2 上更新 chain1 的最新的状态，然后 chain1 向 chain2 发出 Merkle proof：我的数据包确实已经发出来了。 上述每一步都包含一种 IBC 交易类型，让我们 one by one 地来看一下： IBCRegisterChainTxIBCRegisterChainTx 用来注册一条链到另外一条链上。 123456type IBCRegisterChainTx struct &#123; BlockchainGenesis &#125;type BlockchainGenesis struct &#123; ChainID string Genesis string &#125; 对于给定的 chainID，该类型交易只能发送一次，重复发送将返回错误。 IBCUpdateChainTxIBCUpdateChainTx 用于在其它链上更新当前链的信息。 1234type IBCUpdateChainTx struct &#123; Header tm.Header Commit tm.Commit&#125; IBCPacketCreateTxIBCPacketCreateTx 用来创建一个将要外发给其他链的交易。 1234567891011type IBCPacketCreateTx struct &#123; Packet&#125;type Packet struct &#123; SrcChainID string DstChainID string Sequence uint64 Type string Payload []byte&#125; IBCPacketPostTxIBCPacketPostTx 用来向外发送交易到另外一条链。 12345type IBCPacketPostTx struct &#123; FromChainID string // The immediate source of the packet, not always Packet.SrcChainID FromChainHeight uint64 // The block height in which Packet was committed, to check Proof Packet Proof *merkle.IAVLProof&#125; IBC State了解完跟跨链相关的交易类型，来看看 state。每条链都会在默克尔树中存储关于 IBC 的 state，对于当前链来说，它记录的每条注册到它上面的其它链的信息包括： Genesis configuration Latest state Headers for recent heights 当然，还会记录所有它收到(ingress) 和外发(egress)的交易（packet）。 每当一笔提交 IBCUpdateChainTx 交易，这条链的会相应地更新它的 state, 每当创建一笔IBCPacketCreateTx 交易，新的 packet 数据会添加到 egress state 中，每当接收到一笔 IBCPacketPostTx 交易并验证通过了 proof 后，新的 packet 数据会添加到 ingress state 中。 Relay由于我们内部需要这些跟跨链相关的交易，以便在不同链之间以一种安全的方式来跟踪所有 proof，为了让整个流程显得流畅自然，我们可以运行一个 relay 程序来处理这些跟跨链相关的交互操作。 在本例中，只需要 2 步： basecoin relay init：每条链都在上面注册好另外一条链，并确保彼此可以发送和接收交易。 basecoin relay start：长轮询，不断地从一条链上拉取跨链交易并转发到另外一条链上。 前提是：relay 程序必须有权限读写这些链的账户及资产信息，因为发送 IBC 交易需要支付一定的 Fee。 Try it out有了前面这些知识做铺垫，现在，让我们来真实地体验下跨链交易： Preliminaries12# first, clean up any old garbage for a fresh slate...rm -rf ~/.ibcdemo/ 为了方便后续操作，先设置好一些环境变量和命令行别名： 12345678export BCHOME1_CLIENT=~/.ibcdemo/chain1/clientexport BCHOME1_SERVER=~/.ibcdemo/chain1/serverexport BCHOME2_CLIENT=~/.ibcdemo/chain2/clientexport BCHOME2_SERVER=~/.ibcdemo/chain2/serveralias basecli1="basecli --home $BCHOME1_CLIENT"alias basecli2="basecli --home $BCHOME2_CLIENT"alias basecoin1="basecoin --home $BCHOME1_SERVER"alias basecoin2="basecoin --home $BCHOME2_SERVER" 设置两条链的 chainID 12export CHAINID1="test-chain-1"export CHAINID2="test-chain-2" 由于我们是在一个机器上运行两条基于 tendermint 的区块链，我们需要给两条链设置不同的端口： 1234export PORT_PREFIX1=1234export PORT_PREFIX2=2345export RPC_PORT1=$&#123;PORT_PREFIX1&#125;7export RPC_PORT2=$&#123;PORT_PREFIX2&#125;7 Setup Chain 1创建两个 test-chain-1 链的账户: 1234basecli1 keys new moneybasecli1 keys new gotnoneexport MONEY=$(basecli1 keys get money | awk '&#123;print $2&#125;')export GOTNONE=$(basecli1 keys get gotnone | awk '&#123;print $2&#125;') 初始化这条链，它会给 $MONEY 账户打很多钱： 1basecoin1 init --chain-id $CHAINID1 $MONEY 启动 basecoin 区块链： 123sed -ie "s/4665/$PORT_PREFIX1/" $BCHOME1_SERVER/config.tomlbasecoin1 start &amp;&gt; basecoin1.log &amp; test-chain-1 跑起来了，你可以通过 tail -f basecoin1.log 实时查看它的日志。 接下来，我们将 basecli 客户端连接上 test-chain-1，验证 test-chain-1 的最新状态，下面第一个账户应该显示有钱，第二个显示没钱。 123basecli1 init --node=tcp://localhost:$&#123;RPC_PORT1&#125; --genesis=$&#123;BCHOME1_SERVER&#125;/genesis.jsonbasecli1 query account $MONEYbasecli1 query account $GOTNONE Setup Chain 2设置 test-chain-2 跟 test-chain-1 步骤类似： 1234basecli2 keys new moremoneybasecli2 keys new brokeMOREMONEY=$(basecli2 keys get moremoney | awk '&#123;print $2&#125;')BROKE=$(basecli2 keys get broke | awk '&#123;print $2&#125;') 准备创世块，启动节点： 12345basecoin2 init --chain-id $CHAINID2 $(basecli2 keys get moremoney | awk '&#123;print $2&#125;')sed -ie "s/4665/$PORT_PREFIX2/" $BCHOME2_SERVER/config.tomlbasecoin2 start &amp;&gt; basecoin2.log &amp; 我们将 basecli 客户端连接上 test-chain-2，验证 test-chain-2 的最新状态，同样，下面第一个账户应该显示有钱，第二个显示没钱。 123basecli2 init --node=tcp://localhost:$&#123;RPC_PORT2&#125; --genesis=$&#123;BCHOME2_SERVER&#125;/genesis.jsonbasecli2 query account $MOREMONEYbasecli2 query account $BROKE Connect these chainsOK，现在我们有两条独立的 basecoin 区块链在运行，让我们启动 relay 程序把它们串联起来，让它们可以彼此发送交易给对方。 relay 账户需要有余额来支付 IBC 消息，因此，我们需要先往 relay 账户充值部分钱。 12345678910# note that this key.json file is a hardcoded demo for all chains, this will# be updated in a future releaseRELAY_KEY=$BCHOME1_SERVER/key.jsonRELAY_ADDR=$(cat $RELAY_KEY | jq .address | tr -d \")basecli1 tx send --amount=100000mycoin --sequence=1 --to=$RELAY_ADDR --name=moneybasecli1 query account $RELAY_ADDRbasecli2 tx send --amount=100000mycoin --sequence=1 --to=$RELAY_ADDR --name=moremoneybasecli2 query account $RELAY_ADDR 一切准备就绪，启动 relay 程序： 12345678basecoin relay init --chain1-id=$CHAINID1 --chain2-id=$CHAINID2 \ --chain1-addr=tcp://localhost:$&#123;RPC_PORT1&#125; --chain2-addr=tcp://localhost:$&#123;RPC_PORT2&#125; \ --genesis1=$&#123;BCHOME1_SERVER&#125;/genesis.json --genesis2=$&#123;BCHOME2_SERVER&#125;/genesis.json \ --from=$RELAY_KEYbasecoin relay start --chain1-id=$CHAINID1 --chain2-id=$CHAINID2 \ --chain1-addr=tcp://localhost:$&#123;RPC_PORT1&#125; --chain2-addr=tcp://localhost:$&#123;RPC_PORT2&#125; \ --from=$RELAY_KEY &amp;&gt; relay.log &amp; Sending cross-chain payments好了，test-chain-1 和 test-chain-2 通过 IBC 协议彼此连接好，跨链中最艰巨的部分已经完成，现在，就是见证 跨链交易 奇迹的时刻： 12345678# Here's an empty account on test-chain-2basecli2 query account $BROKE# Let's send some funds from test-chain-1basecli1 tx send --amount=12345mycoin --sequence=2 --to=test-chain-2/$BROKE --name=money# give it time to arrive...sleep 2# now you should see 12345 coins!basecli2 query account $BROKE Conclusion本节我们详细阐述了 IBC 的工作机制，并演示了如何利用它在链间通信，并手把手教你进行跨链交易。其中，IBC 最核心的部分是： 在 chain2 上更新 chain1 的最新的状态，然后 chain1 向 chain2 发出 Merkle proof：我的数据包确实已经发出来了。]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>跨链</tag>
        <tag>IBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨链三部曲-2：Basecoin Plugin]]></title>
    <url>%2F2018%2F06%2F16%2Fcross-chain-2-Basecoin-plugin%2F</url>
    <content type="text"><![CDATA[在前一节中，我们学习了如何使用 basecoin 启动区块链和 basecli 来发送交易，同时研究了 Account 和 SendTx 这两种基本类型。本节，我们将演示如何扩展 SendTx 以便让它支持另外一种交易类型：AppTx，这样就可以发送数据到一个自定义的插件 plugin。这里，我们来探索一个简单的 plugin：Counter。 Example Pluginbasecoin 的设计使得实现一个用户自定义插件变得十分简单，Counter 插件是和 basecoin 区块链打包在一起的，因此，如果你已经安装了 baseocin，并且运行了 make install，你应该可以直接运行 Counter 区块链节点和它的客户端 countercli，它和我们之前的 basecli 用法十分相似。 除了 --name和 --amount是必选参数，Counter 交易由其他两个参数确定：boolean 类型的 valid，和 countfee 表示某种代币类型和数量。只有当 valid 为 true 且 amount 数量大于 counterfee 时，该笔交易才是有效的。 跟之前 basecoin 区块链一样，类似的，counter 区块链也可以这样初始化： 12345678910# WARNING: this wipes out data - but counter is only for demos...rm -rf ~/.countercountercli reset_allcountercli keys new coolcountercli keys new friendcounter init $(countercli keys get cool | awk '&#123;print $2&#125;')counter start counter 的配置文件默认存放在 ~/.counter 目录，打开另一个命令行窗口， 初始化 countercli 并用 tx 的子命令 send 发送交易： 1234countercli init --node=tcp://localhost:46657 --genesis=$HOME/.counter/genesis.jsonYOU=$(countercli keys get friend | awk '&#123;print $2&#125;')countercli tx send --name=cool --amount=1000mycoin --to=$YOU --sequence=1 Counter 的 tx 还有另外一个子命令 counter，它会为这个 plugin 构造一个特殊的 AppTx： 12countercli tx counter --name cool --amount=1mycoin --sequence=2countercli tx counter --name cool --amount=1mycoin --sequence=3 --valid 第一笔交易不会被区块链接受，因为它没有指定 valid 参数，第二笔顺利发送，接下来我们可以查询这个 plugin： 1countercli query counter 可以看到，我们这个自定义插件已经可以跑通，你应该看到 Counter 值为 1 代表当前 counter 的有效交易数量，如果再发送一笔交易： 12countercli tx counter --name cool --amount=2mycoin --sequence=4 --valid --countfee=2mycoincountercli query counter 再次查询，我们将看到 Counter 值会变为 2，这一次，我们指定了 countfee=2mycoin，它没有超出 --amount=2mycoin，因此，可以通过 counter 区块链的合法性验证。 记住，和 basecli 一样，每次查询， countercli 都会验证区块链返回的 proof，保证返回结果是最新且正确的。 AppTx在实现我们自己的 plugin 之前，有必要先探究下 AppTx 和 basecoin 的 plugin 系统。 AppTx 和 SendTx 相似，不同之处在于，SendTx 是从 inputs 发送交易到 outputs，而 AppTx 是从一个 input 发送交易到一个 plugin，当然，也可以附加其他数据 Data。 1234567type AppTx struct &#123; Gas int64 `json:"gas"` Fee Coin `json:"fee"` Input TxInput `json:"input"` Name string `json:"type"` // Name of the plugin Data []byte `json:"data"` // Data for the plugin to process&#125; 通过 plugin 的方式，AppTx 可以使 Basecoin 扩展为能够处理除了转账之外的其他交易。Name字段代表某个处理特殊交易的 plugin 名字，Data 代表 plugin 要处理的数据。 Plugins一个 plugin，简单来说，它实现了 Plugin 接口中定义的方法： 1234567891011121314151617181920type Plugin interface &#123; // Name of this plugin, should be short. Name() string // Run a transaction from ABCI DeliverTx RunTx(store KVStore, ctx CallContext, txBytes []byte) (res abci.Result) // Other ABCI message handlers SetOption(store KVStore, key string, value string) (log string) InitChain(store KVStore, vals []*abci.Validator) BeginBlock(store KVStore, hash []byte, header *abci.Header) EndBlock(store KVStore, height uint64) (res abci.ResponseEndBlock)&#125;type CallContext struct &#123; CallerAddress []byte // Caller's Address (hash of PubKey) CallerAccount *Account // Caller's Account, w/ fee &amp; TxInputs deducted Coins Coins // The coins that the caller wishes to spend, excluding fees&#125; 关键在于 RunTx 方法，AppTx 中的 Data 会赋值给 txBytes，Input 则用来填充 CallContext。 注意到 RunTx 还接收一个 KVStore 类型参数 store，它抽象化了底层默克尔树对 account 数据的操作，这样 plugin 可以直接更新 Basecoin 节点里面的 account 信息，也可以存储其它信息用来来反馈区块链应用的最新状态。 通过 plugin 的方式，基于 Basecoin 的区块链应用可以得到很大扩展，甚至，可以实现类似于以太坊虚拟机那样的插件。这里 有些别人已经实现好的 plugin 例子。 Conclusion本节我们演示了如何创建一个 plugin 来扩展现有 Basecoin 实现发送用户自定义交易到区块链，下一节，我们将介绍一个用于区块链跨链通信 IBC(Inter Blockchain Communication) 的插件。]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>跨链</tag>
        <tag>IBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨链三部曲-1：Basecoin]]></title>
    <url>%2F2018%2F05%2F22%2Fcross-chain-1-Basecoin%2F</url>
    <content type="text"><![CDATA[前面我们讲到 Basecoin 是一个基于 tendermint 的 ABCI 应用，同时它也是一个跨链应用。这节，我给大家介绍如何利用它在不同的账户之间发送交易，并试着探索下其中的技术内幕。 Install墙外的用户直接运行: 1go get -u github.com/tendermint/basecoin/cmd/... 像我们被困在墙内的用户怎么办呢，Basecoin 是用 glide 管理依赖包的，老司机都知道通过 glide miror set 来设置那些被墙包的镜像，具体请看我的另一篇 《我是如何管理goalng包的》。 安装好后，会有两个工具： basecoin 运行区块链节点 basecli 轻客户端命令行 Generate some keys首先，生成 2 组 key，一个用来接收初始分配的币，一个用来发送币。 12345678# WARNING: this will wipe out any existing info in the ~/.basecli dir# including private keys, don't run if you have lots of local state already# while we're at it let's remove the working directory for the full node toobasecli reset_allrm -rf ~/.basecoinbasecli keys new coolbasecli keys new friend 生成 key 时会提示你输入密码，生成好后，查看已有的 key 列表: 1234AllendeMacBook-Pro:~ $ basecli keys listAll keys:cool CD86946FB29D3F9666294BEAC036062F4340FD1Ffriend 851010D4FDA491244ACAAD5B0E97E71DBFD85625 你可以看到在目录下已经有 cool 和 friend 两组 key 了： 123456AllendeMacBook-Pro:~ $ ls -l ~/.basecli/keys/total 32-rw------- 1 hxz staff 140 4 26 11:44 cool.pub-rw------- 1 hxz staff 238 4 26 11:44 cool.tlc-rw------- 1 hxz staff 142 4 26 11:45 friend.pub-rw------- 1 hxz staff 240 4 26 11:45 friend.tlc Initialize Basecoin初始化 Basecoin 区块链: 1234# WARNING: this will wipe out any existing info in the ~/.basecoin dir# don't run if you have lots of local state alreadyrm -rf ~/.basecoinbasecoin init $(basecli keys get cool | awk '&#123;print $2&#125;') basecoin 会创建出运行区块链必须的文件，在 ~/.basecoin 目录下，有一个 validator（验证节点）和一个账户(cool)。 1234567AllendeMacBook-Pro:~ $ ls -l ~/.basecoin/total 32-rw-r--r-- 1 hxz staff 309 4 26 11:47 config.tomldrwx------ 2 hxz staff 64 4 26 11:47 data-rw-r--r-- 1 hxz staff 529 4 26 11:47 genesis.json-r-------- 1 hxz staff 368 4 26 11:47 key.json-r-------- 1 hxz staff 475 4 26 11:47 priv_validator.json Start准备就绪！现在，我们可以启动 Basecoin 区块链了： 1basecoin start 你可以从控制台上看到，Basecoin 会每隔一秒出一个新块。 Initialize Light-Client现在，Basecoin 区块链已经运行，我们可以初始化 basecli了，它可以发送交易给 basecoin，并查询 basecoin 区块链的状态。 打开一个新的命令行窗口： 1basecli init --node=tcp://localhost:46657 --genesis=$HOME/.basecoin/genesis.json 通过提供 genesis 配置文件给 basecli，它会解析出区块链的 chainID 和 validator 集合，basecli 需要这些信息才能通过 basecoin 区块链的密码学验证逻辑。 注意：--genesis 只有在 validator 集合没有变动的情况下才能生效，如果之前 validator 集合发生过更改，你需要通过其他方式来找到当前区块链的 validator 集合。 Send transactions现在，我们可以发送交易了。 首先，来看下我们之前创建的两个账户的资产信息： 1234ME=$(basecli keys get cool | awk '&#123;print $2&#125;')YOU=$(basecli keys get friend | awk '&#123;print $2&#125;')basecli query account $MEbasecli query account $YOU 第一个账户显示出了它的资产信息，第二个账户显示账户不存在。让我们从第一个账户发点币给第二个账户： 123456789101112131415$ basecli tx send --name=cool --amount=1000mycoin --to=$YOU --sequence=1&#123; "check_tx": &#123; "code": 0, "data": "", "log": "" &#125;, "deliver_tx": &#123; "code": 0, "data": "96905F5B71953A6C9BF20ABF05B2C614176BC0A9", "log": "" &#125;, "hash": "743D40A6EB009E18C162FA7DA98B57FBC324187E", "height": 1013&#125; 第二个账户现在有 1000 个 mycoin 了，我们可以从第二个账户发回 500 个给第一个账户： 1basecli tx send --name=friend --amount=500mycoin --to=$ME --sequence=1 如果我们发送的币超出发送者拥有的数量，毫无疑问，会报错： 1basecli tx send --name=friend --amount=500000mycoin --to=$ME --sequence=2 从上面例子都可以看出，每次发送交易时，需指定发送者名字 --name，发送币及数量 --amount，接收者名字 --to 以及本次交易的序列号 --sequence（有序递增），区块链则返回本次交易 hash，我们可以根据这个 hash 查询到本次交易在区块链上的记录。 123456789101112131415161718192021222324252627282930313233343536373839404142434445basecli query tx 743D40A6EB009E18C162FA7DA98B57FBC324187E&#123; "height": 1013, "data": &#123; "type": "send", "data": &#123; "gas": 0, "fee": &#123; "denom": "mycoin", "amount": 0 &#125;, "inputs": [ &#123; "address": "CD86946FB29D3F9666294BEAC036062F4340FD1F", "coins": [ &#123; "denom": "mycoin", "amount": 1000 &#125; ], "sequence": 1, "signature": &#123; "type": "ed25519", "data": "66EB328A0CD5AF23C7740CF833E20D3D7A424D3535528EBCDFACB39EA92FE354DDF5EBE7B04D4BB064D10AA675F561E9EC94FCB896DE830234F5E191B1815C09" &#125;, "pub_key": &#123; "type": "ed25519", "data": "DB09171E2557503457F8C4DD518A0B030089F0A967068C8F8C69EBC59CCFF0F9" &#125; &#125; ], "outputs": [ &#123; "address": "851010D4FDA491244ACAAD5B0E97E71DBFD85625", "coins": [ &#123; "denom": "mycoin", "amount": 1000 &#125; ] &#125; ] &#125; &#125;&#125; Accounts and Transactions为了更好地理解 basecli 以及 basecoin 是如何工作的，我们需要先补点跟账户、交易相关的基础知识 Accounts受以太坊的账户系统的启发，Basecoin 维护了一个账户系统，每个账户包含一个公钥、不同币种的资产信息以及一个严格递增的交易序列号。请注意：Basecoin 是一个多数字货币资产钱包，因此每个账户可以有许多种不同的 token。 123456789101112type Account struct &#123; PubKey crypto.PubKey `json:"pub_key"` // May be nil, if not known. Sequence int `json:"sequence"` Balance Coins `json:"coins"`&#125;type Coins []Cointype Coin struct &#123; Denom string `json:"denom"` Amount int64 `json:"amount"`&#125; 如果你想往区块链里添加更多的币种，只需要在区块链初始化前手动编辑 ~/.basecoin/genesis.json 。 账户被序列号保存在默克尔树中，键为 base/a/&lt;address&gt;，其中&lt;address&gt;是账户的地址。一般地，账户地址是一个 20 字节的公钥哈希（RIPEMD160算法），当然，其他格式也支持。Basecoin 中用到的默克尔树是一个平衡二叉查找树，也称 IAVL树。 TransactionsBasecoin 定义里一个简单的交易类型 SendTx，它包含一个或多个输入和输出，允许 token 从一个账户转移到其他账户。 12345678910111213141516171819type SendTx struct &#123; Gas int64 `json:"gas"` Fee Coin `json:"fee"` Inputs []TxInput `json:"inputs"` Outputs []TxOutput `json:"outputs"`&#125;type TxInput struct &#123; Address []byte `json:"address"` // Hash of the PubKey Coins Coins `json:"coins"` // Sequence int `json:"sequence"` // Must be 1 greater than the last committed TxInput Signature crypto.Signature `json:"signature"` // Depends on the PubKey type and the whole Tx PubKey crypto.PubKey `json:"pub_key"` // Is present if Sequence == 0&#125;type TxOutput struct &#123; Address []byte `json:"address"` // Hash of the PubKey Coins Coins `json:"coins"` //&#125; 注意到SendTx还包含 Gas和 Fee字段，Gas 限制了每次交易最多允许执行的计算次数，Fee 指这比交易的交易费，validator 根据交易费大小对接收到的交易进行打包排序，这有点类似于比特币中手续费概念。 和以太坊中的 Gas、GasPrice 概念稍微有点不同，以太坊中的交易费 Fee = Gas x GasPrice，在 Basecoin 中，Gas 和 Fee 是两个独立的概念。 只有在 Sequence == 0 的时候，PubKey才是必选项。之后，它会存储在默克尔树该账户对应的 key 中，后续的交易只需要引用PubKey对应的 Address就可以指定发送者了。 最后，多个输入账户和多个输出账户可以让我们在一笔交易中就实现在不同账户间多个 token 的转移，当然，你必须保证”价值守恒”(输入=输出，交易费已经在 Fee 中指定)，并且，每个输入都要有对应账户的私钥签名。 Conclusion本章介绍了 basecoin 和 basecli 两个命令行工具及其基本用法，演示了如何启动一条 basecoin 区块链，怎样在账户间发送 token，并讨论了 basecoin 中账户和交易类型，下一章，我们将介绍 Basecoin 的插件系统，实现不同插件的扩展。]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>跨链</tag>
        <tag>IBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨链三部曲-0：开篇]]></title>
    <url>%2F2018%2F05%2F07%2Fcross-chain-0-preface%2F</url>
    <content type="text"><![CDATA[区块链技术发展到现在，从开山鼻祖比特币开始，涌现出了各种形形色色的链。 但，由于每个链都是独立的、垂直的封闭体系，当前的链圈只是由许多彼此割裂开来的区块链「孤岛」构成，链与链之间无法进行价值和数据的交换。 讽刺的是，声称去中心化的区块链之间的价值互换却主要依靠中心化的交易所来完成。 为了实现区块链之间的原子交易、资产转换、区块链内部信息互通，涌现了各种 跨链 技术。 但是，跨链是一个复杂的过程，它涉及到三个核心功能点： 单独验证链中信息 去中心化的输入 获取验证链外信息 《深度解析：区块链跨链技术》 和 V神：区块链跨链技术大规模应用将在一到两年内爆发 这两篇文章总结了目前主流的跨链技术： 公证人机制（Notary schemes） 侧链/中继（Sidechains/relays） 哈希锁定（Hash-locking） 分布式私钥控制（Distributed private key control） 早期跨链技术关注的是资产转移，这类代表有瑞波和 BTC Relay；现有跨链技术则侧重于跨链基础设施，典型代表有 Polkadot 和 Cosmos；新出现的 FUSION 想要做价值互联网时代的金融（即加密金融），它实现了高效率的、面向多币种和多种触发机制的增强型智能合约，可以支持丰富的的跨链金融应用。 这些跨链技术，网上都有很多理论性的分析文章，但理论归理论，“纸上得来终觉浅”，没有一个实际的例子，总感觉领会得不够透彻。 这个系列，我将由浅入深地给大家介绍一个基于 Cosmos 生态的跨链例子：Basecoin。但是，先别急，在此之前，你得补习下跟 Basecoin 相关的背景知识。 为了研究一个点，你需要搞清楚它的来龙去脉，因果背景……没有前面这些知识的铺垫，我估计没人知道我在说什么。 首先，有必要先了解下 Cosmos。《前沿跨链技术Cosmos简介》 这篇文章介绍了 Cosmos 的前世今生，对于初学者来说是很好的科普资料。这里，我略作总结： Cosmos 是跨链开源项目，它的目标是建立区块链的“互联网”，在多链多币的世界里，通过跨链代币转移技术构造一个深度集成的代币经济生态系统。 Cosmos 的底层是 Tendermint，它包含两个核心组件：一个区块链共识引擎（Tendermint Core）和一个通用的应用程序接口（ABCI）。 共识引擎采用了 PBFT 共识算法，通过一个基于弱同步的假设的两轮投票机制，最多可以容忍 1/3 的拜占庭节点（可简单理解为“异常节点”和“作恶节点”），它也是确定性一致算法，区块链保证永不分叉，共识效率比较高，秒级出快，TPS 可达到上千。 Tendermint 通过提供一个非常简单的 ABCI 接口，将区块链底层复杂的共识逻辑和应用程序逻辑分离开来。举个大家比较熟悉的例子，比特币。比特币是一个加密货币区块链，每个节点维护了一份完整的 UTXO 数据库。如果有人想基于 Tendermint 创建一个类似比特币的 ABCI 应用，Tendermint Core 将会负责： 在节点间广播区块和交易 维护区块链的不可变性 而 ABCI 应用程序将会负责： 维护 UTXO 数据库 验证交易的加密签名 阻止花费尚未存在的交易 允许客户端查询 UTXO 数据库 ABCI 应用的合约可以用任何编程语言进行编写，这比起以太坊应用的合约受限于 Solidity 这么一种冷门的编程语言来说，区块链开发者们纷纷表态“不能同意更多”。 Cosmos 中使用的跨链技术用的是 侧链 机制，它规定了一套跨链通讯协议（IBC），通过它来实现的代币的跨链转移，我们这个系列要讲的 Basecoin 说白了也是一个 IBC 的具体实现。 IBC 的目的是让区块链彼此之间充当一个轻量级的客户端，由于 Tendermint 底层使用PBFT 共识算法，多个校验节点在处理新的区块之前会先达成一致，在客户端上进行验证是简单可行的：只须校验最新块的签名并验证默克尔树的 PoS 即可。 IBC 工作流程如下： 假设我们有两条区块链：Test_chain_1 和 Test_chain_2，从 Test_chain_1 发送数据到 Test_chain_2: 好了，前期知识铺垫得差不多了：我们从跨链技术的背景讲起，讲到了 Cosmos，Tendermint，ABCI，IBC，在这个过程中，大家脑海里应该被我灌输了这么几个概念： Cosmos 是一个专注于跨链资产转移的代币生态系统 Cosmos 的底层是 Tendermint 共识引擎 IBC 是 Cosmos 生态内部的一套跨链通讯协议 Basecoin 是一个基于 Tendermint 的 ABCI 应用 Basecoin 是一个基于 IBC 协议的跨链应用 终于要正式迎接 Basecoin 粉墨登场了。]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>跨链</tag>
        <tag>IBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我体验了 N 款数字货币钱包]]></title>
    <url>%2F2018%2F05%2F06%2FI-expericed-N-digital-wallet%2F</url>
    <content type="text"><![CDATA[钱包，被看作未来数字资产交易的入口，谁能成为其中的独角兽，谁就可能会成为未来区块链版的“支付宝”，甚至“微信”。 我司举办了一次“钱包抓虫大赛”，号召全公司员工去体验市面上流行的各种数字货币钱包，分析其优缺点，以便为我们的钱包设计提供借鉴和参考。 目前，各大主流钱包花样繁多，归根结底，我认为，钱包需要解决的核心需求无外乎： 资产管理 转账收款 私钥管理（我一直认为，凡是在服务端保存用户私钥的钱包都是伪钱包，无一例外） 一个钱包至少要在这三个功能点上做到“上手容易、操作简便、体验流畅”才能算是一个合格的钱包。 当然，大多数钱包还会在其它非主流功能上做文章： 收发红包 联系人 市场行情 业内资讯 第三方应用 C2C交易 多语种 小明周末两天挨个问候了目前用户群比较大的几款钱包，稍作整理，报告如下（仅代表个人看法）： imToken 优点： 界面优雅，蓝白相间的主题色调给人一种静谧的安全感（看得出，imToken 的设计师有一定的美学修养） 添加 token、收款转币体验非常流畅。特别是转账操作，既支持普通简易版，也支持高级选项版（设置 gas，gas price，自定义数据），照顾了多种用户需求，用户提示信息也出现得恰到好处。 支持多种导入导出方式（助记词、keystore、私钥、二维码扫描） 支持离线签名 卡片式集成第三方 DApp 缺点： 目前只支持以太坊生态圈币种（不过，据说最新的内测版支持 BTC 等其它主流币种） 资产不为零的 token 不会主动显示，需手动添加 行情只能看，无法进行交易 设置收款金额后，生成二维码时，二维码显示白底，需过一会后才恢复正常 比特派与其说它是钱包，不如说是个交易所 App，因此谈不上有什么钱包的优缺点，下面我从交易所 App 的角度来评价。 整体界面设计水平一般，顶层两栏有碍瞻观。 优点： 支持主流币种，其中 BTC 和 ETH 系的可以直接添加，其它系的需要搜索 支持一键买卖(支付宝、银行卡)、C2C交易、一键发token、eos映射 缺点： 切换币种时有烦人的提示 用户无法管理私钥，极不安全 身份验证无法上传照片，只能拍摄 功能太杂太乱 Kcash优点： 简直就是 imToken 的翻版（抄也抄得有模有样），不过这里的背景色调为金灰色，给人一种金光闪闪的土豪即视感。 用户体验和 imToken 不相上下，学习成本低 一套助记词，生成多种主流币种的私钥 支持 收发红包（红包代币可选，这是个中心化功能，需要用户注册登陆，钱包会为用户分配一个托管账户来管理跟红包相关的资产，托管账户和本地钱包账户是独立的），领红包界面设计得很好，用户提示细致周到，一步一步手把手告诉用户怎么领红包，充分吸引新用户去下载使用钱包 缺点： 新用户领红包要输入两次手机号和短信验证码，过程略繁琐 不支持多个钱包账户 不支持联系人功能 不支持离线签名 转账不支持用户设置矿工费和自定义数据 Cobo 钱包优点： 界面清爽，收发币体验流畅 支持主流币种 支持 收发红包，领红包过程较 kcash 更流畅 缺点： 需要注册登陆后才能用 本地无法管理私钥，由服务端保存，不安全 P钱包 http://pqb.com这款是我们公司开发的，由于没有专业的设计师和产品经理把关，无论是从设计还是用户体验来看，这款钱包都还有很多值得改进的地方。 优点： 一套助记词，生成多种主流币种的私钥 支持多个钱包账户 私钥只在本地保存（还支持导出到手机 SIM 卡） 支持离线签名（需搭配离线钱包使用） 缺点： 界面不美观：对于交易记录没有或很少的币种，上方的币种 Tab 页拥挤在一起，下方却显示一大片空白区域。 收发币操作流程不流畅： 首先，需要先滑到对应那个币种的 Tab 页 然后，选择接收方地址还要在“我的地址（默认）”和“我的好友” Tab 栏中切换一次，其实用户大部分都是转币给别人，为什么不默认跳到“我的好友”栏 名字太不好听，“屁钱包”？ 只能新增、无法删除某个钱包账户 生成私钥最后一步，“导出私钥”，界面却显示“导入私钥”，让人搞不明白到底什么意思 不支持生成固定金额的收款二维码 加载币种历史账单记录，一直显示“正在加载” 资产显示有问题，区块链上确认得记录了，P 钱包这边等了几个小时还是显示 0.0…… 总结总的来说，钱包市场百花齐放，良莠不齐，各领风骚。 imToken 因为其优雅的界面和良好的用户体验吸引了第一波种子用户，并且用户群在业内是当之无愧的第一位（已经上百万了）。 但是，由于它仅支持 ETH 系币种，使得其它支持 BTC 等主流币种的钱包异军突起。KCash 和 Cobo 对着 imToken 的设计依样画葫芦，通过 “抢红包” 这个大招吸引了不少用户群。 我司的 P 钱包（以后会重塑个上得了台面的名字吧）仍需努力啊。]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>钱包</tag>
        <tag>imToken</tag>
        <tag>KCash</tag>
        <tag>P钱包</tag>
        <tag>Cobo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql主从同步/复制]]></title>
    <url>%2F2018%2F04%2F14%2Fmysql-master-slave-sync%2F</url>
    <content type="text"><![CDATA[主从同步原理 在master机器上，主从同步事件会被写到特殊的log文件中(binary-log);在slave机器上，slave读取主从同步事件，并根据读取的事件变化，在slave库上做相应的更改。 主从同步作用 数据备份：主数据库服务器故障后，可切换到从数据库继续工作，避免数据丢失。 架构扩展：水平扩展数据库的负载能力。当业务量越来越大，I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的频率，提高单个机器的I/O性能。 读写分离：写服务使用master，读服务使用slave，读写服务分离互不影响，提高并发访问性能。 主从同步格式binlog日志格式有3种，mysql默认采用 Statement： Statement：基于语句的复制，主库把 sql语句 写入到binlog中，完成复制 优点是并不需要记录每一条sql语句和每一行的数据变化，减少了binlog日志量，节约IO，提高性能。缺点是在某些情况下会导致master-slave中的数据不一致(如sleep、last_insert_id以及user-defined functions等函数会出现问题)。 Row：基于行数据的复制，主库把每一行 数据变化 的信息作为事件，写入到binlog，完成复制 优点是不会出现某些特定情况下的存储过程、或function、或trigger的调用和触发无法被正确复制的问题。缺点是会产生大量的日志，尤其是 alter table的时候会让日志暴涨。 Mixed：statement与row的 混合 默认用语句复制，出问题时候自动切换成行数据复制,MySQL会根据执行的SQL语句选择日志保存方式。 主从同步过程主从同步需要3个线程协作： 主库-binlog输出线程: 每当有从库连接到主库的时候，主库都会创建一个线程然后发送binlog内容到从库。 从库-I/O线程: 当START SLAVE语句在从库开始执行之后，从库创建一个I/O线程，它读取主库的binlog输出线程发送的更新并拷贝这些更新到本地relay log文件。 从库-SQL线程: 读取从库I/O线程写到relay log的更新事件并执行。 主从同步实践主从部署必要条件： 主库开启binlog日志 主从server-id不同 从库服务器能连通主库 环境准备本地docker安装两个mysql: 123mysql:5.6mysql1(master): 172.17.0.3:3307mysql2(slave): 172.17.0.2:3308 配置文件mysql1(master): 172.17.0.3 配置: 1234567891011121314151617#mysql master1 config [mysqld]server-id = 1 # 节点ID，确保唯一# log configlog-bin = mysql-bin #开启mysql的binlog日志功能sync_binlog = 1 #控制数据库的binlog刷到磁盘上去 , 0 不控制，性能最好，1每次事物提交都会刷到日志文件中，性能最差，最安全binlog_format = mixed #binlog日志格式，mysql默认采用statement，建议使用mixedexpire_logs_days = 7 #binlog过期清理时间max_binlog_size = 100m #binlog每个日志文件大小binlog_cache_size = 4m #binlog缓存大小max_binlog_cache_size= 512m #最大binlog缓存大binlog-ignore-db=mysql #不生成日志文件的数据库，多个忽略数据库可以用逗号拼接，或者 复制这句话，写多行auto-increment-offset = 1 # 自增值的偏移量auto-increment-increment = 1 # 自增值的自增量slave-skip-errors = all #跳过从库错误 mysql2(slave): 172.17.0.2 配置: 1234567[mysqld]server-id = 2log-bin=mysql-binrelay-log = mysql-relay-binreplicate-wild-ignore-table=mysql.%replicate-wild-ignore-table=test.%replicate-wild-ignore-table=information_schema.% 重启两个mysql，让配置生效 master数据库进入master的数据库，为master创建复制用户 1CREATE USER repl_user IDENTIFIED BY 'repl_passwd'; 赋予该用户复制的权利 123grant replication slave on *.* to 'repl_user'@'172.17.0.2' identified by 'repl_passwd';FLUSH PRIVILEGES; 查看master的状态 1234567mysql&gt; show master status;+------------------+----------+--------------+------------------+-------------------+| File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |+------------------+----------+--------------+------------------+-------------------+| mysql-bin.000005 120| | mysql | |+------------------+----------+--------------+------------------+-------------------+1 row in set (0.00 sec) slave数据库1234567891011mysql&gt; CHANGE MASTER TO MASTER_HOST = '172.17.0.3', MASTER_USER = 'repl_user', MASTER_PASSWORD = 'repl_passwd',MASTER_PORT = 3307,MASTER_LOG_FILE='mysql-bin.000005',MASTER_LOG_POS=120,MASTER_RETRY_COUNT = 60,MASTER_HEARTBEAT_PERIOD = 10000; # MASTER_LOG_FILE='mysql-bin.000005',#与主库File 保持一致# MASTER_LOG_POS=120 , #与主库Position 保持一致 启动从库slave进程 12mysql&gt; start slave;Query OK, 0 rows affected (0.04 sec) 参考 What is MySQL Replication and How Does It Work? MySQL Master-Slave Replication on the Same Machine HOW TO SETUP MYSQL 5.7 REPLICATION WITH MONITORING ON UBUNTU 16.04]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>同步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gopher 做 PPT 的正确姿势]]></title>
    <url>%2F2018%2F03%2F28%2FGopher-slide%2F</url>
    <content type="text"><![CDATA[试想一下，你作为一枚区块链技术开发者，受邀到某个区块链峰会做演讲，你总得做个 PPT 吧，做 PPT， mac 上自带了 keynote、pages 等软件还好，windows 系统的话你还得装个 powerpoint 吧。 到了会上做演讲，要么你自带笔记本，要么会场的电脑也得装了 PPT 播放软件，你才能把 PPT 投射出来。 嗯，情况就是这样。 我总觉得还是有点不方便。 而且，我想，我肯定不是第一个有这种感觉的人。 Origin最近，我们区块链底层开发组来了好几个实习生，我要给这拨刚毕业的同学们做个 go 语言基础培训，那肯定要做个类似于课件啊、讲义之类的 PPT 吧。 刚开始，我打开了 mac 的 keynote 捣鼓会，其实就跟 windows 上搞 ppt 差不多的操作…… 但是，我烦了。 我们这类技术培训，大部分内容跟代码相关，在 PPT 上贴一大段代码毕竟画面不会太好看，“PPT+IDE”组合又得不停地在两种窗口间切换来切换去，并且还得另外准备一份演示用的代码集。 懒人开始思考。 我想起刚学 go 语言那会在 YouTube 上看了不少 Google 大牛的 go 语言布道视频，他们演讲时好像是播放一种叫 slide 的文件，直接呈现在网页里，还可以在里面直接运行代码。 这正是我想要的，我花点时间研究了下其中的内幕。 Experientslide 是随着 Go 诞生而出现的一种 present 格式，Go 语言研发组那帮老爷们十分喜欢以这种格式分享 Go语言技术心得和想法，几乎所有技术会议的幻灯片均是以 .slide 形式提供的，给人一种“真会装逼”的感觉。 present 是一种文本标记语言，使用普通文本编辑器就能编写（还装什么 powerpoint、keynote啊），只要遵循它的语法，就可以使普通文本内容呈现出特定的格式。说白了，就跟我现在用 markdown 语法写这篇文章差不多，它让作者把精力花在内容上，而无需过多关心格式、排版等问题。 简单体验下 present 语法： 12345678Hello SlideHuang_Xuezhong33.cnhxz@disanbo.comhttp://hxzqlh.com* Hello world 就这么几行文本，就可以渲染出下面 3 张 slide。 回车键、方向键都可以控制往前或往后看～，神奇吧～ 本地运行的话，有这么几步： 1.先装一个 present 渲染工具。 1go get golang.org/x/tools/present 很不幸，如果你在天朝，无法访问 golang.org/x/tools, 不过好在你是一个 gopher，肯定知道，它已经转移到 github.com/golang/tools 有它的镜像，因此，在你的 GOPATH/src 下面手动创建个 golang.org/x 文件夹，再 git clone github.com/golang/tools，再 go install golang.org/x/tools/cmd/present, present 就安装到你的 GOPATH/bin目录中了。 2.在 slide 文件目录，将 present 跑起来： 12hxzdeMac-mini:~/workspace/slide $ present2018/03/27 20:34:36 Open your web browser and visit http://127.0.0.1:3999 3.打开浏览器访问 http://127.0.0.1:3999，会列出它渲染的 slide 文件列表，点击进去，就是见证奇迹的时刻…… Present花点时间熟悉下 persent 语法。 present 语法格式要求用户定义好 头部 和 正文。 header12345678910Title of documentSubtitle of document15:04 2 Jan 2006Tags: foo, bar, baz&lt;blank line&gt;Author NameJob title, Companyjoe@example.comhttp://url/@twitter_name 头部只有标题是必需的，它是第一个非空非注释行，子标题、日前、标签、作者等信息都是可选的，标题、作者头衔以及所在机构作为 slide 的第一页。 标签栏后留一个空行，可以附上作者信息：作者姓名、头衔、所在机构、邮箱、网站、Twitter名等，这部分会显示在最后那张 Thank you 的 slide 中。 body正文部分以 *后跟当前页标题来区分每张 slide。 正文语法示例如下，支持多级标题、列表、图片、代码段、网页链接等多种格式。 1234567891011121314151617181920212223242526272829* Title of slide or section (must have asterisk)Some Text** Subsection- bullets- more bullets- a bullet with*** Sub-subsectionSome More text Preformatted text is indented (however you like)Further Text, including invocations like:.code x.go /^func main/,/^&#125;/.play y.go.image image.jpg.background image.jpg.iframe http://foo.link http://foo label.html file.html.caption _Gopher_ by [[https://www.instagram.com/reneefrench/][Renée French]]Again, more text 最最令人兴奋的是，可以在里面直接跑代码： 真正的所见即所得啊，再也不用在代码区和演示文稿窗口间切来切去啦～这正是我等代码家梦寐以求的 PPT 打开方式啊。 关于 present 语法，这里 有详细的文档。 Watch It Everywhere本地 present 服务可以作为调试用，slide 最终是给别人看的。 通过 https://talks.godoc.org/ 提供的 present 渲染服务可以在线浏览 slide，并且支持 github 仓库中的 slide 文件。 Go 开发者们只需要将自己写好的 slide 文件存放在自己 github 上的仓库中，就可以随时随地打开这类 present 文件给大家分享了。 比如，我的 github 有一个叫 slide 的仓库地址：github.com/hxzqlh/slide/ ，里面有一个 golang_coding_standard.slide 然后，你只需按照【仓库地址/slide文件名】格式拼接到 https://talks.godoc.org/ 后面就可以观看了： https://talks.godoc.org/github.com/hxzqlh/slide/golang_coding_standard.slide 很实用吧。 但是…… 还是因为墙的原因，https://talks.godoc.org/ 在大陆是无法直接访问的，有梯子的还可以访问，没有梯子的怎么办？ TODO, 这里先挖个坑： 等有空了，我自己搭建个 https://talks.godoc.org/ 镜像。 有个老外在 YouTube 上放了个非常酷炫的 视频 来介绍 present，我上面讲的这些内容，里面都有涉及，我把它搬砖到腾讯视频了，快来看看吧。 Last如此一番折腾，我们得到了什么？ 我们可以不装 office，不用 keynote，只需打开你随身携带的记事本，简简单单地用 present 写 slide，一键上传至 github，只要有网，人人皆可访问。]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>slide</tag>
        <tag>present</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lisk：下一个百倍币，也许现在是最佳入手时机。]]></title>
    <url>%2F2018%2F03%2F07%2FLisk%2F</url>
    <content type="text"><![CDATA[最近，老外在 Twitter、Reddit、GitHub 上讨论得最多的数字货币是哪个？Lisk。 什么是 Lisk？Lisk 是第一个完全用 Javascript 实现的去中心化的区块链应用开发平台，建立于 2016 年初。它的宣传口号是“一个App一条侧链”，Lisk 使开发人员能够通过部署侧链到主网来创建、分发、管理去中心化的区块链应用（简称：dApp）。 以太坊有什么问题？目前，90% 的智能合约都是跑在以太坊上，用户想要创建一个基于区块链的语言受到多方面的限制： 合约只能用一种小众得不能再小众的 Solidity 语言编写 只能用 pow 挖矿算法 不得不忍受交易高峰期的网络拥堵 Lisk 有何与众不同之处？目前，业界的区块链解决方案都是基于单个区块链或为某个专用区块链量身定制的。如果某个智能合约出现漏洞，那么其它智能合约甚至整个区块链网络都会深受其害，最明显的例子就是 2016 年爆发的以太坊 DAO 漏洞，该漏洞迫使以太坊不得不进行“硬分叉”（严格意义上来说，我们现在所说的以太坊其实是伪区块链，因为它为了挽回用户被盗的币，篡改了区块链账本，致使部分交易记录凭空消失，而秉持区块链“不可篡改性”的一方后来称之为以太坊经典）。 Lisk 则努力提供两全其美的解决方案：Lisk 主链提供了稳定性和安全性，而侧链则具有无限的灵活性，可以创建成千上万个个性化的 dApp。 Lisk 主链为开发人员提供了一个安全可控的环境，开发人员可以为自己的应用创建一条侧链，从而不必面对从零开始构建区块链网络的复杂性。 不同侧链之间互不影响，所以，即使某个合约出现 bug，危害范围也只局限于它所在的那一条链，主链和其它侧链感觉不到。 由于侧链的灵活性，开发人员可以完全实现和定制其 dApp，“一个应用一个侧链”，保持了主链的简单干净，用户只有用到相关的应用时才需要下载对应的侧链，同步速度非常快，整个 Lisk 网络可以高效运行，这可能就是 Lisk 跟其它区块链开发平台（以太坊、EOS、NEO）最大的不同并可能超越它们的地方。 Lisk 的愿景是让开发者能快速方便地使用区块链技术，而不仅仅局限于一小戳极客圈子里，它提供了一个使用 JavaScript 语言编写的 SDK 和详细的说明 文档。 众所周知，JavaScript 语言本身十分简单，上手快，工具链丰富，用户群比 Solidity 多得不知道哪里去了，光开发语言这一点，Lisk 就占尽了先机。任何 Web 开发人员只要会 JavaScript 和 Node.js ，都可以立即转移到 Lisk 去开发去中心化的应用程序。 Lisk BlockchainLisk 是一条公链，主网从 2016-05-24 开始运行，平均每 10 秒产生一个新块，现在已经到了 540 万左右高度。 Lisk 区块链进行交易的代币叫 LSK，目前市场价格大概为 16 美元，初始分配额度为 100000000 LSK。每创建一个新块，5 个新的 LSK 将被添加到总供应中。每经过 3000000（〜1年）个高度，新块奖励减少 1 LSK，最终减少至每块 1 LSK，当前新块奖励为 4 LSK。 Lisk 采用 dPOS 共识机制，每次选出 101 名代表为 Lisk 网络提供安全保障，新块奖励在 101 名代表中平均分配。此外，代表根据他们为特定区块中的交易收取交易费用。这套激励机制，可以保护 Lisk 区块链网络能够自发健全地演化下去。 对于那些小交易，一般会在 6 个块（1分钟）后得到确认，大交易在本轮委托投票期（1010 秒，～17分钟）结束后得到确认。 类似比特币、以太坊，它也有自己的浏览器: https://explorer.lisk.io，用户地址格式如 13449367279616835943L，是一串 20 个阿拉伯数字后面跟一个L。 Why Best Time to Buy LSK?好了，现在回答我的标题，为什么说“现在是 LSK 的最佳入手时机”？ 2018-02-20, Lisk 在柏林举行了 Rebrand 发布会，在接下来的 4 到 6 周（也就是三月底到四月初），将会发布重大更新：Lisk Core 1.0 Beta 版。跟据过往经验，一般某个币种社区公布了某项具有突破性质的进展后，该币都会蹭蹭蹭直线上涨。 我们看数字货币行情，受主流数字货币影响，LSK 近期已经从 35 美元持续下跌到了 16 美元。奇货可居啊，聪明的韭菜都知道在低价的时候买入，等待它涨到理想的高价吧。 据 CryptoMiso 报道，一大波开发者们正在涌向 Lisk：过去 3 个月，LSK 位列”数字货币类 GitHub 代码活跃度”排名榜首，众人看好的 EOS 也不过排第三而已。 是的。2018 年，LSK 极有可能上涨到 100 美元。]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>LSK</tag>
        <tag>以太坊</tag>
        <tag>EOS</tag>
        <tag>NEO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大年初二，写给女儿]]></title>
    <url>%2F2018%2F02%2F17%2F2nd-day-of-Chinese-new-year-2018%2F</url>
    <content type="text"><![CDATA[没有「的」，没有 「地」，也依旧没有 「得」字。 过完年，瑄瑄就号称三岁，实岁一年六个月左右。但无论从身板还是心智来看，她真像有三岁多，比一般同龄小孩高半个头。 这个小情人真够俊俏，眉清目秀，五官端正，脸庞没有一点瑕疵，颜值全村第一，好几百个父老乡亲一致认证通过。 瑄宝乖巧又懂事。很少哭闹，按时喝牛奶；想要嘘嘘或便便时，会指着下身暗示大人；爷爷奶奶忙就跟爸爸妈妈玩耍。这两天长辈给她塞不少红包，都交给爸爸，蛤蛤，我可从来没教过这个哦。 瑄宝这点年纪，就很有条理，长大后当班长应该比你爹更称职：家中东西，大大小小，必须放在原位，一个摆错就指挥你一定要摆好放正；爸爸皮衣拉链没拉好她就不放手，硬是要看到拉成一条直线她才放心。 吃完零食，知道把袋子丢到垃圾桶；有时哭泣把奶奶衣服弄脏会指着脏处叫我们拿纸巾擦干净；睡觉前或跟人道别两只手做“拜拜”。你说她这么小，怎么知道这么多？ 最近，电视被瑄宝霸占，从早到晚只能固定CCTV音乐频道，而且只能是那个“广场舞金曲”，有时她在外面玩着，只要一听到广场舞放完，马上遥指电视“呃呃呃”叫嚷，还好有回看功能，给她倒过去看呗，其实只是听听，有《最炫民族风》和《小苹果》就跟着节拍手舞足蹈，你说这个小女孩，可爱不可爱？大年三十，爷爷连春晚都没法看，5555~ 这个小屁孩，勺子筷子左右互搏，吃饭时还给我夹菜呢。要陪她玩王中王鞭炮，捂住耳朵，躲在背后，炮一响，惊一下，抱住爸爸，真是可爱。 这大半年，瑄宝在老家，我和老婆在杭州，几乎每天晚上都跟她微信视频，这点小习惯，发挥不少余热：这几天陪她玩，逗她，抱她，亲她，现在瑄宝喊「爸爸~爸爸~」，叫起来甜，听起来也甜。]]></content>
      <categories>
        <category>心旷神怡</category>
        <category>黄泽瑄</category>
      </categories>
      <tags>
        <tag>春节</tag>
        <tag>女儿</tag>
        <tag>的地得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[祝大家新年玉快阖家欢落]]></title>
    <url>%2F2018%2F02%2F16%2Fhappy-Chinese-new-year-2018%2F</url>
    <content type="text"><![CDATA[元旦没有写点东西，就值此新春佳节之际，来个小小的总结吧。 过去的这一年，我的工作依然是搞后台开发，不同的是以前主攻C++，现在新学了个新技能Go，用得如鱼得水。 还换了家公司。因不甘于在前公司的人事斗争中做牺牲品，放弃了年终奖（后来打听到前公司到了10月份也没发……)，4月底果断地跳了出来。 事实证明，这是个不艰难但很正确的决定：我很庆幸自己在2017年区块链行业刚刚火爆发展的那个时间点加入了复杂美公司，个人能力在各个维度都被逼锤炼提高，从之前只能默默地做一个螺丝钉，修修补补bug，到挑大梁，独当一面，指导新人(人称彦祖老师)，年终还一不小心还拿了个优秀员工奖(10万个YCC，此处有憨笑脸)，有付出，有回报，有钱途，展望新年，有好几个小目标等着我们大刀阔斧地去干…… 大概说了工作，谈谈家人。小女两岁，聪明伶俐，活泼可爱，西湖区第一萌~，得亏丈母娘和岳父大人在老家帮带，二老付出诸多心血，着实不易，所以，这个年又陪他们一起过了。 今年把家搬到转塘公租房了，感谢党，感谢政府，感谢习大大对我们这些困难群众的挂念和帮助。 跟老婆两个人在一起的小日子总是油腻中夹杂点酸辣，小吵小闹也是有的，多哄哄，多体贴下，老婆就会还你一个和谐的家。这个知性的辣妹子呀，能工作又会持家，真是个贤惠的新时代女性。 摇号摇了两年，今年还是没有摇上，人品可见一斑，希望明年好运来吧。 写到这里，外面已经开始鞭炮迎新年啦，也不多说了罢，新的一年，祝大家： 春节玉快，阖家欢落！]]></content>
      <categories>
        <category>心旷神怡</category>
      </categories>
      <tags>
        <tag>春节</tag>
        <tag>戊戌</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再来一次手牵手：php7.0 + protobuf]]></title>
    <url>%2F2018%2F01%2F19%2Fphp-protobuf%2F</url>
    <content type="text"><![CDATA[这两天在折腾 php。 php 作为世界世界上最好的编程语言，我不过是读研那会给导师做项目的时候撸过一年的代码，水平一般，只了解基本的语法，会进行简单的 php 后台开发，后来就没再用过了。 这次，是为了工作需要，在整理项目模块的时候，同事反映“之前的 php5.x 对 protobuf 的支持不是很好，解码出来的数据结构跟其它语言的对不上……”， 我当时的第一反应是：居然有这种事？至于具体是不是真的如此，我也懒得去重现。那是两年前的事，现在 php 都到 7.x ，protobuf 都到 3.5.1 了，时过境迁，IT 技术日新月异，或许问题早就解决了呢？ 报着试一试的态度，我主动提出来调研下 “protobuf 在 php7.0 的用法”。 phpdocker 里面现成的 php 镜像多的是，想要快的话，直接 run 一个 php 容器出来就可以，但是我想从零开始，体验下 Linux 配置 php 开发环境的流程，一步一个脚印，给人一种稳重的安全感。 所以，所以还是从一个裸体的 ubuntu 系统开始吧。 启动一个 ubuntu:16.04 容器： 1docker run -d -P -it ubuntu:16.04 bash 先装 php 的，这里我选了 7.0 版本： 1234567root@aae76b5e0ca4:/var/www/html# apt-get updateroot@aae76b5e0ca4:/var/www/html# apt-get install php7.0root@aae76b5e0ca4:/var/www/html# php -vPHP 7.0.22-0ubuntu0.16.04.1 (cli) ( NTS )Copyright (c) 1997-2017 The PHP GroupZend Engine v3.0.0, Copyright (c) 1998-2017 Zend Technologies with Zend OPcache v7.0.22-0ubuntu0.16.04.1, Copyright (c) 1999-2017, by Zend Technologies 装个 nginx 服务器来驱动 php 脚本吧： 123root@aae76b5e0ca4:/var/www/html# apt-get intall nginxroot@aae76b5e0ca4:/var/www/html# nginx -vnginx version: nginx/1.10.3 (Ubuntu) 配置下 nginx，开启 php 解释器， 修改 /etc/nginx/sites-enabled/default 这部分如下： 1234567location ~ \.php$ &#123; include snippets/fastcgi-php.conf; # With php7.0-cgi alone: # fastcgi_pass 127.0.0.1:9000; # With php7.0-fpm: fastcgi_pass unix:/run/php/php7.0-fpm.sock;&#125; 启动 PHP 和 nginx 服务： 123root@aae76b5e0ca4:/var/www/html# service php7.0-fpm startroot@aae76b5e0ca4:/var/www/html# service nginx start * Starting nginx nginx [ OK ] 这样，php 运行环境就搭建好了，可以写个简单的 PHP 脚本 helloworld.php 来验证下，把它放在 nginx 默认的网站根目录 /var/www/html 中: 123&lt;?php echo "Hello World!";?&gt; 现在就是见证奇迹的时刻： 12root@aae76b5e0ca4:/var/www/html# curl 127.0.0.1/helloworld.phpHello World! 只需几步就配置好了 php 运行环境，真是 Excited！ protobufphp7 要使用 Google protobuf 需要安装两个东西：protoc 编译器 和 php 扩展库。 protoc 编译器到 https://github.com/google/protobuf/releases 下载 linux 平台的 protoc ，把 bin 和 include 里面的文件拷贝到 /usr/local 的对应目录，这样 protoc 就算安装完成了： 12root@aae76b5e0ca4:/var/www/html# protoc --versionlibprotoc 3.5.1 写个 test.proto： 123456789101112131415161718syntax = "proto3";message PhoneNumber &#123; string number = 1; int32 type = 2;&#125;message Person &#123; string name = 1; int32 id = 2; string email = 3; repeated PhoneNumber phone = 4; double money = 5;&#125;message AddressBook &#123; repeated Person person = 1;&#125; 这个 proto 文件是什么意思，相信用过 proto 的人都知道。 编译 proto 文件： 123456789root@aae76b5e0ca4:/var/www/html# mkdir fooroot@aae76b5e0ca4:/var/www/html# protoc --php_out=foo test.protoroot@aae76b5e0ca4:/var/www/html# tree foo/foo/|-- AddressBook.php|-- GPBMetadata| `-- Test.php|-- Person.php`-- PhoneNumber.php 可以看到，protoc 编译出的结果里包含三个 php 文件（对应 proto 文件里面声明的三种结构）和 一个 GPBMetadata 文件夹（下面的 Test.php 描述了 test.proto 文件的元信息）。 php 扩展库protobuf 的 php 扩展 官方 提供了 c 动态库 和 php 包两种形式。 php 包形式我折腾了半天也不会用，烦死了。还是安装 c 动态库形式的扩展吧： 12345678root@aae76b5e0ca4:/var/www/html# apt-get install php-pear php7.0-dev autoconf automake libtool make gccroot@aae76b5e0ca4:/var/www/html# pecl install protobuf-3.5.1...Build process completed successfullyInstalling '/usr/lib/php/20151012/protobuf.so'install ok: channel://pecl.php.net/protobuf-3.5.1configuration option "php_ini" is not set to php.ini locationYou should add "extension=protobuf.so" to php.ini 提示安装成功，但还需要修改 php 的配置文件 /etc/php/7.0/fpm/php.ini， 开启 protobuf 库支持： 12;extension=php_xsl.dllextension=protobuf.so 重启 php7.0-fpm 服务。 Test准备工作做好后，就可以正式进行 protobuf 解析了。 写个测试例子 test.php： 123456789101112131415161718192021222324252627282930313233343536&lt;?phprequire_once "foo/GPBMetadata/Test.php";require_once "foo/AddressBook.php";require_once "foo/Person.php";require_once "foo/PhoneNumber.php";$foo = new Person();$foo-&gt;setName('hxz');$foo-&gt;setId(2);$foo-&gt;setEmail('notexist@foxmail.com');$foo-&gt;setMoney(1988894.995);$phone_num = new PhoneNumber();$phone_num-&gt;setNumber('1351010xxxx');$phone_num-&gt;setType(3);$phone = array();array_push($phone, $phone_num);$foo-&gt;setPhone($phone);$packed = $foo-&gt;serializeToString();try &#123; $p = new Person(); $p-&gt;mergeFromString($packed); echo "------------parsed-------\n"; echo $p-&gt;getName() ."\n"; echo $p-&gt;getEmail() ."\n"; echo $p-&gt;getMoney() ."\n"; echo $p-&gt;getId() . "\n"; echo $p-&gt;getPhone()[0]-&gt;getNumber() ."\n";&#125; catch (Exception $ex) &#123; die('Upss.. there is a bug in this example');&#125;?&gt; 访问 127.0.0.1/test.php 输出： 1234567root@aae76b5e0ca4:/var/www/html# curl localhost/test.php------------parsed-------hxznotexist@foxmail.com1988894.99521351010xxxx 看上去，protobuf 的 serializeToString 和 mergeFromString 都没有问题。 一切看上去都那么自然，但，这里有个问题，不得不提下。测试发现： 在 test.php 中，必须引入 proto 文件中声明过的所有结构类型（即使你只用到了里面的一个类型），否则会报错。 比如，注释掉这行 require_once &quot;foo/AddressBook.php&quot;;（事实上，AddressBook 这个类也没有用到）, nginx-error 日志输出： 12018/01/19 08:32:10 [error] 6880#6880: *39 recv() failed (104: Connection reset by peer) while reading response header from upstream, client: 127.0.0.1, server: _, request: "GET /test.php HTTP/1.1", upstream: "fastcgi://unix:/run/php/php7.0-fpm.sock:", host: "localhost" 这个就很恶心了，“我只想要个苹果，你却给我一车梨？”。具体原因我还不知道，谁能帮我解释下吗？ 总结php 本身的确是门很简单易用的语言，加上我当年学到的东西还没有忘光，所以重新拾起来还是有故人重逢的感觉。 小试牛刀发现：php7.0 下 protobuf 扩展是可以用的，配置起来也不是很难。 然后，我在调研过程中，还是留了 2 个坑： php 扩展包的另外一种安装方式 拔一发而动全身：必须引入 proto 文件中声明过的所有结构类型 有收获，也有遗憾，这次 “php7.0+protobuf” 的填坑之旅就这样告一段落吧，具体的业务代码，就让 phper 们去撸吧， 我还是喜欢用 go。]]></content>
      <categories>
        <category>Coder</category>
      </categories>
      <tags>
        <tag>protobuf</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql 热备份迁移]]></title>
    <url>%2F2018%2F01%2F17%2Fmysql-back-migration%2F</url>
    <content type="text"><![CDATA[Xtrabackup 是由 percona 公司 开源 的免费数据库 热备份 软件，它能对 InnoDB数据库和 XtraDB存储引擎的数据库进行 非阻塞 地备份。 众所周知，mysqldump 备份方式是采用的逻辑备份，其最大的缺陷是备份和恢复速度较慢，如果数据库大于50G，mysqldump备份就不太适合。 相比而言，Xtrabackup 的优势体现在： 备份、还原速度快，物理备份可靠 备份过程不会打断正在执行的事务（无需锁表） 能够基于压缩等功能节约磁盘空间和流量 支持流式处理，将备份传输到另外一台机器上 自动备份校验 Xtrabackup 安装完成后有 4 个可执行文件: xtrabackup: 是专门用来备份InnoDB表的，和mysql服务器没有交互； innobackupex: 是一个封装xtrabackup的Perl脚本，支持同时备份innodb和myisam，但在对myisam备份时需要加一个全局的读锁。 xbcrypt: 加密解密备份工具 xbstream: 流打包传输工具 全备恢复首先，准备一个数据库全备份： 1234567891011121314151617181920212223242526272829root@zhaobi:~# innobackupex --user=*** --password=*** ./mysql.backencryption: using gcrypt 1.6.5...180508 14:32:32 Connecting to MySQL server host: localhost, user: root, password: set, port: not set, socket: not setUsing server version 5.7.20-0ubuntu0.16.04.1...180508 14:32:33 &gt;&gt; log scanned up to (146069144514)xtrabackup: Generating a list of tablespacesInnoDB: Allocated tablespace ID 455 for parse/mtf_LTC_USDT, old maximum was 0180508 14:32:33 [01] Copying ./ibdata1 to /root/mysql.back/2018-05-08_14-32-32/ibdata1...180508 14:38:27 [01] ...done180508 14:38:27 Finished backing up non-InnoDB tables and files180508 14:38:27 Executing FLUSH NO_WRITE_TO_BINLOG ENGINE LOGS...xtrabackup: The latest check point (for incremental): '146066625808'xtrabackup: Stopping log copying thread..180508 14:38:27 &gt;&gt; log scanned up to (146071684987)180508 14:38:27 Executing UNLOCK TABLES180508 14:38:27 All tables unlocked180508 14:38:27 [00] Copying ib_buffer_pool to /root/mysql.back/2018-05-08_14-32-32/ib_buffer_pool180508 14:38:27 [00] ...done180508 14:38:27 Backup created in directory '/root/mysql.back/2018-05-08_14-32-32/'180508 14:38:27 [00] Writing /root/mysql.back/2018-05-08_14-32-32/backup-my.cnf180508 14:38:27 [00] ...done180508 14:38:27 [00] Writing /root/mysql.back/2018-05-08_14-32-32/xtrabackup_info180508 14:38:27 [00] ...donextrabackup: Transaction log of lsn (146061868327) to (146071684987) was copied.180508 14:38:27 completed OK! Xtrabackup 备份原理： 备份开始时首先会开启一个后台检测进程，实时检测 mysql redo log的变化，一旦发现有新的日志写入，立刻将日志记入后台日志文件 xtrabackup_log中，之后复制 InnoDB 的数据文件以及系统表空间文件ibdatax，复制结束后，将执行 flush tables with readlock ,然后复制 .frm .MYI .MYD 等文件，最后执行 unlock tables。 输出 completed OK! 信息代表备份成功。 看一下备份后的文件列表： 123456789101112root@zhaobi:~# ls -l mysql.back/2018-05-08_14-32-32/total 349608-rw-r----- 1 root root 487 May 8 14:38 backup-my.cnf-rw-r----- 1 root root 2362 May 8 14:38 ib_buffer_pool-rw-r----- 1 root root 348127232 May 8 14:32 ibdata1drwxr-x--- 2 root root 4096 May 8 14:38 mysqldrwxr-x--- 2 root root 4096 May 8 14:38 parsedrwxr-x--- 2 root root 4096 May 8 14:38 performance_schemadrwxr-x--- 2 root root 12288 May 8 14:38 sys-rw-r----- 1 root root 123 May 8 14:38 xtrabackup_checkpoints-rw-r----- 1 root root 445 May 8 14:38 xtrabackup_info-rw-r----- 1 root root 9819136 May 8 14:38 xtrabackup_logfile 然后，将备份好的数据拷贝到目标主机，准备进行恢复： 先关掉目标主机的 mysql 服务，准备一个全备份： 1$ innobackupex --apply-log /path/to/BACKUP-DIR 准备完成后，检查下最后输出到信息： 12150806 01:01:57 InnoDB: Shutdown completed; log sequence number 1609228150806 01:01:57 innobackupex: completed OK! 接着进行全备恢复： 1$ innobackupex --copy-back /path/to/BACKUP-DIR 增量备份优点： 数据库太大没有足够的空间全量备份，增量备份能有效节省空间，并且效率高； 支持热备份，备份过程不锁表（针对InnoDB而言），不阻塞数据库的读写； 每日备份只产生少量数据，也可采用远程备份，节省本地空间； 备份恢复基于文件操作，降低直接对数据库操作风险； 原理： 首先完成一个全备份，并记录下此时检查点LSN； 然后增量备份时，比较表空间中每个页的LSN是否大于上次备份的LSN，若是则备份该页并记录当前检查点的LSN。 增量备份需要用到两个参数： --incremental 告诉 innobackupex 进行增量备份 --incremental-basedir 指定增量备份的起始点，这里是之前备份过的某个目录 在全量备份基础上进行第一次增量备份： 12345root@zhaobi:~# innobackupex --user=** --password=*** --incremental --incremental-basedir=./mysql.back/2018-05-08_14-32-32/ ./mysql.inc1...180508 15:29:32 [00] ...donextrabackup: Transaction log of lsn (146084103197) to (146090143186) was copied.180508 15:29:32 completed OK! 对比两次备份的 xtrabackup_checkpoints 记录可以看到： backup_type 分别为 full-backuped，incremental 增量备份的 from_lsn 对应于上次全量备份的 to_lsn 1234567891011121314root@zhaobi:~# cat mysql.back/2018-05-08_14-32-32/xtrabackup_checkpointsbackup_type = full-backupedfrom_lsn = 0to_lsn = 146066625808last_lsn = 146071684987compact = 0recover_binlog_info = 0root@zhaobi:~# cat mysql.inc1/2018-05-08_15-24-35/xtrabackup_checkpointsbackup_type = incrementalfrom_lsn = 146066625808to_lsn = 146090143177last_lsn = 146090143186compact = 0recover_binlog_info = 0 在第一次增量备份基础上，进行第二次增量备份： 12345root@zhaobi:~# innobackupex --user=** --password=*** --incremental --incremental-basedir=./mysql.inc1/2018-05-08_15-24-35/ ./mysql.inc2...180508 15:41:50 [00] ...donextrabackup: Transaction log of lsn (146090145039) to (146094909487) was copied.180508 15:41:50 completed OK! 同理，第二次增量备份的 from_lsn 对应于第一次增量备份的 to_lsn： 1234567root@zhaobi:~# cat mysql.inc2/2018-05-08_15-36-58/xtrabackup_checkpointsbackup_type = incrementalfrom_lsn = 146090143177to_lsn = 146090145039last_lsn = 146094909487compact = 0recover_binlog_info = 0 增量恢复首先，准备一个全备份： 1innobackupex --apply-log --redo-only BASE-DIR 然后，依次将增量备份 append 到全备份，特别需要注意的是：最后一个增量备份不用 --redo-only 12innobackupex --apply-log --redo-only BASE-DIR --incremental-dir=INCREMENTAL-DIR-1innobackupex --apply-log BASE-DIR --incremental-dir=INCREMENTAL-DIR-2 确保每次操作最后都打出了日志信息： completed OK! 现在，所有的备份都整合到了 BASE-DIR，对合在一起的完全备份进行一次 apply 操作，回滚未提交的数据: 1innobackupex --apply-log BASE-DIR 最后，恢复所有备份： 1innobackupex --copy-back BASE-DIR 总结这篇文章简单记录并总结了使用 Xtrabackup 对 mysql 数据库进行 全量/增量备份并恢复的过程，希望能对初学者有所帮助。 很抱歉，就做了点微小的贡献。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>备份</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cgo 让 C 和 Go 手牵手]]></title>
    <url>%2F2018%2F01%2F11%2Fc-and-go%2F</url>
    <content type="text"><![CDATA[go 里面的 cgo 包可以直接调用 c 代码，只需要遵守一定的使用规则即可，对于那些熟悉 c/c++ 的开发者来说，不失为一个福音。 三个代表cgo 会从 go 代码中去寻找 c/c++ 代码，约定： 紧挨在 import &quot;C&quot; 上面的所有 c 风格的注释语句都可以被 go 编译。 1.所有代码都写在一个 go 文件中123456789101112131415161718//foo.gopackage main/*#include &lt;stdio.h&gt;int count = 6;void foo() &#123; printf("I am foo!\n");&#125;*/import "C"import "fmt"func main() &#123; fmt.Println(C.count) C.foo()&#125; 这是最简便的方式，适用于 c 代码逻辑比较简单的情况。 12345678hxzdeMac-mini:~ $ tree.├── foo.go0 directories, 1 fileshxzdeMac-mini:~ $ go build -o foohxzdeMac-mini:~ $ ./foo6I am foo! 2.c 代码和 go 代码写在独立文件1234567891011121314151617181920212223242526//foo.hextern int count;void foo();//foo.c#include &lt;stdio.h&gt;#include "foo.h"int count = 6;void foo() &#123; printf("I am foo!\n");&#125;//foo.gopackage main/*#include "foo.h"*/import "C"import "fmt"func main() &#123; fmt.Println(C.count) C.foo()&#125; 像这种直接编译 c 源码和 go 源码的方式，只需执行 go build，cgo 会在当前目录或 c 语言 -I 编译参数指定的目录寻找需要的.h,.c文件。 12345678910hxzdeMac-mini:~ $ tree.├── foo.c├── foo.go└── foo.h0 directories, 3 fileshxzdeMac-mini:~ $ go build -o foohxzdeMac-mini:~ $ ./foo6I am foo! 3.go 代码调用动态链接库如果只提供了 c 的动态链接库和头文件，那么需要在 go 文件中指定 cgo 的 CFLAGS, CPPFLAGS, CXXFLAGS, LDFLAGS 等编译选项： 123456789101112131415161718//foo.hextern int count;void foo();//foo.gopackage main/*#cgo LDFLAGS: -L./ -lfoo#include "foo.h"*/import "C"import "fmt“func main() &#123; fmt.Println(C.count) C.foo()&#125; 1234567891011hxzdeMac-mini:~ $ tree.├── foo.go├── foo.h└── libfoo.dylib0 directories, 3 fileshxzdeMac-mini:~ $ go build -o foohxzdeMac-mini:~ $ ./foo6I am foo! go 引用 cC 里面的标准类型可以在 go 里面直接引用： 12345678910C.char, C.schar (signed char), C.uchar (unsigned char)C.short, C.ushort (unsigned short), C.int, C.uint (unsigned int), C.long, C.ulong (unsigned long), C.longlong (long long), C.ulonglong (unsigned long long), C.float, C.double, C.complexfloat (complex float), C.complexdouble (complex double).void* == unsafe.Pointer__int128_t and __uint128_t == [16]byte 引用 struct，union，enum： 123C.struct_Foo == struct FooC.union_Foo == union FooC.enum_Foo == enum Foo Go 里面的 struct 不能包含 C 类型。 sizeof：1C.sizeof_struct_Foo == sizeof(struct Foo) c 中结构体字段如果是 go 里面的关键字，那么可以在该结构体字段名前面加个 _ 来引用，比如： 1234567typedef struct Foo &#123; int val; int type;&#125;Foo;foo := C.Foo&#123;2,4&#125;fmt.Println(foo.val, foo._type) // 2 4 Cgo 将 C 类型转译成对应的 go 类型是不可导出的，因此，go 包导出的 API 里面不能含有 C 类型。 C 里面的函数执行结果可以赋给 go 里面的多返回值（执行结果和可能产生的错误值），即使是没有返回值的 void 类型函数。 12n, err = C.sqrt(-1)_, err := C.voidFunc() cgo 目前还不支持直接调用 C 里面的函数指针，你可以声明一个包含 C 函数指针的 go 变量（如下的 f），这样就可以在 go 和 C 之间传递了。 1234567891011121314151617181920212223package main/*typedef int (*intFunc) ();int bridge_int_func(intFunc f) &#123; return f();&#125;int fortytwo()&#123; return 42;&#125;*/import "C"import "fmt"func main() &#123; f := C.intFunc(C.fortytwo) fmt.Println(int(C.bridge_int_func(f))) // Output: 42 fmt.Println(int(C.bridge_int_func(C.fortytwo))) // error // cannot use _Cgo_ptr(_Cfpvar_fp_fortytwo) (type unsafe.Pointer) as type *[0]byte in argument to _Cfunc_bridge_int_func&#125; 在 C 里面， 如果一个函数接受一个数组参数，只需要传递数组名即可，但在 go 里面不行，你必须显示指定数组首元素的地址： 12345void f(int[] arr) &#123;&#125;f(arr); // CC.f(&amp;C.arr[0]) // go 下面是几组 c 和 go 之间拷贝数据的语法： 1234567891011// Go string to C string; result must be freed with C.freefunc C.CString(string) *C.char// C string to Go stringfunc C.GoString(*C.char) string// C string, length to Go stringfunc C.GoStringN(*C.char, C.int) string// C pointer, length to Go []bytefunc C.GoBytes(unsafe.Pointer, C.int) []byte c 引用 go 使用 //export &lt;function-name&gt; 导出 Go 代码 在 C 代码里面使用 extern 关键字引用 go 代码 12345678910111213141516171819202122package main/*extern void myprint(int i);void dofoo(void) &#123; int i; for (i=0;i&lt;10;i++) &#123; myprint(i); &#125;&#125;*/import "C"//export myprintfunc myprint(i C.int) &#123; fmt.Printf("i = %v\n", uint32(i))&#125;func main() &#123; C.dofoo()&#125; 传递指针go 是一门垃圾回收语言，垃圾回收器需要知道每个指针所指向的内存位置，正因为如此，在 go 和 c 之间传递指针有些许限制。 go 指针：使用 &amp; 操作符或 new 函数返回的指针 c 指针： 使用 C.malloc 返回的指针 首先，我们需要明白： 将指针传递给 struct 某个字段时，所涉及的 Go 内存是该字段占用的内存，而不是整个结构体占有的内存；将指针传递给数组或切片中的元素时，所涉及的 Go 内存是整个数组或整个切片的底层数组。 go 代码可以传递 go 指针给 c, 前提是这个指针指向的内存不包含任何 go 指针。c 代码必须保留这个属性： 它不能在 go 内存中存储任何 go 指针（即使是临时变量也不行）。 C 代码调用的 Go 函数可能会将 C 指针作为参数，并且可能通过这些指针存储非指针或 C 指针数据，但是它可能不会将 Go 指针存储在由C 指针指向的内存中；C 代码调用的 Go 函数可能会将 Go 指针作为参数，但它必须保留“指向的 Go 内存不包含任何 Go 指针”的属性。 Go 代码可能不会在 C 内存中存储 Go 指针，C 代码可能会在 C 内存中存储 Go 指针，这取决于上面的规则：当 C 函数返回时，它必须停止存储 Go 指针。 References https://blog.golang.org/c-go-cgo https://golang.org/cmd/cgo/]]></content>
      <categories>
        <category>Coder</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>cgo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「黄泽瑄的成长记」第六季来啦]]></title>
    <url>%2F2017%2F12%2F16%2FHuang-Zexuan-6%2F</url>
    <content type="text"><![CDATA[我家瑄宝越来越可爱啦 除了吃饭睡觉 整天都在各种玩 精力超级充沛 最喜欢爷爷奶奶一起陪着玩 也越来越粘爷爷啦 特别喜欢爷爷带出去溜弯 爷爷上班的时候 瑄宝跟着奶奶会乖乖地吃饭 乖乖地喝牛奶 超级棒滴哦 瑄宝是个活泼可爱的万人迷 最喜欢听小苹果 边听边跟着节拍手舞足蹈 喜欢玩摇摇车 都快成摇摇车老司机啦 一周岁后剃了个光头 宝妈说 以后再不能剃光头了啦 但在宝爸看来 瑄瑄即使剃光头 也是国色天香级美女 不信？请看…… 亲亲我的宝贝 爸爸妈妈爱你哟]]></content>
      <categories>
        <category>黄泽瑄</category>
      </categories>
      <tags>
        <tag>女儿</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go 迷思之 Named 和 Unnamed Types]]></title>
    <url>%2F2017%2F11%2F27%2Fgo-Named-and-Unnamed-Types%2F</url>
    <content type="text"><![CDATA[先来热身一下，下面的代码能编译吗？为什么？ 1234567891011package maintype stack []uintptrfunc callers() stack &#123; return make([]uintptr, 20)&#125;func main() &#123; callers()&#125; (此处省略一分钟冥思苦想状….) 好啦，不用多想了，当然可以编译。 但是……这个问题重要吗？ 是的，很重要。 如果上面这份代码不能编译，那意味着你无法写这样的代码： 12type stack []uintptrvar st stack = make([]uintptr, 20) 而我们知道，这样的代码几乎无处不在。 再来，下面的代码能通过编译吗？ 12345678type T intfunc F(t T) &#123;&#125;func main() &#123; var q int F(q)&#125; 结合你平时写的代码，再思考一分钟…… Ops, it couldn’t。 稍微改动如下，它能通过编译吗？ 12345678type T []intfunc F(t T) &#123;&#125;func main() &#123; var q []int F(q)&#125; Yes, it does. Surprised?! How could this happen？ Read The Fxxking Manual言归正传，先来看下这又臭又长的 《Go 规范手册》 是怎么解释 Types 的。 A type determines a set of values together with operations and methods specific to those values. A type may be denoted by a type name, if it has one, or specified using a type literal, which composes a type from existing types. Named instances of the boolean, numeric, and string types are predeclared. Other named types are introduced with type declarations. Composite types—array, struct, pointer, function, interface, slice, map, and channel types—may be constructed using type literals. Each type T has an underlying type: If T is one of the predeclared boolean, numeric, or string types, or a type literal, the corresponding underlying type is T itself. Otherwise, T’s underlying type is the underlying type of the type to which T refers in its type declaration. Named vs Unnamed TypeNamed types 有两类： 内置的类型，比如 int, int64, float, string, bool， 用 type 关键字声明的类型，比如 type Foo string Unamed types：基于已有的 named types 声明出的组合类型，uname types 在 Go 里俯拾皆是。比如 struct{}、[]string、interface{}、map[string]bool、[20]float32…… Named types 可以作为方法的接受者， unnamed type 却不能。比如： 1234567891011type Map map[string]string// okfunc (m Map) Set(key string, value string)&#123; m[key] = value &#125;// invalid receiver type map[string]string (map[string]string is an unnamed type)func (m map[string]string) Set(key string, value string)&#123; m[key] = value &#125; Underlying Type每种类型 T 都有一个底层类型：如果 T 是预声明类型或者 类型字面量(笔者注：type literal 翻译成类型字面量，地道不？) ，它的底层类型就是 T 本身，否则，T 的底层类型是其类型声明中引用的类型的底层类型。 123456type ( B1 string B2 B1 B3 []B1 B4 B3 ) string, B1 和 B2 的底层类型是 string. B2 引用了 B1，那么 B2 的底层类型其实是 B1 的底层类型，而 B1 又引用了 string，那么 B1 的底层类型其实是 string 的底层类型，很明显，string 的底层类型就是string，最终 B2 的底层类型是 string。 []B1, B3, 和 B4 的底层类型是 []B1. []B1 是类型字面量，因此它的底层类型就是它本身。 所有基于相同 unnamed types 声明的变量的类型都相同，而对于 named types 变量而言，即使它们的底层类型相同，它们也是不同类型。 12345678910111213// x 是 unnamed typesvar x struct&#123; I int &#125;// x 和 x2 类型相同var x2 struct&#123; I int &#125;// y 是 named typetype Foo struct&#123; I int &#125;var y Foo// y 和 z 类型不同type Bar struct&#123; I int &#125;var z Bar Assignability不同类型的变量之间是不能赋值的。 1234type MyInt intvar i int = 2var i2 MyInt = 4i = i2 // error: cannot use i2 (type MyInt) as type int in assignment 你不能把 i2 赋值给 i，因为它们的类型不同，虽然它们的底层类型都是 int。 对于那些拥有相同底层类型的变量而言，还需要理解另外一个重要概念：可赋值性。在 Assignability 的六大准则中，其中有一条： x’s type V and T have identical underlying types and at least one of V or T is not a defined type. 也就是说底层类型相同的两个变量可以赋值的条件是：至少有一个不是 named type。 1234x = y // oky = x // okx = x2 // oky = z // error: cannot use y (type Foo) as type Bar in assignment 现在，你知道“为什么开头那两份代码为什么一个能编译另一个不能”了吧。 Type Embedding当你使用 type 声明了一个新类型，它不会继承原有类型的方法集。 1234567891011121314151617package maintype User struct &#123; Name string&#125;func (u *User) SetName(name string) &#123; u.Name = name&#125;type Employee User func main()&#123; employee := new(Employee) employee.SetName("Jack"). // error employee.SetName undefined (type *Employee has no field or method SetName)&#125; 作为一个小技巧，你可以将原有类型作为一个匿名字段内嵌到 struct 当中来继承它的方法，这样的 struct 在 Go 代码中太常见不过了。 比如： 12345678910111213141516171819package maintype User struct &#123; Name string&#125;func (u *User) SetName(name string) &#123; u.Name = name&#125;type Employee struct &#123; User // annonymous field Title string&#125;func main()&#123; employee := new(Employee) employee.SetName("Jack")&#125; Last But Not LeastGo 里面关于类型 Types 的一些规定有时候让初学者丈二和尚摸不着头脑，而 Types 几乎是任何一门编程语言的基石，如果你不能理解 Go 里面最基本的概念之一：Types，相信我，你将不可能在这门语言上走远。]]></content>
      <categories>
        <category>Coder</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>Named Types</tag>
        <tag>Unnamed Types</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go 语言从入门到放弃之 range]]></title>
    <url>%2F2017%2F10%2F29%2Fgo-range-quiz%2F</url>
    <content type="text"><![CDATA[《Go Range 内部实现》 这篇译文对于 Go 开发者来说，很值得一读。 对比老外的原文和作者的翻译，可以学到些许关于 for...range 语法的奥妙。尤其是对于 Go 初学者来说，可以避免少踩几次关于 range 的「坑」。 缘起老外在 twitter 上图这个 Go 语言小测试，初看此题，直觉上你可能会认为这个 for 循环会无休止地执行下去，因为每次都往切片尾部新增了一个元素，导致切片无法遍历结束。蛤蛤，这是典型的一知半解式解答。不过，即便你能猜到该程序能正常结束并且 v 最终为 [1 2 3 0 1 2]，你也未必能讲明白 Why。 剖析在 《Go 规范文档》 「For statements with range clause」 一节可以找到关于 for...range 语法的相关说明。 123for v := range a &#123; fmt.Println(v)&#125; 我不想大段大段地摘抄原文，你需要知道的一个关键点是： 循环变量（v）在每一次迭代中都被 赋值 且 复用。 range 右边（上例 a）的表达式（或表达式展开后的结果），可以是这些数据类型： 数组(或指向数组的指针） 切片 字符串 map 可以接收传输的 channel, 比如：chan int 或 chan&lt;- int 在 Go 里，所有的赋值都是 值拷贝。如果赋值了一个指针，那我们就复制了一个指针副本。如果赋值了一个结构体，那我们就复制了一个结构体的副本。 那么， 对于不同类型 a，range a 返回的结果是什么呢？ 类型 a range a 赋值结果 array 一个新数组：拷贝原始数组到新数组 slice 一个结构体：拥有一个变量 len 、一个变量 cap 和一个指针指向原有 slice 背后的数组 string 一个结构体：拥有一个变量 len 和一个指针指向原有 string 背后的字符数组 map 一个指针：指向原有 map 底层结构体（哈希表） channel 一个指针：指向原有 channel 原文作者还去瞅了瞅 Go 里面 for...range 一个 slice 编译的源码: 12345678// for_temp := range// len_temp := len(for_temp)// for index_temp = 0; index_temp &lt; len_temp; index_temp++ &#123;// value_temp = for_temp[index_temp]// index = index_temp// value = value_temp// original body// &#125; 回到这个测试题； 123456func main() &#123; v := []int&#123;1, 2, 3&#125; for i := range v &#123; v = append(v, i) &#125;&#125; 这段代码之所以会结束是因为它其实可以粗略的翻译成类似下面的这段： 12345678for_temp := vlen_temp := len(for_temp)for index_temp = 0; index_temp &lt; len_temp; index_temp++ &#123; value_temp = for_temp[index_temp] index = index_temp value = value_temp v = append(v, index)&#125; 在循环开始前对这个 slice 生成副本赋值给 for_temp，后面的循环实际上是在对 for_temp([1 2 3]) 而非原始变量 v 进行迭代。 再深一点前面列出了不同类型 a 经过 range a 赋值后的结果，有两个地方需要注意； 对数组赋值都会拷贝到一个新的数组，若要更改原始数组，可通过引用原数组下标的方式修改， 如 a[i] = val。 在 range 循环里对 map 做添加或删除元素的操作是安全的，添加的元素 不一定 会出现在后续的迭代中。 为什么在 map 后续的迭代中不一定能遍历到当前添加的元素？ 译文这样解释道： 如果你知道哈希表是如何工作的（map 本质上就是哈希表），就会明白哈希表内部数组里的元素并不是以特定顺序存放。最后一个添加的元素有可能经过哈希后被放到了内部数组里的第一个索引位，我们确实没有办法预测当前添加的元素是否会出现在后续的迭代中，毕竟在添加元素的时候很可能已经遍历过了第一个索引位。因此，当前添加的元素是否能在后续迭代中遍历到，还是看编译器的心情吧。 举个栗子： 12345678910111213141516func main() &#123; data := make(map[string]int) data["one"] = 1 data["two"] = 2 data["three"] = 3 for k, v := range data &#123; fmt.Println(k, v) if v == 1 &#123; data["four"] = 4 delete(data, "three") &#125; &#125; fmt.Println(data)&#125; 下面是几次运行结果： 12345678910111213one 1two 2map[two:2 four:4 one:1]three 3one 1two 2map[one:1 two:2 four:4]one 1two 2four 4map[one:1 two:2 four:4] 我们在遍历时即插入也删除了元素，最终都为 map[one:1 two:2 four:4]，但可以看到，对 map 元素的遍历是无序的，遍历时插入的元素也不一定出现在后续遍历中。 另一面前面说了： 循环变量（v）在每一次迭代中都被 赋值 且 复用。 赋值讲得差不多了，还有复用呢？ 这也是初学者易踩的一个大坑。在 《Go的50度灰：Golang新开发者要注意的陷阱和常见错误》 一文中，作者给了很大的篇幅详解「for 循环变量在每次迭代中会被复用」这一特性。这个特性意味着你在 for 循环中创建的闭包（即函数字面量）将会引用同一个变量（而在那些 goroutine 开始执行时就会得到那个变量的值）。 在 for 循环中开启 go routine 尤其需要注意「复用」这个特性，由于 go 一个协程出来，go 运行环境会为这个协程分配一个协程栈来存放函数参数、闭包引用的外部变量等。 比如下面这个例子： 1234567891011121314151617package mainimport ( "fmt" "time")func main() &#123; data := []string&#123;"one","two","three"&#125; for _,v := range data &#123; go func() &#123; fmt.Println(v) &#125;() &#125; time.Sleep(3 * time.Second) // 协程栈里的 v 是 for 语句里面 v 的副本, 而后者每次迭代都复用 // 3 个协程几乎都要等待 cpu 调度到这里才开始运行，此时协程栈里的 v 都是 「three」 // 因此输出: three, three, three&#125; 解决方法，众所周知的有两种： 1.不需要修改 goroutine，在 for 循环代码块内把当前迭代的变量值保存到一个局部变量中。 123456for _,v := range data &#123; vcopy := v go func() &#123; fmt.Println(vcopy) &#125;()&#125; 2.把当前的迭代变量作为 goroutine 的参数。 12345for _,v := range data &#123; go func(in string) &#123; fmt.Println(in) &#125;(v)&#125; 来看看这个稍微复杂一点的例子： 12345678910111213141516171819202122package mainimport ( "fmt" "time")type field struct &#123; name string&#125;func (p *field) print() &#123; fmt.Println(p.name)&#125;func main() &#123; data := []*field&#123; &#123;"one"&#125;,&#123;"two"&#125;,&#123;"three"&#125; &#125; // data for _,v := range data &#123; go v.print() &#125; time.Sleep(3 * time.Second)&#125; 相信你已经知道，如果 //data 这行改为 data := []field{ {&quot;one&quot;},{&quot;two&quot;},{&quot;three&quot;} }，毫无疑问三个协程输出都是 &quot;three&quot;，但这个例子，切片元素 filed 用指针修饰，输出将会如何呢？ 答案是输出: &quot;one&quot;,&quot;two&quot;,&quot;three&quot;。 data := []*field{ {&quot;one&quot;},{&quot;two&quot;},{&quot;three&quot;} } 中，for 循环的 v 是指针，print 这个方法接收的是指针的拷贝，协程栈里保存的 v 指针值都是不同的，所以每次输出不同。 因此，有第三种 fix 办法：将切片元素用指针修饰，同样可以达到 goroutine 引用到每个元素的目的。 总结其实，不管哪一门语言，即使是所谓的大神，一不小心在某些语法细节上栽跟头也是司空见惯。至于为什么会掉「坑」，无外乎这「三个代表」： 理解的得根本就不对，南辕北辙； 认知不够彻底，只知其一不知其二； 先入为主，把其他语言的思维惯用在这门语言之上。 到这里，希望你的脑中有了一副清晰的图像描绘 for...range在底层是如何运作的，以后别再掉进那些「坑」里。]]></content>
      <categories>
        <category>Coder</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>range</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「黄泽瑄的成长记」第五季来啦]]></title>
    <url>%2F2017%2F09%2F10%2FHuang-Zexuan-5%2F</url>
    <content type="text"><![CDATA[这一季主要是记录了瑄宝 8-10个月这段时间的生活点滴 我家瑄宝是个活泼可爱的小娃娃 爱笑爱闹爱玩耍 这期妈妈离开瑄宝到爸爸那上班去啦 宝宝以前从不认生 谁抱都开心 妈妈走后好像意识到什么 变得只要奶奶抱 生怕一个没注意奶奶也不见啦呢 从此变成啦一个粘乎乎到宝宝咯 奶奶是唯一的安全感 还是喜欢到外面玩 但家里面只要有小伙伴的话也能一天不出门 见到邻居会热情打招呼 人家走了会摇摆手给拜拜 会喊妈妈和爷爷啦 奶奶做家务的时候也会乖乖跟爷爷玩 瑄宝是个乖宝宝 爸爸妈妈爱你哟]]></content>
      <categories>
        <category>黄泽瑄</category>
      </categories>
      <tags>
        <tag>女儿</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「黄泽瑄的成长记」第四季来啦]]></title>
    <url>%2F2017%2F07%2F31%2FHuang-Zexuan-4%2F</url>
    <content type="text"><![CDATA[这一季主要是记录了我家瑄宝 6-7个月这段时间的生活点滴 本季集锦片段： 镜头感超级棒的瑄宝 小猪猪是瑄宝的好伙伴～ 小小年纪就会弹奏《图森破》，哈哈～ 这位美女，你的玉足很香吗？蛤蛤～ 冷不丁地逗你一下～]]></content>
      <categories>
        <category>黄泽瑄</category>
      </categories>
      <tags>
        <tag>女儿</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「黄泽瑄的成长记」第三季来啦]]></title>
    <url>%2F2017%2F07%2F23%2FHuang-Zexuan-3%2F</url>
    <content type="text"><![CDATA[这一季主要是记录了我家瑄宝 4-5个月这段时间的生活点滴 本期视频集锦： 可神气哦～ 吃小手手～ 和爷爷谈笑风生～ 身子骨还嫩 坐不起来 好烦哦～ 古灵精怪的小眼神～ 洗完澡澡 抖抖小长腿～ 蛤蛤蛤～]]></content>
      <categories>
        <category>黄泽瑄</category>
      </categories>
      <tags>
        <tag>女儿</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「黄泽瑄的成长记」第二季来啦]]></title>
    <url>%2F2017%2F05%2F13%2FHuang-Zexuan-2%2F</url>
    <content type="text"><![CDATA[瑄宝的纪录片视频第一季距今 都已经4个多月了 本来打算过年后就发第二季的 结果小明一不小心 沉迷于《王者农药》不可自拔 第二季拖延到现在才做完 这一季主要是记录了黄泽瑄 2个月到3个月这段的生活点滴 咳咳～ 那会宝宝住院了 天天打吊水 头顶上扎了那么多针 心疼啊 还好我们家瑄宝是一个坚强的女子 勇敢地面对抽血、打针 很少看到她大哭大闹 还会做鬼脸逗我们笑～]]></content>
      <categories>
        <category>黄泽瑄</category>
      </categories>
      <tags>
        <tag>女儿</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go 之初体验]]></title>
    <url>%2F2017%2F05%2F11%2Fgo-tutorial%2F</url>
    <content type="text"><![CDATA[小明最近新入职了一家研究区块链技术的 复杂美科技有限公司，岗位职责是用 Go 语言做区块链底层开发。 Go 之前都没接触过，现学现卖咯～这几天上班，小明启动了 3 条工作线程： 熟悉公司的产品 消化这份 《区块链技术指南》 学习 Go 语言 在此，总结下初步学习 Go 语言的一些心得。 考虑到公众号粉丝群众的职业分布，小明温馨提示： 为避免文章内容专业性太强，引起部分用户生理不适，非计算机从业者请直接拉到最下赞赏通道 ^_^ …… 由来在接触 Go 以前，我用 C/C++、Python 作为后台的主要开发语言。 C/C++ 的问题： 开发效率低，对开发者要求高 Python 的问题： 动态语言，缺少编译过程，低级错误频出 性能差，不适合做高性能服务 我对 Go 的初体验： 有 C/Python 基础，学 Go 非常轻松 代码简洁，格式统一，阅读方便 天生支持高并发 略逊于 C/C++ 的高性能 + Python 的高开发效率 部署极其方便，不依赖其它库 格式化格式化问题总是充满了争议，但却始终没有形成统一的定论 缩进用空格还是制表符 Tab？ 大括号 { 要不要另起一行？ 代码结尾需不需要以分号;结尾？ 虽说人们可以适应不同的编码风格， 但抛弃这种适应过程岂不更好？若所有人都遵循相同的编码风格，在这类问题上浪费的时间将会更少。 问题就在于如何实现这种设想，而无需冗长的语言风格规范。在 Go 中我们另辟蹊径，让机器来处理大部分的格式化问题。 举例来说，你无需花时间将结构体中的字段注释对齐，gofmt 将为你代劳。 假如 teso.go 有以下声明： 1234type T struct &#123; name string // 对象名 value int // 对象值&#125; 运行 gofmt test.go，它将按列对齐为： 1234type T struct &#123; name string // 对象名 value int // 对象值&#125; 发明 go 语言的那帮老爷们简单粗暴终结了这三大影响程序员群体团结的争论： 缩进用 Tab 大括号 { 不要另起一行 代码结尾不要分号; 包每个 Go 程序都是由包组成的。 Go 源文件中的第一个语句必须是 1package 名称 如果是可执行程序，第一行必须是 1package main 程序运行的入口是函数 main。 12345678910package mainimport ( "fmt" "math/rand")func main() &#123; fmt.Println("My favorite number is", rand.Intn(10))&#125; 这个程序使用并导入了包 &quot;fmt&quot; 和 &quot;math/rand&quot;。 按照惯例，包名与导入路径的最后一个目录一致。例如，&quot;math/rand&quot; 包由 package rand 语句开始。 导入1234import ( "fmt" "math") 这个代码用圆括号组合了导入，这是打包导入语句。 同样可以编写多个导入语句，例如： 12import "fmt"import "math" 不过使用打包的导入语句是更好的形式。 函数函数可以没有参数或接受多个参数。 123func add(x int, y int) int &#123; return x + y&#125; add 接受两个 int 类型的参数。 类型在变量名 之后。(参考 这篇关于 Go 语法定义的文章了解类型以这种形式出现的原因。) 当两个或多个连续的函数命名参数是同一类型，则除了最后一个类型之外，其他都可以省略。 上面这个例子中， x int, y int 可以被缩写为： x, y int 多值返回函数可以返回任意数量的返回值。 123func swap(x, y string) (string, string) &#123; return y, x&#125; swap 函数返回了两个字符串。 命名返回值Go 的返回值可以被命名，并且像变量那样使用。 12345func split(sum int) (x, y int) &#123; x = sum * 4 / 9 y = sum - x return&#125; 返回值的名称应当具有一定的意义，可以作为文档使用。 没有参数的 return 语句返回结果的当前值。也就是直接返回。 变量var 语句定义了一个变量的列表，跟函数的参数列表一样，类型在后面。 12345678910package mainimport "fmt"var c, python, java boolfunc main() &#123; var i int fmt.Println(i, c, python, java)&#125; 就像在这个例子中看到的一样，var 语句可以定义在包或函数级别。 初始化变量变量定义可以包含初始值，每个变量对应一个。 如果初始化是使用表达式，则可以省略类型；变量从初始值中获得类型。 12345678910package mainimport "fmt"var i, j int = 1, 2func main() &#123; var c, python, java = true, false, "no!" fmt.Println(i, j, c, python, java)&#125; 短声明变量在函数中，:=简洁赋值语句在明确类型的地方，可以用于替代 var 定义。 函数外的每个语句都必须以关键字开始（var、func等） := 结构不能使用在函数外。 1234567func main() &#123; var i, j int = 1, 2 k := 3 c, python, java := true, false, "no!" fmt.Println(i, j, k, c, python, java)&#125; 基本类型123456789101112131415boolstringint int8 int16 int32 int64uint uint8 uint16 uint32 uint64 uintptrbyte // uint8 的别名rune // int32 的别名 // 代表一个Unicode码float32 float64complex64 complex128 零值变量在定义时没有明确的初始化时会赋值为零值。 数值类型为 0 布尔类型为 false 字符串为 &quot;&quot;（空字符串） 类型转换表达式 T(v) 将值 v 转换为类型 T。 一些关于数值的转换： 123var i int = 42var f float64 = float64(i)var u uint = uint(f) 或者，更加简单的形式： 123i := 42f := float64(i)u := uint(f) 与 C 不同的是 Go 在不同类型之间的项目赋值时需要显式转换。 类型推导在定义一个变量但不指定其类型时（使用没有类型的 var 或 := 语句）， 变量的类型由右值推导得出。 当右值定义了类型时，新变量的类型与其相同： 12var i intj := i // j 也是一个 int 但是当右边包含了未指名类型的数字常量时，新的变量就可能是 int 、float64 或 complex128，这取决于常量的精度： 123i := 42 // intf := 3.142 // float64g := 0.867 + 0.5i // complex128 常量常量的定义与变量类似，只不过使用 const 关键字。 常量可以是字符、字符串、布尔或数字类型的值。 常量不能使用 := 语法定义。 123const Pi = 3.14const World = "世界"const Truth = true 数值常量数值常量是高精度的值。 一个未指定类型的常量由上下文来决定其类型。 1234567891011121314151617181920package mainimport "fmt"const ( Big = 1 &lt;&lt; 100 Small = Big &gt;&gt; 99)func needInt(x int) int &#123; return x*10 + 1 &#125;func needFloat(x float64) float64 &#123; return x * 0.1&#125;func main() &#123; fmt.Println(needInt(Small)) //fmt.Println(needInt(Big)) // error: overflows int fmt.Println(needFloat(Small)) fmt.Println(needFloat(Big))&#125; 控制结构forGo 只有一种循环结构: for 循环。 基本的 for 循环除了没有了 ( ) 之外（甚至强制不能使用它们），看起来跟 C 或者 Java 中做的一样，而 { } 是必须的。 1234sum := 0for i := 0; i &lt; 10; i++ &#123; sum += i&#125; 跟 C 或者 Java 中一样，可以让前置、后置语句为空。 1234sum := 1for sum &lt; 1000 &#123; sum += sum&#125; 死循环如果省略了循环条件，循环就不会结束，因此可以用更简洁地形式表达死循环。 12for &#123;&#125; if &amp; elseif 语句除了没有了 ( ) 之外（甚至强制不能使用它们），看起来跟 C 或者 Java 中的一样，而 { } 是必须的。（耳熟吗？） 跟 for 一样，if 语句可以在条件之前执行一个简单的语句。 由这个语句定义的变量的作用域仅在 if 范围之内。在 if 的便捷语句定义的变量同样可以在任何对应的 else 块中使用。 123456789func pow(x, n, lim float64) float64 &#123; if v := math.Pow(x, n); v &lt; lim &#123; return v &#125; else &#123; fmt.Printf("%g &gt;= %g\n", v, lim) &#125; // 这里开始就不能使用 v 了 return lim&#125; switchswitch 的条件从上到下的执行，当匹配成功的时候停止。 1234switch i &#123; case 0: case f():&#125; 当 i==0 时不会调用 f。 没有条件的 switch 同 switch true 一样。 这一构造使得可以用更清晰的形式来编写长的 if-then-else 链。 12345678switch &#123; case t.Hour() &lt; 12: fmt.Println("Good morning!") case t.Hour() &lt; 17: fmt.Println("Good afternoon.") default: fmt.Println("Good evening.")&#125; deferdefer 语句会延迟函数的执行直到上层函数返回。 延迟调用的参数会立刻生成，但是在上层函数返回前函数都不会被调用。 延迟的函数调用被压入一个栈中。当函数返回时， 会按照 后进先出 的顺序调用被延迟的函数调用。 12345678910package mainimport "fmt"func main() &#123; defer fmt.Println("hxz") defer fmt.Println("world") fmt.Println("hello")&#125; 输出： 123helloworldhxz 阅读 博文 了解更多关于 defer 语句的信息。 指针Go 具有指针。 指针保存了变量的内存地址。 类型 *T 是指向类型 T 的值的指针。其零值是 nil。 &amp; 符号会生成一个指向其作用对象的指针。 12i := 42p = &amp;i * 符号表示指针指向的底层的值。 12fmt.Println(*p) // 通过指针 p 读取 i*p = 21 // 通过指针 p 设置 i 与 C 不同，Go 没有指针运算。 结构体一个结构体（struct）就是一个字段的集合。 结构体文法表示通过结构体字段的值作为列表来新分配一个结构体。 使用 Name: 语法可以仅列出部分字段。（字段名的顺序无关。） 特殊的前缀 &amp; 返回一个指向结构体的指针。 123456789101112131415161718package mainimport "fmt"type Vertex struct &#123; X, Y int&#125;var ( v1 = Vertex&#123;1, 2&#125; // 类型为 Vertex v2 = Vertex&#123;X: 1&#125; // Y:0 被省略 v3 = Vertex&#123;&#125; // X:0 和 Y:0 p = &amp;Vertex&#123;1, 2&#125; // 类型为 *Vertex)func main() &#123; fmt.Println(v1, p, v2, v3) //&#123;1 2&#125; &amp;&#123;1 2&#125; &#123;1 0&#125; &#123;0 0&#125;&#125; new 返回类型为 T 的指针 不会初始化内存，只会将内存置零 make 返回类型为 T 的值，不返回指针 内存已初始化 （而非置零） 它只用于创建切片、映射和信道 数组类型 [n]T 是一个有 n 个类型为 T 的值的数组。 表达式 var a [10]int定义变量 a 是一个有十个整数的数组。 数组的长度是其类型的一部分，因此数组不能改变大小。 数组在Go和C中的主要区别。在Go中: 数组是值。将一个数组赋予另一个数组会复制其所有元素。 若将数组传入某个函数，它将接收到该数组的一份副本而非指针。 数组的大小是其类型的一部分。类型 [10]int 和 [20]int 是不同的。 slice除了矩阵变换这类需要明确维度的情况外，Go中的大部分数组编程都是通过切片来完成的。 切片保存了对底层数组的引用，若你将某个切片赋予另一个切片，它们会引用同一个数组。 若将切片传入某个函数，它将接收到该切片的一份指针。 一个 slice 会指向一个序列的值，并且包含了长度信息。 []T 是一个元素类型为 T 的 slice。 slice 的零值是 nil。 一个 nil 的 slice 的长度和容量是 0。 切片sliceslice 可以重新切片，创建一个新的 slice 值指向相同的数组。 s[lo:hi]:从 lo 到 hi-1 的 slice 元素，含两端。 s[lo:lo]是空的，而s[lo:lo+1]有一个元素。 构造 sliceslice 由函数 make 创建： 1a := make([]int, 5) // len(a)=5 为了指定容量，可传递第三个参数到 make： 12345678910111213141516171819package mainimport "fmt"func main() &#123; a := make([]int, 5) printSlice("a", a) //a len=5 cap=5 [0 0 0 0 0] b := make([]int, 0, 5) printSlice("b", b) //b len=0 cap=5 [] c := b[:2] printSlice("c", c) //c len=2 cap=5 [0 0] d := c[2:5] printSlice("d", d) //d len=3 cap=3 [0 0 0]&#125;func printSlice(s string, x []int) &#123; fmt.Printf("%s len=%d cap=%d %v\n", s, len(x), cap(x), x)&#125; 向 slice 添加元素1func append(s []T, vs ...T) []T 第一个参数 s 是一个类型为 T 的数组，其余类型为 T 的值将会添加到 slice。 append 的结果是一个包含原 slice 所有元素加上新添加的元素的 slice。 如果 s 的底层数组太小，而不能容纳所有值时，会分配一个更大的数组。 返回的 slice 会指向这个新分配的数组。 了解更多关于 slice 的内容，参阅文章 slice：使用和内幕。 rangefor 循环的 range 格式可以对 slice 或者 map 进行迭代循环。 可以通过赋值给 _ 来忽略序号或 值。如果只需要索引值，去掉, value 的部分即可。 12345678910111213package mainimport "fmt"func main() &#123; pow := make([]int, 10) for i := range pow &#123; pow[i] = 1 &lt;&lt; uint(i) &#125; for _, value := range pow &#123; fmt.Printf("%d\n", value) &#125;&#125; mapmap 映射键到值。 map 在使用之前必须用 make 而不是 new 来创建；值为 nil 的 map 是空的，并且不能赋值。 12345678type Vertex struct &#123; Lat, Long float64&#125;m = make(map[string]Vertex)m["Bell Labs"] = Vertex&#123; 40.68433, -74.39967,&#125; 在 map m 中插入或修改一个元素： 1m[key] = elem 获得元素： 1elem = m[key] 删除元素： 1delete(m, key) 通过 双赋值 检测某个键存在： 1elem, ok = m[key] 如果 key 在 m 中，ok 为 true 。否则， ok 为 false，并且 elem 是 map 的元素类型的零值。 同样的，当从 map 中读取某个不存在的键时，结果是 map 的元素类型的零值。 闭包函数也是值。 Go 函数可以是闭包的。闭包是一个函数值，它来自函数体的外部的变量引用。 函数可以对这个引用值进行访问和赋值；换句话说这个函数被“绑定”在这个变量上。 例如，函数 adder 返回一个闭包。每个闭包都被绑定到其各自的 sum 变量上。 123456789101112131415161718192021package mainimport "fmt"func adder() func(int) int &#123; sum := 0 return func(x int) int &#123; sum += x return sum &#125;&#125;func main() &#123; pos, neg := adder(), adder() for i := 0; i &lt; 10; i++ &#123; fmt.Println( pos(i), neg(-2*i), ) &#125;&#125; 方法Go 没有类。然而，仍然可以在结构体类型上定义方法。 方法接收者出现在 func 关键字和方法名之间的参数中。 12345678910111213141516171819202122232425package mainimport ( "fmt" "math")type Vertex struct &#123; X, Y float64&#125;func (v *Vertex) Scale(f float64) &#123; v.X = v.X * f v.Y = v.Y * f&#125;func (v *Vertex) Abs() float64 &#123; return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func main() &#123; v := &amp;Vertex&#123;3, 4&#125; v.Scale(5) fmt.Println(v, v.Abs())&#125; 接口接口类型是由一组方法定义的集合。 12345678910111213141516171819202122232425262728293031323334353637383940414243package mainimport ( "fmt" "math")type Abser interface &#123; Abs() float64&#125;func main() &#123; var a Abser f := MyFloat(-math.Sqrt2) v := Vertex&#123;3, 4&#125; a = f // a MyFloat 实现了 Abser fmt.Println(a.Abs()) a = &amp;v // a *Vertex 实现了 Abser fmt.Println(a.Abs()) // 下面一行，v 是一个 Vertex（而不是 *Vertex） // 所以没有实现 Abser。 // a = v&#125;type MyFloat float64func (f MyFloat) Abs() float64 &#123; if f &lt; 0 &#123; return float64(-f) &#125; return float64(f)&#125;type Vertex struct &#123; X, Y float64&#125;func (v *Vertex) Abs() float64 &#123; return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125; 错误Go 程序使用 error 值来表示错误状态。 与 fmt.Stringer 类似，error 类型是一个内建接口： 123type error interface &#123; Error() string&#125; Readersio 包指定了 io.Reader 接口，它表示从数据流结尾读取。 Go 标准库包含了这个接口的许多实现， 包括文件、网络连接、压缩、加密等等。 io.Reader 接口有一个 Read 方法： 1func (T) Read(b []byte) (n int, err error) Read 用数据填充指定的字节 slice，并且返回填充的字节数和错误信息。 在遇到数据流结尾时，返回 io.EOF 错误。 下例创建了一个 strings.Reader。 并且以每次 8 字节的速度读取它的输出。 123456789101112131415161718192021package mainimport ( "fmt" "io" "strings")func main() &#123; r := strings.NewReader("Hello, Reader!") b := make([]byte, 8) for &#123; n, err := r.Read(b) fmt.Printf("n = %v err = %v b = %v\n", n, err, b) fmt.Printf("b[:n] = %q\n", b[:n]) if err == io.EOF &#123; break &#125; &#125;&#125; Web 服务器包 http 通过任何实现了 http.Handler 的值来响应 HTTP 请求： 12345package httptype Handler interface &#123; ServeHTTP(w ResponseWriter, r *Request)&#125; 在这个例子中，类型 Hello 实现了 http.Handler。 访问 http://localhost:4000/ 会看到来自程序的问候。 12345678910111213141516171819202122package mainimport ( "fmt" "log" "net/http")type Hello struct&#123;&#125;func (h Hello) ServeHTTP( w http.ResponseWriter, r *http.Request) &#123; fmt.Fprint(w, "Hello!")&#125;func main() &#123; var h Hello err := http.ListenAndServe("localhost:4000",h) if err != nil &#123; log.Fatal(err) &#125;&#125; goroutine注意不要混淆并发和并行的概念： 并发是用可独立执行的组件构造程序的方法 并行则是为了效率在多CPU上平行地进行计算 尽管 Go 的并发特性能够让某些问题更易构造成并行计算， 但 Go仍然是种并发而非并行的语言，且Go的模型并不适合所有的并行问题。 关于其中区别的讨论，见 concurrency-is-not-parallelism goroutine 是由 Go 运行时环境管理的轻量级线程。 A goroutine has a simple model: it is a function executing concurrently with other goroutines in the same address space。 开启一个新的 goroutine: 1go f(x, y, z) 执行: 1f(x, y, z) f ， x ， y 和 z 是当前 goroutine 中定义的，但是在新的 goroutine 中运行 f。 goroutine 在相同的地址空间中运行，因此访问共享内存必须进行同步。 channel它将共享的值通过信道传递， 在任意给定的时间点，只有一个Go 程序能够访问该值，数据竞争从设计上就被杜绝了。 不要通过共享内存来通信，而应通过通信来共享内存。 “引用计数”通过为整数变量添加互斥锁来地实现，但作为一种高级方法，通过信道来控制访问能够让你写出更简洁、正确的程序。 channel 是有类型的管道，可以用 channel 操作符 &lt;- 对其发送或者接收值。 12ch &lt;- v // 将 v 送入 channel ch。v := &lt;-ch // 从 ch 接收，并且赋值给 v。（“箭头”就是数据流的方向。） 和 map 与 slice 一样，channel 使用前必须创建： 1ch := make(chan int) channel 可以是 带缓冲的。为 make 提供第二个参数作为缓冲长度来初始化一个缓冲 channel： 1ch := make(chan int, 100) 默认情况下，在另一端准备好之前，发送和接收都会阻塞。这使得 goroutine 可以在没有明确的锁或竞态变量的情况下进行同步。 只有缓冲区满的时候发送者阻塞 只有缓冲区空的时候接收者阻塞 发送者可以 close 一个 channel 来表示再没有值会被发送了。接收者可以通过赋值语句的第二参数来测试 channel 是否被关闭：当没有值可以接收并且 channel 已经被关闭，那么经过 1v, ok := &lt;-ch 之后 ok 会被设置为 false。 循环 for i := range c 会不断从 channel 接收值，直到它被关闭。 注意： 只有发送者才能关闭 channel，而不是接收者。向一个已经关闭的 channel 发送数据会引起 panic。 还要注意： channel 与文件不同；通常情况下无需关闭它们。只有在需要告诉接收者没有更多的数据的时候才有必要进行关闭。 12345678910111213141516171819202122232425262728293031package mainimport ( "fmt" "time")func main() &#123; one := make(chan int) two := make(chan int) go func() &#123; fmt.Println("one is sleep...") time.Sleep(1 * time.Second) one &lt;- 100 &#125;() go func() &#123; fmt.Println("wait one...") v := &lt;-one fmt.Println("get one:", v) fmt.Println("two is sleep...") time.Sleep(2 * time.Second) two &lt;- v &#125;() fmt.Println("wait two...") vv := &lt;-two fmt.Println("get two:", vv)&#125; selectselect 语句使得一个 goroutine 在多个通讯操作上等待。 select 会 阻塞，直到条件分支中的某个可以继续执行，这时就会执行那个条件分支。当多个都准备好的时候，会随机选择一个。 默认选择当 select 中的其他条件分支都没有准备好的时候，default 分支会被执行。 为了非阻塞的发送或者接收，可使用 default 分支： 123456select &#123; case i := &lt;-c: // 使用 i default: // 从 c 读取会阻塞&#125; 总结现在只是掌握了基本的 go 语法，能看懂代码，以后要到项目中实战才能领略到 go 的威力，慢慢练吸 go 大法吧。]]></content>
      <categories>
        <category>Coder</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>区块链</tag>
        <tag>复杂美</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人҉҉要҉҉是҉҉雾霾吸҉҉多҉҉了҉҉,҉҉连҉҉看҉҉东҉҉西҉҉眼҉҉都҉҉是҉҉花҉҉哈哈的҉҉。]]></title>
    <url>%2F2017%2F01%2F06%2Fcyrillic-unicode%2F</url>
    <content type="text"><![CDATA[去年微信爆出的《你女朋友撤回了一条消息还亲了你一口》那个 bug，让广大微信用户 excited了一把。 今天，小明在微信群和朋友圈看到了这样因缺思婷的消息: 消息栏里显示乱码，朋友圈也在玩： 此时，已到下班时间，但是你们都懂的，我是一个对技术敏感而细致的男人，对技术的由衷渴望明显战胜了凡夫俗子的食欲。 在第一时间知会微信总舵主张小龙后，我马上开始研究这个有趣的乱码。 经过一番调试后，小明发现是 u&quot;\u0489&quot; 这个 unicode 字符 ҉ 搞得鬼，它有一个诡异的名字叫 COMBINING CYRILLIC MILLIONS SIGN，翻译成国语就是 可拼接的西里尔修饰符字母。 那么，问题又来了，什么是西里尔字母? 谷歌一下： 西里尔字母主要在俄罗斯、东欧、北亚和中亚等国家使用。截至2011年，欧亚大陆约有2.52亿人使用它作为本国语言的官方字母表，俄罗斯约占其中一半。……西里尔语源自希腊语，现代学者认为，西里尔是由西里尔和迪乌斯的早期门徒发展和形式化的。 18世纪初，在俄罗斯使用的西里尔字母由彼得大帝重新改革，新形式的字母变得更接近拉丁字母，几个古老的字母被删除，几个字母是由彼得大帝亲自设计的（如Я，灵感来自拉丁语R）。 （҉，u0489）是西里尔字符系统中的一个修饰词，它无法独立显示，当附着在其他字符前面或后面后，就出出现叠加在字符上面的雾霾效果。 在各种编码系统中，如何表示这个符号呢： Encoding HTML Entity (decimal) &amp;#1161; HTML Entity (hex) &amp;#x489; How to type in Microsoft Windows Alt +0489 UTF-8 (hex) 0xD2 0x89 (d289) UTF-8 (binary) 11010010:10001001 UTF-16 (hex) 0x0489 (0489) UTF-16 (decimal) 1161 UTF-32 (hex) 0x00000489 (0489) UTF-32 (decimal) 1161 C/C++/Java source code “\u0489” Python source code u”\u0489” 为҉了҉便҉于҉缓҉解҉多҉年҉后҉人҉们҉对҉当҉下҉雾҉霾҉的҉思҉念҉，特҉别҉推҉出҉一҉款҉合҉成҉的҉雾҉霾҉专҉用҉纪҉念҉字҉体҉：雾҉霾҉体҉。҉ 雾҉霾҉体҉下҉可҉以҉有҉雾҉霾҉宋҉体҉、҉雾҉霾҉黑҉体҉、҉雾҉霾҉文҉泉҉驿҉以҉及҉超҉级҉雾҉霾҉体҉等҉等҉字҉体҉…҉…҉ 其҉字҉体҉的҉技҉术҉实҉现҉很҉简҉单҉，现҉有҉字҉加҉U҉n҉i҉c҉o҉d҉e҉字҉符҉：&#x0489;即҉可҉，如： 原&amp;#x0489;来&amp;#x0489;如&amp;#x0489;此&amp;#x0489; 就会显示成： 原&#x0489;来&#x0489;如&#x0489;此&#x0489;]]></content>
      <categories>
        <category>Coder</category>
      </categories>
      <tags>
        <tag>微信</tag>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「黄泽瑄的成长记」第一季来啦]]></title>
    <url>%2F2016%2F12%2F18%2FHuang-Zexuan-1%2F</url>
    <content type="text"><![CDATA[这个星期忙里偷闲 给宝宝做了个视频 以宝妈给宝宝拍的小视频为素材 记录她从出生到满月的生活点滴 虽说我两年前就买了 mac 但几乎就没有打开过 iMovie 这是个视频编辑软件 用起来非常傻瓜 普通小白用户不用看说明手册 都可以很快上手 我没有受过科班媒体专业训练 但凭着这么多年使用各种软件的经验 用这个 iMovie 居然毫无压力 视频+配音+字幕+特效 边学边做 这是宝宝纪录片的第一季 视频做得有点粗糙 但 贵在真实 原汁原味]]></content>
      <categories>
        <category>黄泽瑄</category>
      </categories>
      <tags>
        <tag>女儿</tag>
        <tag>iMovie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两小儿「江」持不下辩「长城」]]></title>
    <url>%2F2016%2F12%2F17%2Ftwo-children-debate-on-Great-Wall%2F</url>
    <content type="text"><![CDATA[孔子东游钱塘江，水天相接，江天一色，美哉、壮哉。 路遇两小儿辩斗。 一儿曰：「长城」上映一日，口碑评分陷入江局，吾之于能否走向世界江信江疑。 一儿曰：江心比心，所谓仁者见仁，智者见智，个人主观臆断不可以偏概全。 一儿曰：艺谋张搞大场面，弄色之才登峰造极，然每每不能如观众所愿，江郎才尽乎？《英雄》之后，再无良作，江淹梦笔乎？ 一儿曰：不然，此片非往昔烂片可比，艺谋本色执导，好莱坞和我国一线伶人加盟，一流工业水准打造，即使在西方世界翻江倒海也未可知。 对曰：This is your feeling。国师坐拥天时地利人和之便，吾本对此片充满期待，然以今日之观感，大失所望：长城打怪，虽江心独妙，然西式的特效怪兽与中国特色精神文明建设格格不入；人物台词草草敷衍，人物性格亦无甚亮点；故事推进得莫名其妙，期间堆砌各种中国元素，恰似一个个割裂的舞台节目，掐着表计算演出时间，one by one 地～急着登场，又仓促谢幕。真是糟蹋了这满满一城的精致！ 一儿曰：此诚如所言，然五色禁军视觉之观感、大场景 3D 之特效、BGM 之震撼淋漓，不亦可赛艇乎？ 对曰：众人皆知国师有三把斧：霸气之阵容、华美之艳服、夺目之背景，然此等浮夸小技若欲俘获观众，须以故事情节之饱满、发人深省之价值观为本。江山易改，本性难移，汝不知《十面埋伏》《黄金甲》前车之鉴乎？江本逐末，甚之不惠。再有一附庸权贵伶人，世人皆称烂片女王，乃江门弃材也，而艺谋江颜屈体跪舔之，不惠又甚之诶。 「呸，汝江嘴拗舌，一派胡言，不要给我们景甜泼脏水」 「哼，汝江嘴硬牙，无可奉告，就要搞你们景甜大新闻」 孔子不能决也。 两小儿怒而蛤斥曰：「Naive，孰为汝多知乎？」]]></content>
      <categories>
        <category>一颗赛艇</category>
      </categories>
      <tags>
        <tag>长城</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[天分与坚持：四分之一世纪的跑步]]></title>
    <url>%2F2016%2F12%2F07%2Frunning-for-a-quarter-of-century%2F</url>
    <content type="text"><![CDATA[《当我谈跑步时，我谈些什么》这本书是村上春树的跑步回忆录，从 2005 夏天动笔到 2006 秋天写完，零零星星写了他跑步二十年多来的回忆或感悟。 我为什么开始跑步了1978 年 4 月 1 日，下午一点半，29 岁的村上春树决定开始写小说。 为了全身心地投入到写小说中，他和妻子商量卖掉了经营得还不错的酒吧，改掉了原先凌晨两三点下班回家睡觉、中午起床的作息习惯，开始每天清晨五点就起床，晚上十点前睡觉，这样一种规则的生活，一直坚持至今。 他这样看待因此而「荒废」的夜生活和不得不推脱的各种邀约聚会： 人生之中总有一个先后顺序，也就是如何去安排时间和能量。到一定的年龄之前，如果不在心中制定好这样的规划，人生就会失去焦点，变得张弛失当。与和周遭的人们交往相比，我宁愿又想确立能专心致志创作小说的稳定和谐的生活。我的人生中最为重要的人际关系并非同某些特定的人物构筑的，而是与或多或少的读者构筑的。稳定我的生活基盘，创造出能集中精力执笔写作的环境，催生出高品质的作品，才会为更多的读者欢迎，这也是我作为一个小说家的责任和义务。 「人不可能做到八面玲珑、四方讨巧」。说白了，就是此意。 刚刚成为专业小说家那会儿，他首先直面的问题却是「如何保持身体健康」。 打算作为小说家度过今后漫长的人生，就必须找到一个既能维持体力，又可将体重保持得恰到好处的方法。 村上春树性情孤绝，喜爱独处，他坦言自己没有发达的运动神经和灵活的四肢，不擅长那些速战速决型的竞技类体育项目，但是像跑步和游泳这种一个人就可以完成的运动，倒和他的胃口。 至少在跑步时不想和任何人交谈，不必听任何人说话，只需眺望周围的风光凝视自己便可，这是任何东西都无法替代的宝贵时刻。 而且，相比其他运动，跑步有几个显而易见的长处：不需要伙伴或对手也不需要特别的装备，更不必特地赶赴某个特别的场所，只要有一双适合跑步的鞋，有一条马马虎虎的路，就可以在兴致所至时爱跑多久就跑多久。 基于这些考虑，小说家村上春树在他 33 岁时开始了跑步这项运动，无论寒暑冬夏，几乎每天都坚持跑步，你猜他跑了多久？ 27 年！每周跑 60 公里，一周 6 次，平均每天 10 公里，累计参加 28 次马拉松…… 为自己而跑对于各种体育运动，村上春树说他不甚在乎胜负成败，倒是更关心能否达到为自己设定的标准。 他每日一面跑步，一面将目标的横杆一点点提高，通过超越这高度来提高自己，至少是通过刻意的训练来提高自己，并为之付出努力。在长跑中，如果说有什么必须战胜的对手，那就是过去的自己。 对于他来说，能否感到自豪或者类似自豪的东西，这，才是最重要的。当然不需要跑得比香港记者还快啊。 同样的说法也适用于写作，小说家这一职业至少对我来说是无所谓胜负成败的。书的销量、得奖与否、评论的好坏，这些或许能成为成功与否的标志，但不能说是本质问题。写出来的文字是否达到了自己设定的基准，这，才是至为重要；这，才容不得狡辩。别人大概怎么都可以搪塞，自己的心灵却无法蒙混过关。在这层意义上，写小说很像跑全程马拉松，对于创作者而言，其动机安安静静、确确实实地存在于自身，不应向外部去寻求形式与标准。 跑步 vs 写小说写小说并非那么安逸的工作。坐在书桌前，将神经如同激光束一般集中于一点，动用想象力，从无的地平线上催生出故事来，挑选出一个个正确的词语，让所有的流程准确无误，这样一种工作与一般人想象的相比，更为长久的需要远为巨大的能量。 作为一个小说家，村上春树不是天生才华横溢的那类。为了写小说，非得奴役身体，耗费时间和劳力不可。因为长年累月的坚持这种生活，久而久之，就技术和体力而言，他都能相当高效的找到新的创作灵感。 他写小说的许多方法是每天清晨沿着道路跑步时学到的。 对小说家来说，最为重要的资质是什么？无需赘言，当然是才华。这是必要的资质，或者说前提条件，就好比如果没有燃料，再出色的汽车也无法开动。然而，才华于质于量都是主人难以驾驭的天分。 第二的重要资质，是集中力。将自己拥有的有限的才能汇集，然后倾注于最为需要之处的能力。没有它，则不足以办成任何大事。有效地使用这种力量，就可弥补才华的不足与偏颇。 第三是耐力，每天集中精力写作，坚持半载，一载，乃至两载，有志于写长篇的小说的作家就必须具有这种耐力，姑且把这比作「呼吸法」： 假使说集中力是屏住呼吸，耐力就是一面屏气，一面学会安静徐缓地呼吸。这两种呼吸法如果不能保持平衡，就难以长年累月地作为职业作家坚持写小说。得一面屏住呼吸，一面继续呼吸。 每天不间断地写作，集中意识地去工作，这事非做不可，将这样的信息持续不断地传递给身体系统，让他牢牢地记住，再悄悄移动刻度，一点一点将极限值向上提升，注意不让身体发觉。 这跟每天坚持慢跑，强化肌肉，逐步打造出跑者的体型，乃是异曲同工。给它刺激，持续，再给它刺激，持续。这一过程当然需要耐心，不过一定会得到相应的回报。 跑步哲学萨摩赛特·毛姆说：「任何一把剃刀都自有其哲学」。 无论何等微不足道的举动，只要天天坚持日日坚持，从中总会产生出某些类似观念的东西来。 村上春树 作家（兼跑者） 1949-20xx 他至少是跑到了最后]]></content>
      <categories>
        <category>心旷神怡</category>
      </categories>
      <tags>
        <tag>村上春树</tag>
        <tag>跑步</tag>
        <tag>写作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《你的名字》难再续]]></title>
    <url>%2F2016%2F12%2F04%2FYour-Name%2F</url>
    <content type="text"><![CDATA[梦里相逢人不见，若知是梦何须醒。纵然梦里常幽会，怎比真如见一回。 男高中生小江一天醒来突然发现自己变成了女生，拥有了亮丽的歌喉，而女高中生小宋醒来后发现自己裤腰带特别高。 身处两地的两人身体互换，奇妙地过上了对方的生活。 身为小宋的小江上课时听到老师讲林则徐的故事：「苟……」，大受启发；身为小江的小宋考入名牌大学，突然来到北京，突然就任要职。 有一天，小宋偶然发现自己不再能跟小江交换身体，于是前往北京寻找原因，发现未来的小江身患重病，躺在军区医院里。 小宋为了警告小江，跑到地动仪前祈祷再次穿越到小江的身体里。她看到蟾蜍嘴里的球掉了下来，陷入了昏迷。 醒来后，小宋再度变成了小江。 她跑到天安门前大喊「苟……」，此时，变成小宋的小江也在天安门前，听到小宋的呼喊。两人擦身错过，却看不到对方，只能听到声音。这时小江提议绕着天安门广场奔跑，跑得越来越快，直到两人均速一样的时候就看到了对方。 小宋拿起笔说我们写下对方的名字吧，小江说「好」，这时候小江消失了。当小宋醒来，却再也不记得那个人是谁。她打开手掌，只能看到手心里写着「+1s」。 原来，两个人一直在以 1s 的单位不停远离开去，所以永远都见不到对方。小宋在绝望之中站在天安门广场上大声呼喊「你的名字是……」 冥冥之中突然传来小江的声音：「蛤？」]]></content>
      <categories>
        <category>一颗赛艇</category>
      </categories>
      <tags>
        <tag>新海诚</tag>
        <tag>你的名字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[苦涩虐心的爱河]]></title>
    <url>%2F2016%2F11%2F29%2FNorwegian-Wood-10-bitter-love%2F</url>
    <content type="text"><![CDATA[渡边爱过直子，如今仍同样爱着她，希望等她病好了后和她重新开始新的生活。 从阿美寮疗养所看望直子回来后，渡边和绿子已经无法制止地相爱了。渡边爱绿子这点恐怕更早些时候就已了然于心，只不过他长期回避作出结论。 绿子心里多么渴望和渡边在一起啊，可是渡边牵挂的只是直子的病情，他把自己关在一个人的世界里，对外界的一切都不关心。自然，也就冷落了绿子这个活蹦乱跳的女孩： 「你可知道？今天你做了一件十分使我伤心事：你甚至没有注意到我发型的变化吧？我辛辛苦苦一点点把头发留长，好不容易在上周末把发型变得像个女孩模样，可你连这点都未察觉吧？我自以为十分可爱，加之久未见面，本想吓你一跳，然而你根本无动于衷，这岂不太跟人过不去？反正你现在恐怕连我穿什么衣服都记不起来了。我也是个女孩！你就是再有心事要想，也多少该正眼看我一下才行。只消说上一句’好可爱的发型’，往下无论你做什么，哪怕再心事重重，我都会原谅你」。 不错，我是生你气来着，恨不得狠狠踢你一百八十脚。还不是，好久才见一次面，你却呆愣愣地只顾想别的女人，看都不愿看我一眼，我就是生这个气。 在一起的时候不好好珍惜，绿子不理他了，渡边才发现自己内心其实也爱着绿子： 「由于不能同你说话，我送走了十分凄楚而寂寞的四月和五月，如此凄楚寂寞的春天，我还是第一次体会到。见不到你之后，我才深深意识到，只因有你，我才得以好歹坚持到现在，失去你之后，我实在孤独得好苦」。 他对绿子的爱或许是因为直子的缘故有所犹豫和保留，但绿子对渡边的爱则是那样汹涌澎湃，没有怀疑的余地。 「为什么？」绿子吼道，「你脑袋是不是不正常，又懂英语虚拟语气，又能解数列，又会读马克斯，这一点为什么不明白？为什么还要问？为什么非得叫女孩子开口不可？还不是因为我喜欢你超过喜欢他吗？我本来也很想爱上一个更英俊的男孩，但没办法就是看中了你」。 「我可是有血有肉的活生生的女孩」，绿子把脸颊擦着我的脖颈上说，「而且现在就在你的怀抱里表白说喜欢.只要你一声令下，赴汤蹈火都在所不惜.虽然我多少有蛮不讲理的地方，但心地善良正直，勤快能干，脸蛋也相当俊俏，乳房形状也够好看，饭菜做得又好，父亲的遗产也办了信托存款，你还不认为这是大甩卖？你要是不买，我很快就到别处去」。 问题在于渡边无法很好地向直子解释这种局面的发展。他对直子，一直抱有某种爱的责任，并且他不能放弃这种责任，纵使直子并不爱他，他在自己心田中为直子保留了相当大一片未曾被人染指的园地（渡边自从去年到疗养所看望直子，回来之后大半年再没和女孩子睡过觉）。 在直子身上，我感到的是娴静典雅而澄澈晶莹的爱，而绿子方面则截然相反，那是站立着的，在行走，在呼吸，在跳动，在摇撼我的身心的爱，我心乱如麻，不知所措。 他也无法制止和绿子相爱。「我渴求她，她也渴求我，我们已经在相爱，有谁能制止得了呢？」 渡边想起在雨中天台拥抱绿子，那是何等柔软；在她床上被其用手抚慰，又是何等温暖。 作为我，何尝不想把绿子剥得精光，分开下肢进入到她温暖的缝隙中去——为克制这种强烈的冲动，我不知做了多大努力。当她握住我那种东西的手指缓缓移动的时候，我实在不能自已。 绿子，热情如火；直子，平静如水。苦涩的爱河，不知流淌向何处。 村上村树借玲子给渡边的回信，表达了他对渡边和直子、绿子的三角关系的看法： 第一，渡边既痴情于直子，又强烈地被绿子吸引，这就好比「在风和日丽的天气里荡舟于美丽的湖面，我们会既觉得蓝天迷人，又深感湖水多娇」——乃人之常情。 第二，即使不作为直子的恋人，渡边依然可以是直子的精神支柱，还可以为直子做很多事。 第三，爱上一个人是难得的好事，更难得是两个人彼此都相爱。抓住机会，去追求你自己的幸福吧，人的一生中这种机会只有两三回，一旦失之交臂，一辈子都后悔莫及。 令读者惋惜的是，直子最后自杀了，渡边君最终也没能挽回绿子。 一股沉痛的忧伤！]]></content>
      <categories>
        <category>挪威的森林</category>
      </categories>
      <tags>
        <tag>直子</tag>
        <tag>渡边</tag>
        <tag>绿子</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一种从来不曾实现而且永远不可能实现的憧憬]]></title>
    <url>%2F2016%2F11%2F28%2FNorwegian-Wood-9-dream-never-realized%2F</url>
    <content type="text"><![CDATA[初美是永泽的女朋友，她长得并不出众，但她身上有一股强烈打动人的力量，她娴静、理智、幽默、善良，浑身发出高贵而优雅的气质。 永泽时常同别的女孩子厮混，她基本晓得，但一次也没有出口怨言。她真心真意爱着永泽，却丝毫不加以干涉。 永泽是一个精致的利己主义者，用村上春树的话说就是，「一个在道德意义上破产的人」。 但这不代表他一无是处，他有句名言值得每一个有志青年共勉： 不要同情自己，同情自己是卑劣懦夫干的勾当。 他比身边绝大多数人都努力得多，其他人只是毫无目的地幸苦劳动，他是有目标地规划他想要的人生。 比如说，为了外务省工作更得心应手，他开始拼命自学西班牙语，法语也是自学的，并达到了无懈可击的地步。 他说： 和玩女人一个道理，只要摸到一条规律，往下任凭多少都是一个模式。 永泽无法打心眼里爱上一个人，而总有某个地方保持清醒的饥渴感，他需要的只是搂着女人肉体的快感，而不想担责任。 身体有了性欲，见面、干、分手，连女孩子名字都不知道，如此而已。 他敢于面对未来任何的阻挡，勇往直前，不为任何事情束缚牵绊。他享受当下的快感，又不期待未来的种种。这样的人是无法接受一般的所谓的幸福的，因为那些所谓的幸福在他的眼里低俗不堪，甚至无法忍受。 永泽对初美是一种欣赏和认同，出于对她某一特性的憧憬和触动。但这不能称之为爱，他感兴趣的，永远只是自己而已，就像他说的，「初美能理解最好，不能理解是她自己的问题」。 初美命中注定爱上了这样一个精明、自私、不负责任的男人，三年来如此执着地等着他。 终于有一次聚餐时，初美受够了永泽的傲慢自私，大喊： 我受伤害还不够吗，你们还想要多少人受伤害？ 永泽出走，初美嫁为人妇，不久便割腕自杀了。 由于初美的死，渡边觉得「某种东西消失了」。 这是种什么东西，渡边直到在十二三年后才恍然大悟： 它类似一种少年时代的憧憬，一种从来不曾实现而且永远不可能实现的憧憬。这种直欲燃烧般的天真烂漫的憧憬，我在很早以前就已遗忘在什么地方了，甚至在很长时间里我连它曾在我心中存在过都未曾记起。而初美所摇撼的恰恰就是我身上长眠未醒的「我自身的一部分」。当我恍然大悟时，一时悲枪之极，几欲涕零。 年少时，我们每个人都有过对爱情的幻想，那时憧憬的爱情是简单纯洁干净的。长大后，在滚滚红尘中打拼得久了，生活逐渐颓废，以往坚持的信念开始崩塌，虚无感产生之后便开始从花天酒地中寻找慰藉（就像永泽和渡边出去约炮）。 而初美身上，有一种纯真的力量，她对爱情执念如初，会勾起人遗失的记忆。渡边终于见到了这样的爱情，见到了这样的女性，这是如榜样一样的人啊，初美身上寄托了渡边所有对于爱情的理解与憧憬。 初美的一生都是纯粹的。 然而，初美死了，所以他觉得「某种东西消失了」。 唯死者永远年轻。]]></content>
      <categories>
        <category>挪威的森林</category>
      </categories>
      <tags>
        <tag>永泽</tag>
        <tag>初美</tag>
        <tag>纯真</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你真是个好人呢]]></title>
    <url>%2F2016%2F11%2F27%2FNorwegian-Wood-8-good-man%2F</url>
    <content type="text"><![CDATA[上次的那个星期天，绿子和渡边在晒衣台上看火灾、喝酒、唱歌，过得实在是太开心了。 别人总是对她挑鼻子竖横眼，一见面就叫她要这样不要那样……唯独渡边什么也没有强加于她，一切都是自然而然地就发生了。 渡边没什么朋友，喜欢独来独往，对周遭的人和事都抱着「无所谓、你开心就好」的态度，这种貌似软绵绵、缺乏男性魄力的特质，绿子却喜欢得不得了，经常约他出来一起玩。 绿子大胆地对他表白示爱，使劲地挑逗他，撩他，幻想渡边强奸她、幻想渡边想着她来手淫、幻想他俩被海盗抓住浑身扒光脸对脸绑在一起…… 倒不是说绿子性饥渴，她一直在女校长大、没有同龄的男孩子陪她玩、父母对她又缺乏关爱。因此，她仅仅是对此感兴趣，急于想知道罢了。想知道男孩子都在思考些什么，身体结构是什么样子。她男朋友却古板得要死，每次谈到这些，他就沉下脸，说她淫乱，不正常，连爱抚一下那里都不让。 绿子拉渡边去看色情电影，她最喜欢那种镜头出现的时候，听见周围一大群男人「咕噜」咽唾液的声音，可爱得不得了。 绿子觉得孤单，孤单得要命，希望渡边多陪陪她，渡边则一直谦让着她，由着她闹性子，陪她讲各种下流的脏话，陪她喝酒聊天看电影，在以往二十年人生当中，能允许她这样做的只有渡边一个。 她非常想和渡边在一起，「求你了，要不然我就坐在这儿呜呜哭一晚上，谁向我第一个搭话，就跟谁睡去」，渡边只得跟着绿子去了她家过夜。 “喂喂喂，说点什么呀！”绿子把脸埋在我胸前说。“说什么？”“什么都行，只要我听着心里舒坦。”“可爱极了！”“绿子，”她说，“要加上名字。”“可爱极了，绿子。”我补充道。“极了是怎么个程度？”“山崩海枯那样可爱。”绿子扬脸看看我：“你用词倒还不同凡响。”“给你这么一说，我心里也暖融融的。”我笑道。“来句更棒的。”“最最喜欢你，绿子。”“什么程度？”“像喜欢春天的熊一样。”“春天的熊？”绿子再次扬起脸，“什么春天的熊？”“春天的原野里，你一个人正走着，对面走来一只可爱的小熊，浑身的毛活像天鹅绒，眼睛圆鼓鼓的。它这么对你说道：‘你好，小姐，和我一块儿打滚玩好么？’接着，你就和小熊抱在一起，顺着长满三叶草的山坡咕噜咕噜滚下去，整整玩了一大天。你说棒不棒？”“太棒了。”“我就这么喜欢你。”绿子紧紧贴住我的胸口，“好上天了！” 渡边这段时间由于还没有确认对绿子到底是一种怎样的感情，因此他刻意避免同绿子发生性关系，即使和绿子躺在一张小床上，即使「绿子把鼻子贴着我的胸口，手搭在我的腰部」，渡边也极力克制了自己，待绿子响起睡熟的声音后，溜下床去厨房看《在轮下》。 可以说，渡边一旦确认了对对方的感情，比如直子，对待性就变得严肃起来，开始有了责任感，而不像从前那样，为了释放生理的欲望，随随便便就和女孩子上床睡觉。 而这，未尝不可视为他对纯真的爱情的追求。]]></content>
      <categories>
        <category>挪威的森林</category>
      </categories>
      <tags>
        <tag>好人</tag>
        <tag>在轮下</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[这世上的长者已不多]]></title>
    <url>%2F2016%2F11%2F26%2Fonly-older%2F</url>
    <content type="text"><![CDATA[他，一位可敬的长者，出生在 1926 年，曾经一度大权在握，也曾拥有许多信众，在乱世身经百战，与对手谈笑风生，在永生的道路上，他走得比谁都远…… 然而今天，这位长者，突然～就去见马克思了。 他的经历嘛，就是到了哈瓦那，到了 1959 年初的时候，他就领着他创建的古巴共产党建立了古巴社会主义共和国。 在哈瓦那执政 52 年，他也没做别的，主要就是三件事: 第一个，就是通过努力奋斗在 2014 年获得了孔子和平奖。 第二个，就是 sleep with 35000多个 women。 第三个，就是躲过了 638 次美国反动派的暗杀。 如果说还有什么别的，那就是在续命征程上落后了中国的长者，很惭愧，先走一步了。]]></content>
      <categories>
        <category>一颗赛艇</category>
      </categories>
      <tags>
        <tag>卡斯特罗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不正常人类疗养院]]></title>
    <url>%2F2016%2F11%2F25%2FNorwegian-Wood-7-hospital%2F</url>
    <content type="text"><![CDATA[《挪》书中的人物，似乎个个都有各自的缺陷，得不到排解的人，一死了之，活着的人，在苦苦探寻心灵的自我救赎。 木月不正常。 他拼命掩饰自己软弱的一面，在渡边面前装的一本正经，和直子独处时性情说变就变。他想努力改变自己，提高自己，却总不能如愿，又着急又伤心，直到最后打磨完自己的信心，自杀了事。 直子不正常。 一方面在于生理的缺陷。如果木月没死，她和木月是会在一起过一辈子的。她痛苦的是，她和木月没有真正意义上地体会过一对相爱的男女在一起做爱的快感，每当谈及这个问题，直子都啜泣不止。 虽然她心里爱着木月，和木月接吻的感觉也很妙，但是到关键时刻就是打不开，不知道尝试了多少回，可就是不成功，下面一点也不湿润，又干又痛，只能用手指和嘴唇来安慰木月。 但二十岁生日的那个晚上，和渡边在一起却湿润得一塌糊涂。身体和心灵想着不同的男人，连她自己都弄不清这到底是怎么回事，这种矛盾的羞耻感一直难以释怀。 另一方面，跟她同样也不健全的姐姐有关，她姐姐有时一连几天关在家里闭门不出，最后上吊自杀，至于为什么，谁也弄不明白。和木月一样，事件发生前没有任何前兆。 看着姐姐僵死在那里，直子一动没动，一句话都没说，好像毫无知觉了。或许，在很小的时候，直子和她姐姐就患有某种程度上的精神抑郁症。 玲子不正常。 年轻的时候她本可以做一个出色的钢琴弹奏家，突然就手指完全失去感觉，赋闲在家教一个十三岁聪明而富有心计的女孩学弹琴，未曾想那女孩是个同性恋，学着学着把玲子睡了。 女孩子的爱抚比她老公的感觉还舒服，让玲子一度怀疑自己是同性恋者。她自杀未遂，和丈夫离婚，来到了这里，一呆就是七八年，她害怕和外面的世界再发生关系，怕见各种人，怕想各种事。 可惜，不健全的木月和直子的姐姐，在旁人发现他们的不正常之前，就带着缺陷猝然离世，没有机会在阿美寮医院接受疗养。 死了的人一只都是死的，但直子和渡边还要活下去。她又不想因为她的病拖累了渡边： 我是个比你想的要不健全得多的人，我病的时间比你想的要长久的多，根也深得多。所以，如果你能往前行的话，希望你只管一个人前行就是，别等我。想和其他女孩子睡觉就睡好了，别考虑我顾忌我，喜欢什么就尽情做什么。要不然，我说不定会拖累你。我，不管发生什么，这事是绝对不想做的。不想耽误你的人生，也不想耽误任何人的人生。我只希望你时常来看我，永远记着我——我希望的只是这个。 现在似乎开始明白，村上开篇说的那个「永远不会忘记」的诺言是怎么回事了。]]></content>
      <categories>
        <category>挪威的森林</category>
      </categories>
      <tags>
        <tag>疗养院</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿美寮的三段言情戏]]></title>
    <url>%2F2016%2F11%2F24%2FNorwegian-Wood-6-Amilao%2F</url>
    <content type="text"><![CDATA[《挪威的森林》不得不说的三场言情戏。 1 久别独聚醒来就看到喜欢的女孩子注视着自己的脸，这等含情脉脉换做谁都会融化。 我，在三人一起见面前想单独看你一眼。也不是有什么话非说不可，只是想看看你的脸，习惯一下。要不然会觉得不习惯，我这人笨的很。 这部分内容虽只写了短短一页，却让读者有一种无以名状的甜蜜和温馨，足见村上营造情绪的功力。 2 浪漫月夜直子、渡边、玲子围烛而坐，恍若世界的角落里只剩下他们三人。月影悄无声息，烛光飘忽不定，把酒同欢，吉他弹舞曲，美人相伴，文艺小清新梦幻般的浪漫满屋。 半年时间，直子的娇美已开始带有成熟女性的风韵，她的娴静荡漾着一股给人以亲切和抚慰之感。 那天晚上，渡边分不清到底是置身梦境还是如临其境，直子裸露着身子站在他床边：她腰间美丽的曲线、丰满而光洁的乳房、随着呼吸静静起伏的平滑的小腹，以及下面软软的黑黑的毛丛。 3 绿茵藏艳第二天，渡边和直子二人到山上的草地里像之前那样胡乱地走着。两颗迫不及待的灵魂终于可以在一起互诉衷肠了，村上给他们来了段小黄文～ 想和我睡？自然。能等？当然等的。现在变硬了？脚底板？傻瓜……那滋味，不好受？什么？冲动啊。就是憋的不舒服。给你放出来好吗？用手？嗯。 他们抱在一起，淹没在草丛中，除了天空、白云，什么都看不见。 这三段感情戏，或虚或实，由浅至深，把渡边和直子俩人的思念化作触手可及的恋人间的你侬我侬，剧情需要，其中不乏露骨的性描写，为广大书迷所钟爱。渡边在阿美寮疗养所和直子相处的这短短两天，在 133 分钟的未删减版电影中，足足演绎了近半个小时，这也是全书中最唯美、最值得一读再读之处。]]></content>
      <categories>
        <category>挪威的森林</category>
      </categories>
      <tags>
        <tag>纯爱</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[他又出去约了]]></title>
    <url>%2F2016%2F11%2F23%2FNorwegian-Wood-5-casual-sex%2F</url>
    <content type="text"><![CDATA[渡边经常会想起和木月在一起的日子，没有木月，他甚至会感到孤寂。 逝者，对于生者到底是个什么样的存在？或者说，谈不上存在，因为那肉身已化糜烂。但那偶尔浮现的往日在一起的记忆，却依旧会在某个不经意的瞬间让生者悸动。 小说才开始前半部分，村上已经谈死谈了好几次了。我似乎敏感地预感到《挪》书中的人物，莫非都会一个接一个地没了？就像木月之死，猝不及防。因为这本书，村上一开始就说「献给许许多多的祭日」。 虽说我同意「死作为生的一部分永存」，但青春不该是这么阴沉悲伤，它就该像绿子那般灿烂灵动。 日本作家都喜欢绞尽脑汁来悲天悯人，不搞出几个虐恋的故事，怎么好自称伤痕文学？爱，直至成伤，是他们一贯的套路。 当然，村上还没打算这么早就让他们一个接一个地死去，作为本书的主人公，渡边还要经历不少人不少事。 这不，他改不了的约炮陋习，又开始蠢蠢欲动了。 永泽找他去泡妞，这一次，一晚上，俩人一无所获，整个城市找遍所有的酒吧，他们愣是一个都没约成功，一！个！都！没！有！ 俩人各自告别后，渡边在早餐店邂逅了两个女孩子，其中一个因为男朋友出轨，悲痛不已，她要报复男朋友，于是和渡边开房去了。 女孩子的指甲死死地抠紧渡边的后背，高潮时喊了十六次那个渣男的名字…… 事后，渡边找这样的托词来辩白：「其实双方都不特别想一起睡觉，只是如若不睡，事情便无法收场」。 我强烈鄙视这样的狡辩。 无耻之徒，乘人之危，骗色骗炮。谁说不睡就不能收场？陪人家喝点酒，聊聊天，等她睡一觉恢复理智就好了，渡边君你可以一个人打开电视看球赛啊？或者继续发扬你国把女的绑起来自己专心致志地擀面条的优良传统啊……不想睡还睡？什么人啊，依他的德性，只要是个女人，他一精虫上脑，照样就睡了。 他妈的！敢做不敢当，就不能像林丹那样光明正大地承认错误？]]></content>
      <categories>
        <category>挪威的森林</category>
      </categories>
      <tags>
        <tag>林丹</tag>
        <tag>约炮</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[女追男 | 奇特的邂逅]]></title>
    <url>%2F2016%2F11%2F22%2FNorwegian-Wood-4-strange-encounter%2F</url>
    <content type="text"><![CDATA[兴趣是结交好友的桥梁，也是搭讪的好手段。 《了不起的盖茨比》让渡边成了永泽的朋友，戏剧史Ⅱ，让绿子注意上了他。 渡边在一家饭店吃午饭时，绿子主动来搭讪。绿子给渡边的印象是，一个热情奔放，活力无限的短发女孩，简直就像刚刚迎着春光崩掉到世界上的一只小动物，这和娴静、文雅的直子形成了强烈对比。 绿子欣赏渡边独来独往一切看似无所谓的言谈举止方式，渡边则说，「哪里会有人喜欢孤独！不过是不乱交朋友罢了，那样只能落得失望」。 有一次，绿子带渡边来到她就读的高中，她其实打心眼里不乐意去那所学校读书的，里面的女生都非富即贵，而她家不过靠经营一个小书店维生。绿子是个很倔强的女孩子，一般不喜欢读书的女孩子用的是逃课这种伎俩，她则把内心的逆反通过这样一种看似妥协的方式来表达：「因为我讨厌学校讨厌得要死，所以才一次课都没旷过，心想怎么能败下去！即使高烧三十九度也照样去学校」。 绿子和渡边交谈起来也是无所顾忌： 学校院子里冒的白烟被她说成是在烧女生用完扔在垃圾桶里的卫生巾。 她说她家书店脱手最快的就是《妇女杂志》，附近的太太们把它买回家，背得滚瓜烂熟等丈夫回家演习。那东西真是黄的可以，附录中带有四十八种性姿势插图，鬼知道这世上的太太们每天想的是什么！ 住在这里的人是不是都打飞机啊？男的手淫和女孩子来月经是同一码事。 绿子约渡边星期天去她家玩，给他做了顿午饭吃。由于绿子家人忙于事务都不愿意做饭，绿子靠自学居然烧得出几个关西风味的好菜，让渡边 surprised 了一把。 她们家大人连厨具也不舍得买，绿子只得用买胸罩的钱买了一个煎蛋锅，结果有三个月她都是带着半湿不干的胸罩出门，册那！ 自古情人眼里出西施。在绿子看来，渡边别具一格的说话方式好讨人喜欢，她倾慕于渡边身上那种「不情愿被某种东西束缚住」的特质。她本人也怎么不在乎别人的看法，照样吸不适合女孩子的万宝路烟，灭烟姿势粗鲁得像砍柴女…… 这个下午，渡边和直子在晾衣台上看外面火灾的热闹，幸灾乐祸地对着不远处起火的地方唱歌、喝酒，对周围的事来个不屑一顾。 绿子坦白她对爱感到饥渴，「真想完完全全得到一次爱——哪怕仅仅一次也好，一次就行，只消一次，然而，不论是家人还是男朋友，他们竟一次都没满足过我。我下定决心，一定要找个百分之百爱我的人」。 她所追求的严格意义上来说不是那种完美无缺的爱，只是要容许她任性，百分之百的任性，这就足够了。 比方说，我现在对你说想吃草莓蛋糕，你就什么也不顾地跑去买，气喘吁吁地跑回来递给我，说「喏，绿子，这就是草买蛋糕」。可我又说「我已经懒得吃这玩意了！」，说着「砰」一声从窗户扔出去。这就是我说的真爱。 看完了热闹，俩人有些疲惫，一切那么自然地，四目相对，悄无声息地吻了五六秒钟。 渡边这样解释道，在午后的阳光下坐在晾衣台上喝着啤酒观看火灾，从吵吵嚷嚷到现在大街上的空空荡荡，他们一起感受到了某种情绪的高潮和低谷，无意中想以某种形式将其存留下来。 那吻的感觉是温柔而安稳的，但不知其归宿，甚至对都有交往对象的彼此来说，是包含某种危险的吻。]]></content>
      <categories>
        <category>挪威的森林</category>
      </categories>
      <tags>
        <tag>绿子</tag>
        <tag>女追男</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[男人啊，就这副德性？]]></title>
    <url>%2F2016%2F11%2F21%2FNorwegian-Wood-3-man-virtue%2F</url>
    <content type="text"><![CDATA[因为被发现读《了不起的盖茨比》，渡边成了永泽这个富家子弟的朋友，永泽也成了渡边在宿舍楼里唯一的朋友。 永泽说：「通读三遍《了不起的盖茨比》的人，倒像是可以成为我的朋友。不是说我不相信现代文学，我只是不愿意在阅读未经过时间洗礼的书籍上面浪费时间，人生短暂」。 他极具个人魅力，天生具有那种吸引人、指使人的气质，他睡过七十多个女人，曾一次生吞过三条蛞蝓。 在渡边眼里，他是个矛盾的人：既有令人赞叹的高贵精神，又是个无可救药的时间俗物；可以春风得意地率领众人长驱直进，而那颗心，同时又在阴暗的泥沼里孤独的挣扎。 在渡边眼里，他还是个诚实的人，他对渡边始终亲切如一，生活上给予诸多关照。可以说，永泽真心把渡边当朋友，而渡边因而忍受不了他「醉后想方设法捉弄女孩子」，因而不肯对他像对木月那样交心相待。 渡边其实有那么点虚伪，他一方面认为永泽和女孩子睡觉并非出于真心，纯粹是泄欲的把戏，并自我标榜： 我自己其实不大喜欢同萍水相逢的女孩同床共衾。作为疏导情欲的一种方式，固然惬意，而且同女孩相互拥抱着触摸身体也颇为开心。但厌烦的是早起后房间的凌乱、情绪的昏沉、和道德上的自我厌恶、幻灭之感。 其实，我们知道，后来渡边还是因为忍受不了生理的饥渴而继续出去睡女孩子了，即使和直子以及后来出场的绿子处于恋爱期，这种事也从没断过。 有了女朋友还约炮，日本年轻人在六七十年代对「性」就是这个态度啊？ 他也算承认了私生活上的自我堕落，事后都羞愧不已： 我这是干的什么事？不由得一阵心灰意冷，我想我不应该干这等勾当，然而又不能不干，我的身体十分饥渴，巴不得同女人睡觉。而我同他们睡觉的时候又总是想着直子，想直子黑暗中白嫩嫩浮现出来的裸体，想她的喘息，以及外面的雨声。而且越想越觉得身体饥不可忍，渴可不耐。 腰间挂着两颗滚烫的肾，男人啊，就这副德性。 渡边向永泽探讨了关于睡女孩子一事，永泽像是在回答知乎上那个：「性对男人到底有多重要」的问题，或者说得更确切一点「性对青春期的男人到底有多重要」。 「这种事连续干过七十多次，是否会觉得空虚？」 「如果你觉得空虚，说明你是正人君子，可喜可贺」，他说，「和素不相识的女孩睡觉睡的太多，终归是徒劳无益，只落得疲惫不堪，自我生厌，我也一样。」 「那你为什么还那么卖力气？」 「很难解释。对了，你知道陀思妥耶夫基在一本关于赌博的书里说过，在周围充满可能性的时候，对其视而不见，是非常困难的事。你明白吗？傍晚，女孩子们走上街头，在那一带东游西逛，饮酒消遣。她们是在寻找某种东西，而这种东西我们又可以提供。这是再简单不过的买卖，就像拧开水龙头喝水一样。我们转瞬间就可以发泄，而对方又求之不得。这就是所谓的可能性。这种可能性就在眼前来回晃动，难道你能视而不见？自己具有这种能力，又有发挥这种能力的场所，你能默默通过不成？」 村上似乎想借永泽这个人物来剥落出普通男人身上的一些原始隐藏的欲望或者暗面吧，亦或通过永泽来传达出另外一个社会阶层的人的世界？ 永泽是个怎样的人，后续村上会怎样刻画使这个人物形象更丰满，拭目以待。]]></content>
      <categories>
        <category>挪威的森林</category>
      </categories>
      <tags>
        <tag>约炮</tag>
        <tag>永泽</tag>
        <tag>了不起的盖茨比</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[木月之死和黑暗中的裸体]]></title>
    <url>%2F2016%2F11%2F20%2FNorwegian-Wood-2-dead-and-naked-body%2F</url>
    <content type="text"><![CDATA[直子是木月的恋人，渡边是木月的好友。 三个人经常外出游玩，谈天说地，不知道欢聚了多少次。 每当木月暂时离开和直子独处时，渡边便显得坐立不安，他和直子谈不上三言两语，双方都不晓得从何谈起，只能一声不吭地喝水或者摆弄桌面上的东西，等待木月到来。 毫无征兆地，一个夜里，木月在自家车库自杀了。 木月死后到高中毕业的十个月时间里，渡边无法确定自己在周围世界中的位置，他结交了一个女孩子，同她睡过觉，但不到半年便分手了。 以前他认为： 死迟早会将我们俘获在手，但反言之，在死俘获我们之前，我们并未被死俘获。 十七岁那年五月的一个晚上，死俘获了木月，同时也俘获了渡边。 木月之死，给渡边带来了永无休止的圆周式思考，在活得好端端的青春时代，居然凡事都以「死」为轴心，旋转不休。 随着时间的推移，他的生死观开始以清楚而简单的轮廓呈现出来： 死并非生的对立面，而作为生的一部分永存。 高中毕业后，渡边到东京上大学，住进寄宿舍开始新的生活。 有一天，他和直子在一列电车里不期而遇。 差不多有一年没见到直子了，直子瘦成了另一个人。 原先别具风韵的丰满脸颊几乎变得平平的，脖颈也一下细了好多，但她的瘦削丝毫不给人以骨感啦不健康啦那类印象。她的瘦法看上去非常自然而娴雅，简直就像在某个狭长的场所悄然藏身体型自然变得纤细起来一样。 俩人漫无目的地散步，渡边跟直子讲述在寄宿舍里莫名其妙的生活：庄严的升降国旗仪式，满是男人的邋遢宿舍，贴在墙上的美人照，口吃、有洁癖、对着收音机做广播体操的敢死队…… 他们差不多每周日都幽会，就这样没完没了地在街头上行走不止，在空漠中寻求语言。 俩人开始彼此逐渐地依顺，心照不宣地避免谈及过去，尤其是木月。 每当冷风吹过，直子下意识地挽起渡边的手臂时，渡边觉得：「她所希求的并非是我的臂，必然是某人的臂，她所希求的并非是我的体温，而是某人的体温，而我只能是我本身，于是我总觉得有些愧疚」。 渡边认为，直子仍纠结于木月的死，她把对木月的感情诉移驾到渡边身上。然而，渡边他只能是他自己，无法像木月对直子那样来对待直子。 在直子二十岁生日的雨夜，渡边和她睡了。黑暗中，白嫩嫩浮现出来的裸体，她凄楚的喘息，以及外面的雨声…… 事后渡边犯了几乎每一个不自信的情场小白都会犯的错误，他问直子为什么没有和木月睡过，直子啜泣不止。 第二天直子悄无声息地搬走了，不知去向。 渡边给她寄信希望和她好好谈谈，等她的回信。直子过了几个月才回信说她因为得了重病在一个精神疗养院接受治疗，眼下还没有做好继续见面的准备，待准备完成了，才可以继续加深相互的了解。 渡边想起直子注视他时那透澈的眼睛，那仿佛在寻觅着什么东西的眼神，每次读信都觉得不胜自哀，这种百无聊赖的心情，既无法排遣，又不能藏匿，如此这般苦苦纠缠。]]></content>
      <categories>
        <category>挪威的森林</category>
      </categories>
      <tags>
        <tag>木月</tag>
        <tag>直子</tag>
        <tag>渡边</tag>
        <tag>自杀</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[希望你永远记住我]]></title>
    <url>%2F2016%2F11%2F19%2FNorwegian-Wood-1-wish-you-remember-me%2F</url>
    <content type="text"><![CDATA[村上村树在 38 岁还拖着一点青春记忆尾巴的时候写了一部现实主义的恋爱小说，小明在快到 30 岁的时候才第一次读它。 今天翻看了第一章，趁着记忆还是新鲜的，写点文字留存。 日本的作家大都属于阴冷派，《挪》开篇也充斥着一股抑郁，阴沉，感伤的文艺气息。 37 岁的渡边君想起自己在过去的人生旅途中失却的许多东西，蹉跎的岁月，死去或离去的人们，无可追回的懊悔。 他能清晰地回忆起十八年前的那片草地：草的芬芳，风的微寒，山的曲线，犬的吠声……但，那可贵的东西：直子和当时的他以及他的世界，却无从想起。 他偶尔能想起直子的面容： 那冷冰冰的小手，那流线型泻下的手感爽适的秀发，那圆圆的软软的耳垂，以及紧靠其底端的小小黑痣，那冬日常穿的格调高雅的驼绒大衣，那总是定定地注视对方眼睛发问的惯常动作，那不时奇妙地发出微微颤抖的语声。 随着记忆逐渐模糊，为了显示对直子做出的「永远不会忘记」的诺言，村上抓住这些已经模糊并且时刻模糊下去的记忆残片，来创作这篇小说。 本章最后一句： 想到这里，我悲哀得难以自禁。因为，直子连爱都没爱过我。 咋一看，让人看得莫名其妙，刚才还缅怀恋人，现在就开始埋怨人家了。 在小明看来，这分明就是个文学创作套路嘛，好比中国古典小说里经常出现的那句「欲知后事如何，且听下回分解」。 村上这个老司机，于不经意处挑起了悬念。]]></content>
      <categories>
        <category>挪威的森林</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[看完这本书，你会比 95% 的中国人更懂中国]]></title>
    <url>%2F2016%2F11%2F17%2FOn-China%2F</url>
    <content type="text"><![CDATA[这几天，下班后在家把《论中国》这本书看完了。这本书我2014年就买了，结果应了那句“书非借不读”，当初买了后，只稍微翻了翻就把它扔在家中某个犄角旮旯里。直到最近，川普选上了美国总统，眼看着中美关系将迎来最大波折，才想起看这本书来。 既然看完了，我就记录下阅后心得，权当作一篇读书笔记，不然，这书跟没读差不多。 作者是美国当代大名鼎鼎的外交家、国际问题专家亨利·基辛格。这本书依据他与四代中国领导人的谈话记录，主要讲述了自从新中国成立后，中美两国领导人之间的相互往来，它试图解释中国人对战争与和平、国家秩序等问题的理性思考，以及这种思考与美国人更为实用的、就事论事的思维方式的关系。 对中国的看法在历史意识中，中国是一个只需复原，而无须创建的既有国家。 中华文明的一个特点是，它似乎没有起点。中华文明不是作为一个传统意义上的民族国家，而是作为一种永恒的自然现象在历史上出现。 中国的光荣孤立在人类历史上独一无二，酝酿了一种独特的自我意识。中国的航海技术曾居世界之首，但并不热衷探险和征服，因而错失了海外扩张的良机。 中国与周边国家的疆界与其说是政治和领土的分界线，不如说是文化差异的分水岭。 中国它从未宣扬过美国式的普世观并借此在世界各地传播自己的一套价值观，而是仅把注意力放在驾驭近邻的蛮夷上。 中国挟其独特的传统和千年养成的优越感步入近代。这个独特的帝国声称它的文化和体制适用于四海，却不屑于去改变异族的宗教信仰；它是世界上最富饶的国家，却对与外国通商和技术革新漠不关心；它文化发达，却受制于一个对西方探险时代的来临一无所知的政治统治集团；它在辽阔的疆土上建立了一套政治体系，却对即将威胁其生存的技术文化大潮茫然无知。 为改变当时中西方交往方式，大英帝国派遣马嘎尔尼使团做了一次最著名、最友善和最不“炫耀武力”的访华努力，目标是取得通商贸易和建立外交关系，但由于东西方观点的巨大分歧，这次访问最终一无所获，结果是中国继续闭关锁国。英国在拿破仑战争结束后暂时休整，没过多久，就以“鸦片输送”这种可耻的借口，凭借着坚船利炮把中国的大门轰开了。中国由此遭受了西方列强一百多年侵略的屈辱史。 眼中毛泽东 尽管毛泽东的许多思想和做法在中国历史中都有迹可寻，但历史上从来没有哪一个执政者能像毛泽东那样集传统、权威、冷峻和全球视角于一身。他面对挑战时咄咄逼人，但当环境不允许他按照自己的心意行动时，他就灵活地转而采用外交技巧。他的外交政策虽然借用传统手法，但是影响宏大，立意大胆。 毛泽东制定外交策略常从中国经典古籍中，即他表面上鄙视的中国传统中汲取灵感。在制定外交政策举措时，他所参考的通常不是马克思主义理论，而是中国的古典著作。他把古代士大夫贬为压迫者和寄生虫，却和他们有着相同的兴致，喜好作诗填词，并对自己豪放的大草书法艺术深以为傲。 毛泽东热衷于搞革命，意识形态挂帅,他的革命理论可以用这这段哲学观点来概括：“不平衡是普遍的客观规律。从不平衡至平衡，又从平衡到不平衡，物质循环不已，永远如此，但是每一循环都进到高的一级。不平衡是经常的、绝对的；平衡是暂时的、相对的。” 这里，我举个最令对手毛骨悚然的例子来说明下毛泽东对革命无畏到何种程度。 1957年，在莫斯科召开的社会主义国家会议上，毛泽东对赫鲁晓夫的“社会主义阵营要努力和资本主义世界和平共处”政策给予了异常尖锐的驳斥，他在会上号召所有社会主义国家拿起武器同帝国主义进行斗争，并再次宣布中国不惧核战争，他声称“我们不要怕原子弹和导弹，无论爆发什么样的战争，常规战或热核战，我们都会胜利，如果帝国主义对中国发动战争，我们也许会受伤，但那又怎么呢？战争嘛，过几年我们会努力生出更多的孩子来”。当时听到他讲完话后，捷克斯洛伐克的共产党总书记说”我们怎么办？我们这个斯洛伐克只有1200万人。打起仗来都得死光，哪有人留下来重新开张？” 眼中周恩来 周恩来是我在六十年来工资生涯中遇到过的最有魅力的人，他个子不高，风度翩翩，目光炯炯，表情丰富，他能以他的超人的智慧和能力压倒谈判对手，能凭直觉猜到对方的心理活动。 他成为了毛泽东与人民群众之间重要的纽带。他把毛泽东的远大理想化为具体计划，同时他还因为给毛泽东的过激之处降温，至少是在毛泽东满腔豪情容许的范围内尽可能这么做，而赢得了很多中国人的感激。 在任何聚会中，毛泽东总是以其气势令举座注目，而周恩来则给人带来光明和温暖。毛泽东的满腔豪情会让反对者慑服，而周恩来会以其智慧力求以理服人和以智取胜。毛泽东说话尖锐犀利，周恩来说话则鞭辟入里。毛泽东喜欢将自己看作哲学家，周恩来则自认擅长行政管理或谈判。毛泽东致力于加快历史前进的速度，周恩来则善于乘时乘势。他常说“舵手必须懂得该怎样驾驭风浪”。 眼中邓小平 在习惯了毛泽东的哲学宏论和形象比喻，以及周恩来儒雅庄重的职业精神之后，面对邓小平言语辛辣、单刀直入的作风，偶尔犀利反讽的插话，不喜欢空谈理论，而习惯着眼于极度实际问题时，我花了相当一段时间才把自己调整过来。 他个子矮小，身体结实，进屋时就像有风力相助，坐下来就直切正题，他很少在寒暄上浪费时间，也觉得没有必要像毛泽东那样以寓言为包装来掩饰锋芒，邓小平不像周恩来那样让你有一种亲切感，也不像毛泽东那样把我视为哲学同道，他的态度是“我们都是为了自己的国事而来，又都是成人，对小小不言的摩擦不该介意”。周恩来有英文基础，偶尔也会说几句，邓小平则自称是土包子。 随着时间的推移，我逐渐对这位眼神忧郁，曾几度大起大落，却仍矢志不移，顾全大局，并在日后逐步振兴中国的强悍的小个子，产生了无比的敬意。 他公开强调中国的落后（长得丑却要打扮得像美人一样，那是不行的），强调中国需要向别国学习，这与中国的皇帝和官员与外国人打交道时表现出来的傲慢形成鲜明对比：没有一个中国统治者对外国人说过需要外国的东西。清廷接受了有限的外国创新，但一贯坚持所有外国人通商是为表现中国的仁善，而非中国所需；毛泽东也高度强调自力更生，即使因此使中国陷入贫穷和孤立。 眼中江泽民 他被普遍认为是过渡性人物，与前辈相比，他没有统帅一切的光环，权力基础也相对较少，他是第一位没有军事资历的中国共产党领导人，像其继任者一样，他的领导能力来源于政治履历和经济业绩。 以前的中共领导人，为人处世带有伟人的光环，既有新型马克思唯物主义的风格，也有中国儒家传统的痕迹，江泽民则不同，它更像一位平易近人的家人，热情而不拘礼节。 就对话风格而言，毛泽东是从奥林匹亚山巅俯视谈话对象，好像面对正在考试的研究生，考察他们的哲学见解恰当与否。周恩来谈话轻松优雅，充满儒家圣人般的智慧。邓小平会打断讨论，直奔主题，视离题寒暄为浪费时间。 江泽民温文尔雅、精力充沛，他时而面带微笑，时而放声大笑，讲逸闻趣事，感染谈话对象，他为自己的外语天赋和西方音乐知识感到自豪，时常为此兴高采烈。接见非华人来访者时，为了强调一个论点，他讲话中经常夹杂着英语、俄语甚至罗马尼亚词句，时而不经意间在大量中国古典成语与美国俗语间转换，如果场合允许，他可能会放声高歌来调节气氛，或者强调同志之间的友情。 中国的战略中国的战略一般有三个特点：精心分析长远趋势，仔细研究战术选择，冷静探讨行动方案。他们的领导人可能会决策失误，但鲜有考虑不周的例子。 中国强盛时，其外交体现为在意识形态上捍卫帝国权力的合理性；衰微时，外交则用来掩盖其弱点，帮助中国利用彼此争斗的各种势力。 西方传统推崇决战决胜，强调英雄壮举，而中国的理念强调巧用计谋及迂回策略，耐心累积相对优势。 中国和西方外交战略的首要区别在于劣势中的自处之道。美国和其他西方国家的外交官认为应谨慎行事，避免挑衅，中国则更倾向于摆出更加无谓的姿态。面对于己不利的力量对比，西方外交官倾向于寻求外交解决，他们敦促采取外交举措，陷对方于不义，以求在道义上孤立对方，但不主张使用武力。中国的战略规划者却更坚定决心用勇气和心理压力来对抗敌人实力上的优势，他们相信先发制人的威慑，若是敌人优势太强，而且战略趋势于己不利时，它们的应对方法是打击敌人的信心。 中国政治家对待结盟的态度：不组成联盟却作为盟国国一起行动，这把现实主义发挥到了极致，如果所有领导人都具有足够的战略眼光、深思熟虑的话，他们都会达成同样的结论，结盟等于多此一举，战略分析的逻辑即足以促使有关国家向同一方向努力。 大多数中国领导人认为中美之间建立正式联盟没有必要，而且总的来说在推行外交政局时还会累赘碍事，他们愿意依靠相互之间的心照不宣。 三角关系毛泽东一直在与苏联竞争意识形态上谁执牛耳和地缘战略分析上谁更正确，这两个社会主义国家因此绝不可能因他们各自对美国的敌意而走到一起。 冷战和核武器的巨大破坏性，在西方催生了“威慑”这一概念，但毛泽东认为西方的威慑可能过于消极，他绝不会让中国被动地等着挨打，而是要争取主动。在某种层面上，和西方先发自人的概念有相似之处，不过根据西方的理念，先发制人的目的，是取得胜利的军事优势，毛泽东先发制人的不同之处在于他对心理因素的高度重视，他先发制人的主要目的不是为了抢先进行决定性打击，而是为了改变双方的心理平衡，不是为了打败敌人，而是为了为了调整他所评估的各种风险。 中国在 1954-1958 年的台海危机中的行动，1962 年和印度的边境冲突，1969-1971 年在乌苏里江与苏联的冲突，以及 1979 年的中越边境之战，都有一个共同的特点：突然实施军事打击，马上继之以政治层面上的动作。 中国式先发制人，一旦遭遇西方的威慑，可能会产生恶性循环，中国自认为是防御性的举动，可能会被西方世界视为侵略性的，而西方的威慑行为则可能被中国解读为对它的包围，在冷战期间，美中两国就此纠缠不休，迄今为止，两国在某种程度上仍未摆脱这个恶性循环。 从传统强权政治的观点来看，中国当然无法和三角关系的美苏两方平起平坐，但是，他把核超级大国之间的敌意为己所用，给外界造成无惧核毁灭的印象，因而为中国谋求了一种外交保障。毛泽东不寻求其中一个超级大国的保护，而是利用美苏彼此的戒惧来同时反抗他们两国。 在冷战的两个关键时刻，中国政治家在军事上敌强我弱的情况下，成功地实施了它进攻性威慑的理念，从而实现其长期的战略大目标。1958 年的台海危机和 1979 年的对越作战，中国领导人都在即将采取行动之前，成功地使外界以为他的行动得到了一个超级大国的同意，从而吓阻另一个超级大国插手干预，把“空城计”运用得如火纯青。 那次事件在改革计划的头十年里，中国除了有成功的狂喜外，还遇到了一些挫折。从计划经济过渡到更大程度的权力下放，始终受到来自两方面的威胁：主张维持现状的既得利益者的抵制、因改革进程缓慢而心急的激进者的压力，以及经济权力下放导致要求政治决策多元化。 中国历史上，尤其是近两百年的历史上，有无数的例子证明，政权的四分五裂，有时是因为对更大自由的极大期待，往往导致社会和族裔的剧烈动荡，而最后胜出的一方往往不是最开明的一派。 在这种背景下，学生并不想对他们晓得是一个危险的政权提出致命的挑战，这一政权也不情愿对学生动武，双方有很多共同的目标，有共同的语言。但由于沟通不畅和错误的判断，各自将对方逼到越来越不可能妥协的境地，有几次似乎马上就找到了解决办法，但最后关头又溜走了。最初滑入灾难的速度似乎很慢，但随着双方分歧的加深，这一速度随之加快，在已知最终结果的今天，重温这一事件给人们带来的震撼不亚于从真正的悲剧中感受到的震撼。 如何谴责他们认为错误的行为并做出适当的反应，与此同时，又保持与中国的接触，即使这种关系必须暂时“搁置起来”，布什总统面对此窘境，可运作的空间也极为有限。布什坚信维护美中关系的长期发展无比重要，但他不能不尊重美国人民的情感，他们要求本国政府以某种具体方式表达他们的不赞成。 中国领导人坚持认为这是内政，美国政府则认为是人权的亵渎。双方都有道理，邓小平感到自己的政权四面受敌，布什则认为美国根本的价值观受到了挑战。 随着东欧剧变，苏联解体，多个共产党政府垮台，中国的改革受到国内动荡和国际压力的双重威胁。邓小平本可轻而易举地靠煽动民族主义感情去号召本国人民，但他没有这样做，而是求助于古老的价值观。邓小平给他的接班人和下一代领导人留下 24 字工作指示。 中美分歧中国领导人主张独立自主，不干涉他国内政不向国外传播意识形态，而美国坚持通过施压和激励来实现价值观的普适性，也就是要干涉别国的内政。 美国自建国以来笃信自己的理想具有普世价值，声称自己有义务传播这些理想，这一信念常常成为美国的驱动力。中国行为的依据是其独特性，它通过文化渗透而非传教狂热来扩大影响。 与美国打交道的国家需要懂得：美国对事物的判断，永远不可能与美国对民主制度的看法分开，有些事件必然会引起美国的反应，即使会损害总体关系也在所不惜。 在某些事件面前，美国的外交政策会超出对国家利益的考虑，没有任何一个美国总统可以对这类事情视而不见，但在界定这些事情是他必须小心谨慎，而且要知道意外后果的要义。任何一位外国领导人都不应对此不屑一顾，如何界定这类事件并建立平衡，将决定美国对华关系的性质，可能也将决定世界的和平。 对中国而言，美国太强大难以胁迫，而且致力于与中国发展建设性关系，中国也需要这种关系，超级大国美国、充满活力的中国，全球化的世界，以及世界事务重心逐渐从大西洋向太平洋转移，都需要一个和平合作的中美关系。但他们不能控制两国相互撞击的方式，这是中美关系中尚未解决的挑战。 进入 21 世纪以来，中国与现代西方国际体系的碰撞，在中国精英中间引发放了一个特殊趋势，他们全面的分析、辩论国家命运及其实现之道。以前的国家命运辩论讨论的是，中国是应该向外寻求知识以摆脱虚弱，还是应该眼光向内已远离技术先进但动机不纯的世界，而当前阶段辩论的重点则是，在认识到自立自强的伟大工程迈向成功，中国正在赶超西方的大背景下，确定中国与世界交往的条件。 历史会重演吗？21 世纪中美关系的预兆，和 20 世纪英德两国对抗的史例，看起来有战略相似性。 19 世纪末期，英德两国对抗是如何演进的？导致一战的危机是起因于德国崛起，引起了针对新的强大力量的某种有组织对抗，还是源于德国采取的一些具体的，因而也是可以避免的政策？危机是源于德国的能力还是德国的行为？ 克劳这样分析英国对德关系：不管德国崛起的目的是什么，是否显示足够的友好态度。其实德国崛起本身，就必然损害英国的利益。所以只要德国还在崛起中，对德国的外交围堵就必须加紧进行，这是零和博弈。换句话说，德国在一战前失去外交的灵活性，是德国国力不断增强必然导致英国的反制，与德国是否足够友好无关。 因此，克劳学派会认为中国的成功崛起与美国在太平洋乃至全世界的地位无法相容。 克劳学派把国际事务解读为不可避免的战略优势争夺，这种分析方式不仅限于西方的战略家，中国的必胜主义者运用了几乎是同样的推论。 基辛格不同意这类学派的看法，他的看法如下： 不同历史时期之间的比较重，本质上而言是不正确的，甚至最精确的类比，也不意味着当代人一定会重复前人的覆辙。 中美关系不必也不应成为零和博弈。重要的国际问题，在本质上是全球性的，达成共识可能非常困难等，但在这些问题上挑起对抗是自寻失败。 两个主角的内部演变与一战之前的形势也无法类比。 一个面对如此庞大国内任务的崛起国家，不太可能轻易投身于战略对抗或追求世界主导地位，大规模杀伤性武器的存在，再加上最终后果无法预知的现代军事技术，决定了今天与一战之前的时期明显不同。 基辛格认为，中美两国之间的决定性竞争，更可能是经济竞争，社会竞争，而不是军事竞争。中国和美国既合作又竞争，在许多方面共同发展。 尽管两国的出发点迥异，八位美国总统和四代中国领导人在处理微妙的双边关系时，却显示了惊人的连贯性，双方始终尽力维护这一实质性的合作关系，使之不受历史纠葛和各自国内问题的干扰。 中美关系的恰当表述应该是“共同进化”，而不是“伙伴关系”，这意味着两国都注重国内必须做的事情，在可能的领域开展合作，调整关系，减少冲突。任何一方都不完全赞同对方的目标，也不假定利益完全一致，但双方都努力寻找和发展相互补充的利益。 他呼吁建立太平洋共同体，中美彼此之间，以及和其他参加国家在其中拥有建设性关系。 亚洲，甚至世界的未来，将在很大程度上取决于中国和美国的远见，以及两国在多大程度上认同对方的地区历史角色。 1972 年，基辛格作为尼克松总统的特使秘密访华，周恩来总理和他就宣布中美联合公报达成一致时曾说“这将震撼世界”，在新世纪格局下，倘若中美两国能同心协力建设世界，而不是震惊世界，那将是何等大的成就？ 后记总的来说，这本正文有 500（除去文献引用的 100 多页）多页的大块头书，内容流畅而迷人，有历史细节，也有回忆反思，最重要的是对中国外交政策的前提、方法和目标做出了透彻审视。 看完这本书，你会比 95% 的中国人更懂中国。]]></content>
      <categories>
        <category>心旷神怡</category>
      </categories>
      <tags>
        <tag>看中国</tag>
        <tag>基辛格</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《半场无战事》观影]]></title>
    <url>%2F2016%2F11%2F12%2FBilly-Lynn's-Long-Halftime-Walk%2F</url>
    <content type="text"><![CDATA[「因为人生中最糟的一天而受到表彰，确实有点奇怪」，影片开门见山地点明了宗旨。 那 3 分 43 秒对林恩来说是最悲惨的回忆，班长中枪身亡，自己和敌人贴身肉搏，眼睁睁看着敌人被他用匕首插进心脏，双眼崩裂，血浆满地，窒息而亡。 班长的死，让他心痛；敌人的死，让他恐惧。战场的残酷无情给他造成了巨大的生理和心灵震撼，以至于他在家里听到母亲呵斥他姐姐时怒拍桌子的声音，都会歇斯底里地抽搐。 他不想再去回忆那悲惨的一天，他努力想寻求到认同感，不想再去感受那段心灵的痛创，然而，回到家后，他面临的却是一段段滑稽和无奈。 他的家人骄傲于整条街的人都在谈论他是个英雄；经纪人只想用他们的故事拍电影，大赚一笔；球场里那些工作人员、导演、球队老板表面拿他们当英雄，实际在赤裸裸地拿他们当工具；他最亲密的姐姐觉得是由于自己的原因，他才会被迫去伊拉克参军，想尽办法让他留下来。 所有人都在问林恩那一天发生的事情，有记者问他当时的体会，林恩无法躲避，只得无奈地向演出负责人要头痛药💊 也许看透了半场秀这样一个虚伪盛大的假象，或许是人们只在乎他们对所谓英雄主义的投射，无法体会军人本身在战场上的切身感受，这种错位和反差，最终让林恩和他的战友们重返战场，回到那个他们称作为家的地方。 由于大陆目前只在北京和上海有两家 120 帧的放映设备，很想体验下120帧每秒是什么样观影效果。 所以，要不去魔都再看一遍？]]></content>
      <categories>
        <category>心旷神怡</category>
      </categories>
      <tags>
        <tag>李安</tag>
        <tag>比利·林恩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我作为一个地产商怎么把我选到白宫去了]]></title>
    <url>%2F2016%2F11%2F09%2FTrump-White-House%2F</url>
    <content type="text"><![CDATA[那么人呐就都不知道，自己就不可以预料。 一个人的命运啊，当然要靠自我奋斗，但是也要考虑到历史的行程。 我绝对不知道，我作为一个纽约的地产商，怎么就把我选到白宫去了，所以奥巴马同志跟我讲话，说「选民都决定啦，你来当总统」。 我说另请高明吧，我实在也不是谦虚，「我一个地产商人怎么跑到白宫来了呢」？ 但是呢，巴马同志讲「大家已经研究撅腚了」。 所以，后来我就念了两首诗，叫「苟利国家生死以，岂因祸福避趋之」。 那么所以，我就到了白宫…… 至于到了白宫之后的事，你问我，我只能对你说「无可奉告」。 作为美利坚的总统，我当然不会疯狂到去按核武器按钮，不过大家可以等着看我的四年计划哦～ 且看我怎么让墨西哥出钱建高墙，把2千万非法移民全都赶跑，禁止穆斯林入境，全歼伊斯兰国，撕毁巴黎协议，降税15%，让美国经济增长率追上中国，和中国打贸易战，推翻奥巴马医保，推翻平权法案，禁止人工流产，把希拉里关起来…… 一想起这些，我这年过 70 的老翁都禁不住感到 very excited！ 希拉里老妹，你也别那么沮丧。虽然你输了总统大位，我为你同情，不过你想开点，往后四年，你不必在你老公曾经出轨过的那个恶心的办公室工作，你应该感到庆幸才是，蛤蛤。]]></content>
      <categories>
        <category>一颗赛艇</category>
      </categories>
      <tags>
        <tag>川普</tag>
        <tag>总统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《釜山行》的丧尸之膜]]></title>
    <url>%2F2016%2F09%2F26%2FTrain-to-Busan%2F</url>
    <content type="text"><![CDATA[最近，电影《釜山行》韩语中字版在朋友圈热传后，网上是一阵阵的好评如潮，尤其是著名相声演员于谦因在此片中饰演那个胖大叔而一炮走红。 要说这个胖大叔，其实人家真名叫马东锡，你要是韩片看得够多的话，会发现他经常出没在韩影出演配角，比如我看过的评价不错的就有惊悚片《邻居》、犯罪片《不当交易》《与犯罪的斗争》《罪恶的编年史》、古装动作片《群盗》等。 既然说了他，就不能不说主演孔侑了。这位又高又帅韩国实力派美男，他主演的《熔炉》豆瓣评分高达9.1分，值得每一个标榜自己喜欢韩国电影的有志青年去仔细体会。 《熔炉》揭露学校性侵暴力毕竟太过深沉，我更想说一下他主演的另一部爽快的动作片《嫌疑者》。 作为《谍影重重》的首席学徒，此片可谓青出于蓝而胜于蓝。 赤身搏斗戏、巷战、飙车大战，都流畅得不得了，近身格斗招招凌厉，眼花缭乱的剪辑玩的如火纯青，加上鼓点急促的配乐元素，观者无不看后大呼过瘾。其燃爆程度近年来看，唯有《疯狂的麦克斯4》可与之匹敌。 回过头来说《釜山行》，网上都说是 8分好评，我看这片也值这个评价，这也是韩国恐怖片正常发挥的水准。 为什么值8分呢？除了特效牛逼，剧情紧凑，人物性格突出外，还有一个最重要的原因：丧尸题材拍出了人性的高度。 跟《行至走肉》的主题类似，杀到最后，人类不是和丧尸斗争，而是和你身边的人搏斗，为了争取可怜的生存空间，自私、猜疑、孤立，相煎何太急…… 更让我 excited 的是：影片看到最后，导演也不忘来膜一把。 too young 的小白可能会问：膜在哪里？ 1997年长者访美第一站夏威夷州，与州长会晤时，会场外有大量抗议者用高音喇叭抗议，这虽然不是美国政府的安排，但估计也是得到了当局默许，人家正准备看长者的笑话呢。 长者什么场面没见识过？且看他如何化解。长者想起了自己民国大学时期学过夏威夷吉他，于是即兴演奏了一曲《Hello Hawaii》，并邀请州长夫人演唱，有效地缓解了会场尴尬的气氛，博得了会场嘉宾们好几百人的一致好评。 在《釜山行》结尾，历经生死磨难，列车上仅剩的一个孕妇和一个小女孩相互搀扶着走出隧道，外面伏击待命的士兵正准备开枪，突然听到了这首韩语版的《Aloha Oe》，马上下令「生存者，接近中」，全片终！ 红衣女孩高唱《Aloha Oe》得以续命，其他所有人的命都被贡献出来了，这才是本片的核心。 《Aloha Oe》，续命神曲，当之无愧啊。 现在知道导演膜力深厚了吧？]]></content>
      <categories>
        <category>一颗赛艇</category>
      </categories>
      <tags>
        <tag>釜山行</tag>
        <tag>孔侑</tag>
        <tag>续命</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你国轰轰烈烈G20 我杭闷声放长假]]></title>
    <url>%2F2016%2F09%2F01%2FHangzhou-holiday-on-G20%2F</url>
    <content type="text"><![CDATA[峰会在即，杭州全城都很激动，为了给全世界各国领导人留下一个安全、干净、舒畅的开会环境，我市9月1号到7号休假，把普通老百姓全给欢送出城了。 工厂歇业、店铺全关、道路畅通一改往日拥堵之旧貌……当是时，天时地利人和，徐嘉诰老先生研究了几十年的《天气晴朗学》在此举世瞩目的峰会到来期发挥了重要作用： 本来天气预报说这几天有雨，结果这G20一来啊，阳光明媚，你看，万里乌云的天空下还飘着朵朵蓝翔。 为了办好这届G20峰会，杭州普通市民的出行受到了不同程度的影响。 晚饭后去超市买盒牛奶打算早上喝，一路上，超市保安、公交司机、警察、小区门卫各让喝一口，早餐奶就这样全喝完了。 汽车后备箱里放箱红酒，安检要求每瓶喝一口。喝了后准备回家，刚启动车子，警察不让走说酒后驾车了。 你要问我滋词不滋词G20放假？我说滋词，我就明确告诉你这点。一年过两个国庆长假，有什么不好吗？ 但是，你一定要问我「你杭举全市之物力，接与列国之欢心」，这是不是在搞面子工程？ 没有任何这个意思。加强安保工作，是历届G20峰会的国际惯例。 我告诉你，我是身经百战，见得多了，西方国家的哪个峰会我没去过？人家比我们的严得不知道哪里去了。 2009年英国伦敦G20峰会，当地政府关闭了连接主会场的轻轨站，封堵附近道路，仅开放人行道供当地须出示有效身份证件的居民出入，并严格进行安检。 2010年韩国首尔G20峰会，采用“无车日”和“错峰限行”等多项交通管制措施，数以万计的士兵驻守在重要公共设施附近以及山区；在地铁站等大型公共场所部署了特种部队，车站寄存柜暂时封闭，垃圾箱被换成透明容器。 2011年法国戛纳G20峰会，当时法国海陆空三军总动员,安排拆弹专家排查码头或游艇，元首入住酒店安放防暴犬和监察设备，机场也进行空中警戒安保；戛纳当地学校停课，周围所有建筑禁止开窗。 2013年俄罗斯圣彼得堡G20峰会，安保严格到连宠物狗都登记了。…… 同其他各国相比，杭州G20峰会的安保投入并不夸张。我们的精神是：没有最严，只有更严。严防死守，滴水不漏！ 国进民退，闷声放长假，这是坠吼滴。]]></content>
      <categories>
        <category>一颗赛艇</category>
      </categories>
      <tags>
        <tag>G20</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我承诺会给你一个美好的未来]]></title>
    <url>%2F2016%2F08%2F30%2FI-promise-you-a-good-future%2F</url>
    <content type="text"><![CDATA[在以往的 C++98 中，多线程并行开发并不是那么容易的：你得小心翼翼地处理好「线程、锁、条件变量」的三角关系才能弄出个像样的多线程程序出来。 C++11 提供了 future 和 promise 来简化不同线程间的异步操作： 当一个任务需要向父线程（启动它的线程）返回值时，它把这个值放到 promise 中，之后，这个返回值会出现在和此 promise 关联的 future 中，于是父线程就能读到返回值。 在这种机制里，你只需要一个执行任务的线程，而不必再显示地使用其它的什么锁、条件变量等语义。 future从字面意思看，它表示「未来」，通常我们不能立即获取到异步操作的执行结果，只能在未来某个时候获取。 一个有效的 future 对象通常由以下三种 provider 创建，并和某个共享状态相关联。 async 函数 promise::get_future packaged_task::get_future 我们可以通过查询 future 的状态（future_status）来获取异步操作的结果。 future_status 有三种状态： deferred：异步操作还没开始 ready：异步操作已经完成 timeout：异步操作超时 获取 future 结果有三种方式： get 等待异步操作结束并返回结果 wait 只是等待异步操作完成，没有返回值 wait_for 超时等待返回结果 promisepromise 是个范型对象，可保存 T 类型的值，该值可被 future 对象在将来某个时刻读取。在构造 promise 时，promise 对象可以与共享状态关联起来，这个共享状态可以存储一个 T 类型或者一个由 std::exception 派生出的类的值，并可以通过 get_future 来获取与 promise 对象关联的对象，调用该函数之后，两个对象共享相同的共享状态(shared state)。 promise 对象是异步 provider，它可以在某一时刻设置共享状态的值。 future 对象可以返回共享状态的值，或者在必要的情况下阻塞调用者并等待共享状态标识变为 ready，然后才能获取共享状态的值。 12345678910111213141516171819#include &lt;iostream&gt; #include &lt;functional&gt; #include &lt;thread&gt; #include &lt;future&gt; void print_int(std::future&lt;int&gt;&amp; fut) &#123; int x = fut.get(); std::cout &lt;&lt; "value: " &lt;&lt; x &lt;&lt; '\n'; &#125;int main ()&#123; std::promise&lt;int&gt; prom; std::future&lt;int&gt; fut = prom.get_future(); std::thread t(print_int, std::ref(fut)); prom.set_value(10); t.join(); return 0;&#125; packaged_taskpackaged_task 和 promise 在某种程度上有点像，只不过 promise 保存了一个共享状态的值，而 packaged_task 保存的是一个可调用对象。 它包含了两个最基本元素： 被包装的任务(stored task)，一个可调用的对象，如函数指针、成员函数指针或者函数对象。 共享状态(shared state)，用于保存任务的返回值，可以通过 future 对象来达到异步访问共享状态的效果。 1234std::packaged_task&lt;int()&gt; task([]()&#123; return 7; &#125;);std::thread t1(std::ref(task)); std::future&lt;int&gt; f1 = task.get_future(); auto r1 = f1.get(); promise &amp; future &amp; packaged_taskpromise 和 packged_task 都是异步 provider，都可以在将来某个时候设置与其关联的共享状态的值，它们内部都关联了一个 future 来异步访问共享状态的值。 稍微有点不同的是 packaged_task 包装的是一个异步操作、具体任务的返回值；而 promise 包装的是一个明确的、具体的值。 我的体会是： 需要直接读取线程函数中的某个值，就用 promise，需要获取异步操作的返回值，就用 packaged_task。 就这点细微的区别，我想用人类的语言解释一下。 比如，一个小伙子给一个姑娘表白真心的时候可能会说：「我承诺会给你一个美好的未来」或者「我会努力奋斗为你创造一个美好的未来」。 姑娘往往会说：「我等着」。 这三句话翻译成 C++11 语言就是： 小伙子说：「我承诺会给你一个美好的未来」等于 C++11 中 promise a future; 小伙子说：「我会努力奋斗为你创造一个美好的未来」等于 C++11 中 packaged_task a future; 姑娘梨花带雨地说：「我等着」等于 C++11 中 future.get()/wait(); 小伙子两句话中的差异，自己琢磨一下，就是 promise 和 packaged_task 的差异，只可意会，不可言传吧。 现实中的山盟海誓靠不靠得住我不知道，但是 C++11 中的承诺和未来是一定可靠的，发起来了承诺就一定有未来，不管这个承诺是成功履行了（ready）或者出现了其它变故（exception）。 异步首选：asyncC++11 还提供了异步接口 async，它会自动创建一个线程去执行线程函数，返回一个 future，这个 future 中存储了线程函数的返回值。 async 使我们可以在不显示调用线程的情况下就实现异步操作，获取异步执行状态和结果，真是 so easy，另外，它还提供了两种线程的创建策略。 1async(std::launch::async | std::launch::deferred, f, args...) std::launch::async：调用就开始创建线程，默认策略。 std::launch::deferred：延迟加载方式，调用时不创建线程，直到调用了 future 的 get 或者 wait 时才创建线程。 12345678910111213141516171819202122#include &lt;iostream&gt; #include &lt;future&gt; // a non-optimized way of checking for prime numbersbool is_prime (int x) &#123; std::cout &lt;&lt; "Calculating. Please, wait...\n"; for (int i=2; i&lt;x; ++i) if (x%i==0) return false; return true;&#125;int main ()&#123; std::future&lt;bool&gt; fut = std::async (std::launch::deferred, is_prime, 313222313); std::cout &lt;&lt; "Checking whether 313222313 is prime.\n"; bool ret = fut.get(); // waits for is_prime to return if (ret) std::cout &lt;&lt; "It is prime!\n"; else std::cout &lt;&lt; "It is not prime.\n"; return 0;&#125; 总结C++11 本身提供了统一的跨平台的线程语法，在此基础上，future 和 promise、packged_task、async 进一步地简化了线程的异步操作，使得程序员从以前的多线程噩梦中解脱出来，而将更多的注意力放在具体的业务逻辑上，这是生产力的巨大进步。]]></content>
      <categories>
        <category>Coder</category>
      </categories>
      <tags>
        <tag>C++11</tag>
        <tag>future</tag>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[女排夺冠困扰我的两大难题]]></title>
    <url>%2F2016%2F08%2F21%2Fwomen's-volleyball-champion%2F</url>
    <content type="text"><![CDATA[今天早上的这场女排决赛，燃爆了，据路边社报道，国内收视率一度达到 58.7%，而湖南卫视、江苏卫视、浙江卫视还不及其十分之一，足见国人对女排的热情，其盛况不亚于巴西人万人空巷地看奥运男足。 我们的乒乓球号称「国球」，是因为它有着悠久的历史和辉煌的战绩，6届奥运会的24枚金牌，我们霸气地拿下了23枚；如果说我们国家有「母球」的话，我想，女排当之无愧。 从1984到2004，从2004到2016，中间虽然历经磨难，饱受摧残，依然本色不改：团结、拼搏，是她们一以贯之地优良传统，不像某些队那样…… 三大球中，也就女排最争气了。 1国内主流媒体的报道基本上是说，这次女排能夺冠，靠的就是「不畏强敌、团结协作、自强不息」的女排精神。 作为一个无神论者，我是不相信单纯依靠精神的力量就可以取胜的，何况我们的对手里面有巴西、美国、俄罗斯等老牌强劲对手以及塞尔维亚这样的后起之秀。 女排精神，固不可丢，这也是女排一路走来不断创造辉煌的主观因素。 倘若我们只谈情怀，避谈技术，就跟愤青没什么区别了。赛场上只有你争我夺的实力较量，要发得起有力的进攻，同时扛得住对手的进攻，精神力量只能起到辅助、催化、刺激的作用。 在精神层面，我们常看到自由人、接应凭借顽强的毅力去挽救那些几乎不可能救回的高难度球。 在技术层面，我们看到主攻、副攻借过硬的实力进攻屡屡得分。 2此番里约夺冠，郎平指导功不可没。 郎平用人很准，能充分地发挥出每位队员的特长，并及时地根据对手节奏的变化有针对性地进行战术调整。 在刻苦训练、顽强拼搏的基础上，郎平将国际化、专业化的团队合作形式和科学训练的理念引入中国女排，使得女排这么一支年轻的队伍，经过两三年训练就能脱胎换骨，斩获佳绩。 因此，可以这么说，郎平给中国女排实现了三个现代化：技术化、专业化、科学化，这才是女排继2015年夺得世界杯冠军后又荣获奥运冠军的根本原因。 反观国羽，固步自封，不求变化，对手都把它研究透了，它还躺在往日的成绩薄中不可自拔。短短4年，从伦敦奥运包揽5金，到这届奥运会连丢3金，问题都出在自己身上。 3这届奥运会女排的前三甲，还有段难以释怀的历史。「17 年前，季军轰炸了冠军在亚军的大使馆」。 长者在接受华莱士记者的采访中，谈到了此事，长者说： In the 1989 disturbance, we truly understand the passion of students recalling for democracy and freedom.In fact, we’ve been always working to improve our system of democracy, but we could not possibly allow people with ulterior motive to use students to overthrow the government under the pretest of democracy and freedom. 华莱士追问道： Did a part of you admire his courage? 长者机智地笑了，说： I know what you are driving at, but what I want to emphasize is that we fully respect every citizens’ right to freely express his wishes and desires, but I don’t favor any opposition to government actions during emergency. 华莱士提到了南斯拉夫大使馆问题，问：「你说是美国故意轰炸南斯拉夫大使馆？」 长者笑了，回问华莱士：「Did a part of you believe it?」 华莱士愣了，没敢回答。长者说，这个问题应该由你们美国回答，你们的武器很先进，出了这种问题，你们应该急着去找原因，克林顿已经多次道歉了…… 4最后，有两个问题还在困扰着我： 谁能告诉我塞尔维亚女排 19 号的微信号？ 求塞尔维亚女排教练同款口香糖？]]></content>
      <categories>
        <category>心旷神怡</category>
        <category>一颗赛艇</category>
      </categories>
      <tags>
        <tag>奥运</tag>
        <tag>女排</tag>
        <tag>塞尔维亚</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[公众号最后一日：一场重命名风波]]></title>
    <url>%2F2016%2F08%2F19%2Frename-wechat-public-account%2F</url>
    <content type="text"><![CDATA[今天副组长魏武挥在朋友圈发图说公众号可以改名了。 这可是个天大的好消息啊，想当年，小明注册这个公众号，用脚趾头想了个不伦不类的「我为朝露谁苦多」。说实话，这名字不押韵，不好记，坠痛苦的还是；那些纯情的女孩子，还没关注就被「譬如朝露，去日苦多」这股猥琐的气质给吓跑了。 后来，我一直寻思着想换个名字，但是霸道的公众平台一直不开放修改公众号名字的权限，这给我的自媒体声誉造成了不可估量的损失。 这让我不由得想起了那句老话，「时间对于爱耍小聪明的人是最无情的」。你觉得抖了个机灵，在别人眼里，也许就是逗逼犯傻。 比如，歌坛重量级人物刘欢，给女儿取名：「刘一丝」，说起这个奇怪的名字，一帮看热闹不嫌事大的记者围着他惊讶地问「取这个名字有什么寓意吗？」 刘欢很得意，哈哈狞笑道「这你们就不知道了吧。一丝来自成语一丝不挂，是佛家用语，指的是灵台清净、四大皆空、心里没有一丝尘世的牵挂，这叫一丝不挂，讲的是心境，是很高的修行啊」。 记者一脸懵逼，强拧着脸上的肌肉和刘欢笑成一团，「妈的，这个笨蛋想一丝不挂，自己姓刘又他妈忘了，居然还给女儿留了一丝……」 这就是卖弄学问、弄巧成拙的例子。 王朔有一句体谅人情世故的话，说的特别好： 父母给子女取名字时一时的不谨慎，给孩子造成的是终生的心灵痛苦。 我们上学的时候，但凡名字有点歧义、邪义的家伙，都被身边无情的小伙伴残忍地修理。 据说刘欢女儿现在还叫「刘一丝」，希望她过得快乐吧。 好罢，讲了这么多，无非说取名不可儿戏，要慎重。毕竟这个公号是我一手带大的，充满了感情，于是，我在朋友圈里咨询重命名。 某蛤丝怂恿我改名「黄续忠」，我当即就喷了一脸盐汽水回去「什么续命，尽放狗屁!」，没想到这厮又给我顶了一句「一派胡言，非常气愤！」……两枚蛤丝就这个「续」字膜得不可开交。 赛艇中纪委一贯督促蛤丝们不要武膜，要文膜。暴力膜谁不会啊，蔡英文、卡梅伦、布冯，哪个不是被我膜得栩栩如生？！naive。 思来想去，觉得还是叫本尊真名坠好，从明天开始，这个公众号名字就正式改为：「黄学忠」，算是小明行走江湖的另一个 ID 吧。 很惭愧，就做了点微小的贡献，谢谢大家。]]></content>
      <categories>
        <category>一颗赛艇</category>
      </categories>
      <tags>
        <tag>微信</tag>
        <tag>刘一丝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[平常心造就「一颗赛艇」]]></title>
    <url>%2F2016%2F08%2F15%2Fnormal-heart-makes-exciting%2F</url>
    <content type="text"><![CDATA[在刚刚结束的里约奥运会羽毛球男双 1/4 决赛当中，中国组合张楠/傅海峰为球迷奉献了一场酐畅淋漓的大逆转： 在首局失利，决胜局大比分落后的情况下，还能顽强取胜，以 2-1战胜韩国组合，晋级半决赛。 小明正好观看了整场比赛的直播，真是 excited！中国队组合“玩的就是心跳”，在三局比赛中，他们都是一开始大比分落后，被韩国队虐得满地找球。 可能由于是在当地时间早上比赛，两位队员还没睡醒？第一局完全不在状态，没有打出原奥运冠军的水准，11-21 狼狈收场。 第二局，开始也打的不好，中国队几乎是复制了第一局，韩国队一度 5-1 领先。然而最凶险的时刻还是在这局的尾声，在韩国队 18-16 领先的时候，傅海峰与张楠终于睡狮猛醒，一下子狂砍 5 分，以 21-18 拿下非常关键的一局。 第三局，就更有意思了。一上来，中国队还是大比分落后，8－15……我都看到韩国队那边开始准备庆祝胜利了。中国队苦追，最后韩国队 20-17 拿到三个赛点。关键时候，傅海峰与张楠毫不手软，一直将比分追平。 在 21-21 之时，中国队突然发了一个后场球，成功地打了韩国队一个措手不及，对手即便跪倒在地也没能将球救回来，中国队在心理上给了对手致命一击。 置之死地而后生，韩国队真是拿这对打不死的小强没辙了，垂头丧气地，连爬都没力气了，蛤蛤～ 最终，中国组合一鼓作气，以 24-22 拿下对手，韩国教练无奈地低下了头。 决胜盘大比分落后，我怎么也想不到中国队最终能拿下这场比赛。逆转靠的是什么？心理。赛后，傅海峰接受记者采访说： 我们场上比他们做的好的就是关键分的处理。我们都是奥运冠军，相信我们的实力。比赛，后半段他们慌了。一开始我们不行，后半段他们不行，这就是奥运会的魅力。 作为奥运会参赛选手们而言，他们能代表国家登上这个舞台，本身就是一种成功，只要放下思想包袱，全力以赴，输赢其实真的没那么重要。 韩国选手输了，输在求胜心切；中国选手赢了，赢在心态和拼搏劲。 第一局输后，中国队往后打得没有什么心理压力： 反正我们都输了，无所谓，就当输的来打，反而对手表现得越来越紧，非常想赢球，反而丢了这局。 这是一场精彩的比赛。]]></content>
      <categories>
        <category>一颗赛艇</category>
      </categories>
      <tags>
        <tag>奥运</tag>
        <tag>羽毛球</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从「王宝强事件」学人生经验]]></title>
    <url>%2F2016%2F08%2F14%2Flife-experience-on-Wang-Baoqiang%2F</url>
    <content type="text"><![CDATA[突然从傅园慧的「洪荒之力」这股清流风刮到王宝强的半夜离婚声明，小明明显感觉不太适应。 你要问我对「宝宝妻子出轨经纪人」这事怎么看？我只能说四个字：「无可奉告」。 作为新时代理性的网民，你们千万要记着，「不要见得风，就是雨」，看到这些消息，你们本身也要判断，像那些明显是无中生有的东西，比如那几个冒充注册的小号说什么「告诉你，我们还3P了」、「王宝强家暴」之类的谣言，你再帮它传播一遍，你等于……你也有责任的对吧？ 你们啊，还是要提高自己的姿势水平，识得唔识得？哎！我真是为你们感到捉急啊，你们有一个好，网上有什么热点，你们跑的比香港记者还快，这次你们跑到人家微博去问候人家父母，结果走错地方，把乒乓球运动员宋喆同学骂了一遍，瞧你们这副德行，还是图样图森破，上台拿衣服。 今天我看你们这么热情，一句话不说也不好，我跟你讲，我是身经百战，见得多了：文章出轨、黄海波嫖娼、谢霆锋离婚……哪个我没见识过？ 如果你一定要问我滋词不滋词王宝强这个声明，我是滋词的，我就明确告诉你这一点。老婆出轨了，他根据婚姻基本法提出离婚，有什么问题吗？ 我很抱歉，我今天是作为一个过来人跟你们讲，我有必要给你们传授一点人生的经验，李笑来老师在《通往财富自由之路》书中说： 人生中浪费生命、虚掷光阴、永陷贫穷的三大坑： 莫名其妙地凑热闹 心急火燎地随大流 操碎了别人的心肝]]></content>
      <categories>
        <category>一颗赛艇</category>
      </categories>
      <tags>
        <tag>王宝强离婚</tag>
        <tag>出轨</tag>
        <tag>李笑来</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写给女儿]]></title>
    <url>%2F2016%2F08%2F09%2FTo-my-daughter%2F</url>
    <content type="text"><![CDATA[女儿，今天是你来到这世间的第 20 天。 前天，爸爸结束了 15 天的陪产假，不舍地暂别了你和妈妈。这两天，我都止不住地想念你们母女。 你出生的时候，我还在焦急地赶高铁回家，从杭州到郴州，一千二百多公里，每一里都仿佛是你妈妈分娩你的痛。 终于，2016 年 7 月 22 日，下午一点零三分，你出生了。 微信上你妈妈发来你刚出生时的照片：肤色很白，眼睛睁得很大，好奇地向四周瞅，都说像极了你爸我。 你出生之前，不仅妈妈、奶奶，还有七大姑八大姨，都说你会是一个男孩儿，我们都给你取好了名字叫「黄泽轩」，等你出生，发现是个女孩，爸爸妈妈都觉得 「xuanxuan」这个小名蛮好听的，于是，取一个适用于女孩的「瑄」，就叫你「黄泽瑄」好啦。 黄泽瑄，你在妈妈肚子里的时候可调皮了。有时，你踢妈妈肚子弄得妈妈都没法睡好觉，有时，爸爸给你讲故事，你也会紧贴着肚皮滑来滑去，好像迫不及待地要出来和爸爸打招呼似的。 那天，爸爸刚赶到医院，轻轻地抚摸你的小手，刚刚还在哭闹的你马上就把爸爸的手指握在手心，一副安详的样子。 你回到家里后，亲朋好友都说你长得真标致，白净，乖巧，眉清目秀。以至于你爸这个伪文艺青年我也不吝用这样的文字来形容我的小情人： 片刻的举手投足让你妩媚丛生，刹那的眼神游离让你倾国倾城。 都说女儿是爸爸上辈子的情人，我的小情人啊，你和你妈妈，就是爸爸这辈子最牵挂的人啦。爸爸会好好疼爱你们、保护你们，让你们母女活得自在，自然，自由。 小情人，让我们一起长大，你学着走路和说话，我学着成为一个爸爸。 爸爸，要做到的是，不让你们有什么经济压力，因此，「我要努力成为一个富裕的老爸」。]]></content>
      <categories>
        <category>黄泽瑄</category>
      </categories>
      <tags>
        <tag>女儿</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表驱动｜码农的豹变]]></title>
    <url>%2F2016%2F07%2F14%2Ftable-driven%2F</url>
    <content type="text"><![CDATA[今天不知道怎么滴，歪打正着地闯入到陈硕写于 2005年的一篇 CSDN 博客 ，文末，这厮扬言： 是否掌握表驱动技术是划分初级程序员和高级程序员的重要分水岭之一。 表驱动是个什么鬼？说的好腻害的样子。既然老司机传授如此热心地私家秘籍，作为一个求知欲和毛发一样旺盛的初级码农，小明开始了这一趟求学之旅。 新姿势 get，在此记录下心得。 What表驱动方法（Table-Driven Methods），在《Unix 编程艺术》中有提到，《代码大全》的第十八章对此进行了详细地讲解。 表驱动法是一种从表里查找信息而不是使用逻辑语句（if或switch）的编程模型。 Why先通过一个简单的例子体验下，在某些情况下，如果不使用表驱动方法，代码会如何地难看。 假设让你实现一个返回每个月天数的函数（为简单起见不考虑闰年）。 初级码农的笨方法是马上摆出 12 副威武雄壮的 if-else 组合拳： 1234567891011121314151617181920int iGetMonthDays(int iMonth)&#123; int iDays; if(1 == iMonth) &#123;iDays = 31;&#125; else if(2 == iMonth) &#123;iDays = 28;&#125; else if(3 == iMonth) &#123;iDays = 31;&#125; else if(4 == iMonth) &#123;iDays = 30;&#125; else if(5 == iMonth) &#123;iDays = 31;&#125; else if(6 == iMonth) &#123;iDays = 30;&#125; else if(7 == iMonth) &#123;iDays = 31;&#125; else if(8 == iMonth) &#123;iDays = 31;&#125; else if(9 == iMonth) &#123;iDays = 30;&#125; else if(10 == iMonth) &#123;iDays = 31;&#125; else if(11 == iMonth) &#123;iDays = 30;&#125; else if(12 == iMonth) &#123;iDays = 31;&#125; return iDays;&#125;` 稍微机灵点的码农发现每月天数无外乎 28、30、31 三种，或许会用 switch-case “裁剪”下： 12345678910111213141516171819202122int iGetMonthDays(int iMonth)&#123; int iDays; switch (iMonth) &#123; case 1: case 3: case 5: case 7: case 8: case 10: case 12:&#123;iDays = 31;break;&#125; case 2:&#123;iDays = 28;break;&#125; case 4: case 6: case 9: case 11:&#123;iDays = 30;break;&#125; &#125; return iDays;&#125;` 这两种方法充斥了大量的逻辑判断，还凭空冒出了一大堆1，2，...，11，12这样的 Magic Number（魔鬼数字公然出现在程序里是很 ugly 的做法），不利于代码的维护与扩展。 表驱动处理起来就赏心悦目得多了： 123456static int monthDays[12] = &#123;31,28,31,30,31,30,31,31,30,31,30,31&#125;;int iGetMonthDays(int iMonth)&#123; return monthDays[(iMonth - 1)];&#125; How表驱动可以使你的代码更简洁，结构更加灵活，多用于逻辑性不强但是分支多的情况。 如何使用表驱动法？需要明确两个关键问题： 表的形式及表中放什么内容 表形式可以为一维数组、二维数组和结构体数组。 表中可以存放数值、字符串或函数指针等数据。 如何去访问表。 下面介绍表的三种访问方式： 直接访问直接根据“键”来获得“值”，给定下标 index，然后array[index]就获得数组在相应下标处的数值。例如前面这个根据月份取天数的例子。 索引访问 它适用于这样的情况：假设你经营一家商店，有 100 种商品，每种商品都有一个 ID 号，但很多商品的描述都差不多，所以只有 30 条不同的描述，如何建立建立商品与商品描述的表？ 还是同上面做法来一一对应吗？那样描述会扩充到 100 个，会有 70 个描述是重复的！太浪费了。 方法是建立一个 100 长的索引和 30 长的描述，然后这些索引指向相应的描述（不同的索引可以指向相同的描述），这样就解决了表数据冗余的问题啦。 123456789101112131415161718192021222324252627282930struct product_t &#123; char * id; int desc_index;&#125;;const char * desc[] = &#123; "description_1", "description_2", ... "description_29", "description_30"&#125;;const product_t goods [] = &#123; &#123;"id_1", 3&#125;, &#123;"id_2", 1&#125;, ... &#123;"id_99", 12&#125;, &#123;"id_100", 5&#125;&#125;;const char* desc_product (const char* id) &#123; for (const product_t &amp; p : goods) &#123; if (strcmp(p.id, id) == 0) &#123; return desc[p.desc_index - 1]; &#125; &#125; return NULL;&#125; 阶梯访问 例子：将百分制成绩转成五级分制（我们用的优、良、中、合格、不合格，西方用的 A、B、C、D和F），假定转换关系: Score Degree [90-100] A [80,90) B [70,80) C [60,70) D [0,60) F 如何用表格表示这些范围？你当然可以用第一种直接访问的方法：申请一个 100 长的表，然后在这个表中填充相应的等级。很明显，也会浪费大量空间，有没有更好的方法？ 对于这种“某个范围区间内，对应某个值”的逻辑规则，可用阶梯访问的方式。 123456789101112131415161718192021222324const char gradeTable[] = &#123; 'A', 'B', 'C', 'D', 'F'&#125;;const int downLimit[] = &#123; 90, 80, 70, 60&#125;;int degree(int score)&#123; int gradeLevel = 0; char lowestDegree = gradeTable[sizeof(gradeTable)/sizeof(gradeTable[0]) - 1]; // 这里可用二分查找优化 while (gradeTable[gradeLevel] != lowestDegree) &#123; if(score &lt; downLimit[gradeLevel]) &#123; ++ gradeLevel; &#125; else &#123; break; &#125; &#125; return gradeTable[gradeLevel];&#125; 将来如果等级规则变了（比如 85～100 分为等级 A，或添加 50～60 分为等级 E），只需要修改 gradeTable 和 downLimit 表就行，degree 函数可以保持一行都不改动。 更进一步地，gradeTable 和 downLimit 表还可以配置文件的形式表示，主程序从外部文件 load 进来就行，程序灵活性大大增加。 Review伟大的 C 语言大师 Rob Pike 有句话说的好： 数据压倒一切。如果选择了正确的数据结构并把一切组织的井井有条，正确的算法就不言自明。编程的核心是数据结构，而不是算法。 对人类来说，数据比编程逻辑更容易驾驭。在复杂数据和复杂代码中选择，宁可选择前者。 更进一步，在设计中，应该主动将代码的复杂度转移到数据中去。 这里谈到了 Unix 哲学之分离原则： 策略同机制分离 机制，即提供的功能。 策略，即如何使用功能。 以百分制转五级分制为例，机制就是 degree 函数：你给一个百分制分数给它，它吐出来一个五级分制给你。策略就是gradeTable 和 downLimit 这两个表，它规定了哪个区间的分数对应哪个等级。 从 degree 的实现可以看出:对机制而言，策略是透明的（degree 完全看不到 gradeTable 和 downLimit 这两个表的内部规则）。 将两者分离，可以使机制(degree)相对保持稳定，而同时支持策略(表)的变化。]]></content>
      <categories>
        <category>Coder</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>表驱动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[漫话 C++11 之 atomic_flag]]></title>
    <url>%2F2016%2F07%2F10%2FC%2B%2B11-atomic-flag%2F</url>
    <content type="text"><![CDATA[原子操作原子操作，是多线程环境下的一个重要概念，是指它是否在共享内存中完成了一个线程相关的单步操作。 当一个原子存储作用于一个共享变量时，其他的线程不能监测到这个未完成的修改值。 当一个原子加载作用于一个共享变量时，它读取到这个完整的值，就像此时出现了一个单独的时刻。 而非原子加载和存储则不能做到上述两点保证。 为了保证数据的最终一致性，我们可以定义如下规则： 任何时刻两个线程同时操作一个共享变量，当其中一个为写操作时，这两个线程必须使用原子操作。 atomic_flagatomic_flag 是一种简单的原子布尔类型，只支持两种操作:test-and-set 和 clear。 构造函数atomic_flag 只有默认构造函数，拷贝构造函数已被禁用，因此不能从其他的 atomic_flag 对象构造。 12atomic_flag() noexcept = default;atomic_flag (const atomic_flag&amp;T) = delete; 如果在初始化时没有明确使用 ATOMIC_FLAG_INIT 初始化，那么新创建的 atomic_flag 对象的状态是未指定的（unspecified）（既没有被 set 也没有被 clear。）另外，atomic_flag 不能被拷贝，也不能 move 赋值。 ATOMIC_FLAG_INIT: 如果某个 atomic_flag 对象使用该宏初始化，那么可以保证该对象在创建时处于 clear 状态。 看一个简单的例子，main() 函数中创建了 10 个线程进行计数，率先完成计数任务的线程输出自己的 ID，后续完成计数任务的线程不会输出自身 ID： 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt; #include &lt;atomic&gt;#include &lt;thread&gt; #include &lt;vector&gt; // can be checked without being setstd::atomic&lt;bool&gt; ready (false); // always set when checkedstd::atomic_flag winner = ATOMIC_FLAG_INIT; void count1m (int id) &#123; // wait for the ready signal while (!ready) &#123; std::this_thread::yield(); &#125; // go!, count to 1 million for (int i=0; i&lt;1000000; ++i) &#123;&#125; if (!winner.test_and_set()) &#123; std::cout &lt;&lt; "thread #" &lt;&lt; id &lt;&lt; " won!\n"; &#125;&#125;;int main ()&#123; std::vector&lt;std::thread&gt; threads; std::cout &lt;&lt; "spawning 10 threads that count to 1 million...\n"; for (int i=1; i&lt;=10; ++i) threads.push_back(std::thread(count1m,i)); ready = true; for (auto&amp; th : threads) th.join(); return 0;&#125; test_and_settest_and_set() 函数检查 atomic_flag 标志： 如果之前没有被设置过，则设置 atomic_flag 的标志，并返回 false； 如果之前 atomic_flag 对象已被设置，则返回 true。 12bool test_and_set (memory_order sync = memory_order_seq_cst) volatile noexcept;bool test_and_set (memory_order sync = memory_order_seq_cst) noexcept; test-and-set 操作是原子（read-modify-write）的，它到当前操作不受其他线程影响。 参数 sync 的取值如下： Memory Order 值 Memory Order 类型 memory_order_relaxed Relaxed memory_order_consume Consume memory_order_acquire Acquire memory_order_release Release memory_order_acq_rel Acquire/Release memory_order_seq_cst Sequentially consistent 这里涉及到有关 C++ 中内存模型 Memory Order 姿势，先挖个坑，日后单写一篇这个主题的文章。 clear清除 atomic_flag 对象的标志位，设置 atomic_flag 的值为 false。 12void clear (memory_order sync = memory_order_seq_cst) volatile noexcept;void clear (memory_order sync = memory_order_seq_cst) noexcept; 清除标志使得下一次调用 test_and_set 返回 false。 自旋锁结合 test_and_set() 和 clear()，atomic_flag 对象可以当作一个简单的自旋锁 使用，请看下例： 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;atomic&gt; #include &lt;thread&gt; #include &lt;vector&gt; #include &lt;sstream&gt; std::atomic_flag lock_stream = ATOMIC_FLAG_INIT;std::stringstream stream;void append_number(int x) &#123; while (lock_stream.test_and_set()) // acquire lock ; //spin stream &lt;&lt; "thread #" &lt;&lt; x &lt;&lt; '\n'; lock_stream.clear(); // release lock&#125;int main ()&#123; std::vector&lt;std::thread&gt; threads; for (int i=1; i&lt;=10; ++i) threads.push_back(std::thread(append_number,i)); for (auto&amp; th : threads) th.join(); std::cout &lt;&lt; stream.str(); return 0;&#125;]]></content>
      <categories>
        <category>Coder</category>
      </categories>
      <tags>
        <tag>C++11</tag>
        <tag>atomic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[布冯的历史行程]]></title>
    <url>%2F2016%2F07%2F03%2Fhistory-of-Buffon%2F</url>
    <content type="text"><![CDATA[我的经历就是到了意大利帕尔马俱乐部，到了 2001 年夏天的时候，我就想我在这里只是个替补门将，我想我应该换个俱乐部踢球。 于是我就给尤文图斯里皮主教练写了一个报告，他说欢迎你来，不过这个 apply for goalkeeper 你要去做一个报告。我就做了一个「论守门员扑出点球的正确姿势」的报告，这个报告经过俱乐部经理和几十名队员的一致通过。这个报告做了以后不久，2001 年的 7 月 1 日，意甲俱乐部就把我调到尤文图斯去了。 那么人呐就都不知道，自己不可以预料。一个门将的命运啊，当然要靠自我奋斗，但也要考虑到足协的历史行程，我绝对不知道我作为一个帕尔马替补门将怎么把我交换到尤文图斯去了。 所以里皮同志同我讲话说「俱乐部决定了，让你来当守门员」。我说另请高明吧，我实在也不是谦虚，我一个帕尔马新秀怎么到尤文图斯来了呢。但是呢，里皮同志讲「大家已经研究决定了」。所以后来我念了两首诗，叫「苟利球队生死以，岂因祸福避趋之」，那么所以我就到了意大利尤文图斯俱乐部。 在尤文图斯，我干了这十几年也没有什么别的，大概三件事： 第一个，作为主力门将参加了 2002、2006、2010、2014年的世界杯和 2004、2008、2012、2016年的欧洲杯。 第二个，严防死守！严防死守！为意大利夺得 2006 年世界杯冠军。 第三个，意大利历史上欧洲杯出场时间第一人。 如果说还有一点成绩就是「守门员最高转会费纪录保持者」，这个对我的历史定位有很大的关系的，因为我后来又带病续约踢了一年多，等于说我在尤文图斯干了十几年的核心球员。还有接任国家队队长也是很大的，但是这些都是次要的，我主要的就是三件事情。 很惭愧，就做了一点微小的工作，谢谢大家！]]></content>
      <categories>
        <category>一颗赛艇</category>
      </categories>
      <tags>
        <tag>布冯</tag>
        <tag>欧洲杯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[漫话 C++11 之 condition_variable]]></title>
    <url>%2F2016%2F06%2F26%2FC%2B%2B11-condition-variable%2F</url>
    <content type="text"><![CDATA[condition_variable 是条件变量，通常和 mutex 搭配使用。 当 condition_variable 对象的某个 wait 函数被调用的时候，它使用 unique_lock 来锁住当前线程。当前线程会一直被阻塞，直到另外一个线程在相同的 condition_variable 对象上调用了 notification 函数来唤醒当前线程。 condition_variable 对象通常使用 unique_lock&lt;mutex&gt; 来等待，如果需要使用另外的 lockable 类型，可以使用 condition_variable_any 类。 123456789101112131415161718192021222324252627282930313233343536373839// condition_variable example#include &lt;iostream&gt; // std::cout#include &lt;thread&gt; // std::thread#include &lt;mutex&gt; // std::mutex, std::unique_lock#include &lt;condition_variable&gt; // std::condition_variablestatic std::mutex mtx;static std::condition_variable cv;static bool ready = false;static void print_id (int id) &#123; std::unique_lock&lt;std::mutex&gt; lck(mtx); while (!ready) &#123; cv.wait(lck); &#125; std::cout &lt;&lt; "id=" &lt;&lt; id &lt;&lt; std::endl;&#125;static void go () &#123; std::unique_lock&lt;std::mutex&gt; lck(mtx); ready = true; cv.notify_all();&#125;int main () &#123; std::thread threads[10]; // spawn 10 threads: for (int i=0; i&lt;10; ++i) threads[i] = std::thread(print_id,i); std::cout &lt;&lt; "10 threads ready to race...\n"; go(); // go! for (auto&amp; th : threads) th.join(); return 0;&#125; 只提供了默认构造函数。 wait、wait_for、wait_until 方法 type arg unconditional void wait (unique_lock&amp; lck); predicate template void wait (unique_lock&amp; lck, Predicate pred); 其中 pred 是一个可调用对象/方法， 它不接受任何参数 返回值必须可以被转化为 bool unconditional在线程被阻塞时，wait 函数会自动调用 lck.unlock() 来释放锁，使得其他被阻塞在锁竞争上的线程得以继续执行。 一旦当前线程被唤醒 notified，wait函数会重新调用 lck.lock()，使得 lck的状态和 wait 函数被调用时相同。 Predicate只有当 pred 条件为 false 时调用 wait() 才会阻塞当前线程，并且在收到其他线程的通知后只有当 pred 为 true 时才会被解除阻塞。 举个栗子下面是一个使用 pred 模式的 wait 实现的「单生产者－单消费者」模型： 12345678910111213141516171819202122232425262728293031323334353637383940// condition_variable::wait (with predicate)#include &lt;iostream&gt; // std::cout#include &lt;thread&gt; // std::thread, std::this_thread::yield#include &lt;mutex&gt; // std::mutex, std::unique_lock#include &lt;condition_variable&gt; // std::condition_variablestd::mutex mtx;std::condition_variable cv;int cargo = 0;bool shipment_available() &#123;return cargo!=0;&#125;void consume (int n) &#123; for (int i=0; i&lt;n; ++i) &#123; std::unique_lock&lt;std::mutex&gt; lck(mtx); cv.wait(lck,shipment_available); // consume: std::cout &lt;&lt; cargo &lt;&lt; '\n'; // notify cargo=0; &#125;&#125;int main ()&#123; std::thread consumer_thread (consume,10); // produce 10 items when needed: for (int i=0; i&lt;10; ++i) &#123; while (shipment_available()) std::this_thread::yield(); //wait cargo to be consumed std::unique_lock&lt;std::mutex&gt; lck(mtx); cargo = i+1; cv.notify_one(); &#125; consumer_thread.join(); return 0;&#125;]]></content>
      <categories>
        <category>Coder</category>
      </categories>
      <tags>
        <tag>C++11</tag>
        <tag>condition_variable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[漫话 C++11 之 mutex]]></title>
    <url>%2F2016%2F06%2F26%2FC%2B%2B11-mutex%2F</url>
    <content type="text"><![CDATA[在多线程的程序中，经常需要通过锁的机制来保证数据的一致性。 C++11提供了下面四种语义的锁: type function desc mutex Lockable 普通的互斥锁，不能递归使用。 timed_mutex TimedLockable 带超时的互斥锁，不能递归使用。 recursive_mutex Lockable 递归互斥锁。 recursive_timed_mutex TimedLockable 带超时的递归互斥锁。 继承关系为： 123BasicLockable &lt;--- Lockable &lt;--- TimedLockable+lock +try_lock +try_lock_for+unlock +try_lock_until mutexC++11 中最基本的互斥量，它不支持递归地上锁。 mutex 不允许拷贝构造，也不允许 move 赋值，最初产生的 mutex 对象是处于 unlocked 状态的。 lock()，调用线程将锁住该互斥量。线程调用该函数会发生下面 3 种情况： 如果该互斥量当前没有被锁住，则调用线程将该互斥量锁住，直到调用 unlock之前，该线程一直拥有该锁。 如果当前互斥量被其他线程锁住，则当前的调用线程被阻塞住。 如果当前互斥量被当前调用线程锁住，则会产生死锁。 unlock()， 解锁，释放对互斥量的所有权。 try_lock()，尝试锁住互斥量，和 lock() 相似，不同的是如果互斥量被其他线程占有，则当前线程也不会被阻塞，而是马上返回 false。 recursive_mutex 允许同一个线程对互斥量多次上锁，来获得对互斥量对象的多层所有权。 释放互斥量时需要调用与该锁层次深度相同次数的 unlock()。 time_mutex 比 mutex 多了两个成员函数:try_lock_for()，try_lock_until()。 try_lock_for() 函数接受一个时间范围，表示在 一段时间范围之内 线程如果没有获得锁则被阻塞住，如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回 false。 try_lock_until() 函数则接受一个时间点作为参数，在 指定时间点未到来之前 线程如果没有获得锁则被阻塞住，如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回 false。 RAII关于 mutex 的使用，建议使用 RAII(Resource Acquisition is Initialization)的方式，即在构造的时候 lock, 析构的时候 unlock, 不建议直接手工地进行 lock/unlock。 C++11提供了 lock_guard 和 unique_lock 两种简单而又安全的上锁和解锁方式，即使程序抛出了异常，先前已被上锁的 Mutex 对象也能正确进行解锁，极大地简化了与 Mutex 相关的异常处理代码。 12345template &lt;class mutex&gt; class lock_guard;template &lt;class mutex&gt; class unique_lock; 都是模版类，实例化参数 mutex 必须是个 BasicLockable 类型(即支持 lock 和 unlock)。 都只负责在构造时对 mutex 加锁，析构时对 mutex 解锁，它们并不管理 mutex 本身的生命周期，因此，mutex 的生命周期应至少延伸至 lock_guard 和 unique_lock 析构之后。 lock_guard 只有构造函数和析构函数。 unique_lock 更灵活的初始化方式： default locking try_locking deferred adopting locking_for locking_until move 除了基本的上锁/解锁操作，unique_lock 还支持修改、获取 mutex 的操作： move 移动赋值 swap 与另一个 unique_lock 对象交换它们所管理的 Mutex 对象的所有权 release 返回指向它所管理的 Mutex 对象的指针，并释放所有权 owns_lock 返回当前 unique_lock 对象是否获得了锁 operator bool() 与 owns_lock 功能相同 5. mutex 返回当前 unique_lock 对象所管理的 Mutex 对象的指针 参考 http://www.cplusplus.com/reference/mutex/]]></content>
      <categories>
        <category>Coder</category>
      </categories>
      <tags>
        <tag>C++11</tag>
        <tag>mutex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[漫话 C++11 之 thread]]></title>
    <url>%2F2016%2F06%2F25%2FC%2B%2B11-thread%2F</url>
    <content type="text"><![CDATA[熟悉C++的人知道，在经过了13年的漫长等待后，C++标准委员会终于在2011年通过了C++史上的第二个标准。 C++0x VS C++11，傻傻分不清楚从一开始到现在，C++大概经历了以下几个比较重要的阶段： 1998: ISO官方发布C++标准，俗称C++98，这是第一个C++的官方正式版本 2003: TC1(Technical Corrigendum 1)发布，俗称C++03, 这个版本可以当成是C++98的一个bugfix版本 2005：TR1(Technical Report 1)发布，TR1是一个新增加的库，增加了大约14种新的组件到C++标准中 2008：新C++标准(C++0x)草案发布，这个主要是以TR1的基础上进行了扩充 2011：C++0x标准通过 随着各种动态解释型语言的诞生，C++程序员也越来越感觉到了C++语言本身的一些局限性。以C++之父 Bjarne Stroustrup(没错，就是下面这个仙风道骨的老头) 为代表的先贤们，也一直在不遗余力的努力着，让C++更加强大。 于是他们商量着： 要么大伙每5年来一次华山论剑？ 好！果真，后来的C++大会基本上是5年一次，比如 2003年，2008年。 1998年C++标准发布后，原计划于2003年之后的几年推出新的标准，但由于没有确定具体哪一年发布，就用 0x原来表示的是04-09年中的某一年。 等到了2009年，新的C++0x标准却一致拖着没通过，直到2011年才通过，名称还保持叫C++0x： x表示是16进制的字符0-f，所以11也是x了。 所以说，C++0x和C++11，这俩就是一回事，只不过前者是个草案，而后者是正式通过的标准。 thread以前，由于 C++98中没有线程、锁、条件变量等这些与多线程相关的特性支持，如果需要写多线程程序，都要借助于不同平台上各自提供的 api，导致程序的跨平台移植性较差，经常要用一大堆的 #ifdef WIN32类似的宏来区分不同的平台，这样写代码的姿势很难看。 现在好了，使用 C++11 可以编写跨平台的多线程程序了，而且相比原来的 pthread写法，代码更简洁优美。 今天从 thread 开始，介绍下 C++11 带来的一系列新特性。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;thread&gt;using namespace std;class Foo&#123;public: void bar (int id, string&amp; name) &#123; name += "+1s"; cout &lt;&lt; "id=" &lt;&lt; id &lt;&lt; ",name=" &lt;&lt; name &lt;&lt; endl; &#125;&#125;;void func ()&#123; cout &lt;&lt; "thread func" &lt;&lt; endl;&#125;int main ()&#123; Foo foo; int id = 1; string name("elder"); thread th_1 (func); //thread func th_1.join (); thread th_2 (&amp;Foo::bar, foo, id, ref(name));//id=1,name=elder+1s th_2.join (); thread th_3 (bind (&amp;Foo::bar, foo, id, name));//id=1,name=elder+1s+1s th_3.join (); thread th_4 ([&amp;]&#123; foo.bar (id, name); &#125;);//id=1,name=elder+1s+1s th_4.join (); return 0;&#125; 上面是 thread 的四种构造方式： (1) 最简单，最常用的方式，直接传入一个普通函数。 (2) 变参模版方式，如果函数为类的成员函数，第一个参数是对象本身，后面的参数按函数调用时的顺序传入。注意，引用传递参数的话实参用 ref(arg) 包装。 (3) bind 方式，传入一个 std::function对象，同样地，如果是类成员变量的话，第一个参数是对象本身。 (4) lambda 方式，是比较常用的方式(先留个坑，以后再细述)。 thread 对象 不可被拷贝构造。 可以 ｀move｀ 方式构造，thread th(std::move(x)); 之后，新构造的 th 拥有原先 x 的执行对象，x 不再代表执行对象。 可被 joinable 的 thread 对象必须在他们销毁之前被主线程 join 或者将其设置为 detach。 thread 方法1.operator = 如果当前对象不可 joinable，将获取右值的执行对象，同时，右值将不再代表执行对象；如果当前对象可被 joinable，则 terminate() 报错。 123thread th;th = thread(func); //√th = th_1; //x 2.get_id() 如果当前对象不可 joinable，返回默认构造线程的id（0x0)；如果当前对象可被 joinable，则返回当前线程的 id。 3.joinable() 检测线程是否 joinable。当且仅当 thread 代表某个执行对象时，它才是 joinable的。下列条件下，属于 不可 joinable： a. 默认构造函数构造出来。对 thread th;而言，th 不代表任何 thread 执行对象。 b. 被作为参数给 std::move 调用。 c. 已经调用了 join 或 detach 函数。 4.swap(x) 交换当前线程和 x 的状态、执行对象等。 参考 http://www.cplusplus.com/reference/thread/]]></content>
      <categories>
        <category>Coder</category>
      </categories>
      <tags>
        <tag>C++11</tag>
        <tag>thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[说好不分手，你怎么突然就脱欧了]]></title>
    <url>%2F2016%2F06%2F24%2Fbreak-up-with-European%2F</url>
    <content type="text"><![CDATA[我的经历就是，到了 2016 年中的时候，我的任期快到了，我想我应该脱欧，于是我就给默克尔总理、奥朗德总统，给他们写了一封信。 他们说欢迎你脱，不过，这个 apply for leaving，你要去发起一个公投，我就发起了一个《英国脱离欧盟趋势》的公投，这个公投经过好几千万英国人一致通过。 人呐就都不知道，自己不可以预料。一个人的命运啊，当然要靠自我的奋斗，但是也要考虑到历史的行程。 我绝对不知道，我一个左翼政党，怎么就带领脱欧了，所以伊丽莎白同志同我讲话： 王室都决定了，你来背这个锅。 我说另请高明吧，我实在也不是谦虚。我一个左翼政党怎么就背右翼的锅了呢？但是，伊丽莎白同志讲： 王室已经研究决定了。 后来我就念了两句诗： 苟利大英生死以，岂因欧盟避趋之。 所以我就脱离了欧洲。 当首相这几年我也没有干什么别的，大概三件事： 第一个，支持同性婚姻合法化。 第二个，搞了个苏格兰独立公投留住了苏格兰。 第三个，搞了个脱欧公投脱离了欧盟。 如果说还有什么成绩，那就是见证了一个穆斯林当上了伦敦市长，这对大英的绿化事业有很大的关系。还有 2012 年的奥运会也是贡献很大滴。但这些都是次要的，我主要就是这三件事。 很惭愧，就做了一点微小的工作，谢谢大家。]]></content>
      <categories>
        <category>一颗赛艇</category>
      </categories>
      <tags>
        <tag>脱欧</tag>
        <tag>卡梅伦</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[libevent 的并发工作做得太好了]]></title>
    <url>%2F2016%2F06%2F18%2Flibevent%2F</url>
    <content type="text"><![CDATA[我最近的工作呢，主要是在梳理我司核心平台的档案。 话说我司的这个后台，那可是牛逼的很啊。它作为基础设施，从无到有搞起来，前辈们把它撸得风生水起，支撑了其他产品的正常运转近十年。 系统的架构，小明在入职时就已经被培训过了，但是里面各个模块的细节却知之甚少。这段时间，计划把后台每个模块的代码 one by one 地啃一遍。这不，发现有好几个模块都用到了 libevent 这个库，但我之前没用过诶，为了看懂代码，必须要具备些 libevent 的基础知识。 libevent 是一个用C语言编写的、轻量级的开源高性能网络库。 主要有以下几个亮点： 事件驱动（ event-driven），高性能; 轻量级，专注于网络通信； 源代码相当精炼、易读； 跨平台，支持 Windows、 Linux、 Mac Os； 支持多种 I/O 多路复用技术； 支持定时器和信号等事件； 官网上列出了使用这个库开发的各种应用： 原来大名鼎鼎的 Chromium、Memcached都用到了它，真是 excited！ 看来，当初前辈们选用 libevent 也是一个英明的撅腚啊。 要了解 libvent 如何牛逼，首先要知道传统的 socket 通信是如何的弱鸡。 一开始，大家使用的都是阻塞式I/O函数，如果一个函数在操作完成之前，或者在超时之前，都不会返回，那么就说这个函数是同步的。 比如当你对一个 TCP 连接调用 connect()，你的操作系统会有一个队列，一个保存发送出去的SYN 请求的队列。然后对于每个 SYN 请求，系统尝试等待 TCP 另一端返回对应的确认码，即SYN ACK。在确认码 ACK 返回之前，或者直到超时，同步的函数是不会返回，称之为阻塞I/O。 下面有个使用阻塞I/O函数的例子，它打开一个连接，连接到 www.google.com，发送一个简单的HTTP请求，然后打印出返回内容到stdout。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/* For sockaddr_in */#include &lt;netinet/in.h&gt;/* For socket functions */#include &lt;sys/socket.h&gt;/* For gethostbyname */#include &lt;netdb.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;int main(int c, char **v)&#123; const char query[] = "GET / HTTP/1.0\r\n" "Host: www.google.com\r\n" "\r\n"; const char hostname[] = "www.google.com"; struct sockaddr_in sin; struct hostent *h; const char *cp; int fd; ssize_t n_written, remaining; char buf[1024]; /* Look up the IP address for the hostname. Watch out; this isn't threadsafe on most platforms. */ h = gethostbyname(hostname); if (!h) &#123; fprintf(stderr, "Couldn't lookup %s: %s", hostname, hstrerror(h_errno)); return 1; &#125; if (h-&gt;h_addrtype != AF_INET) &#123; fprintf(stderr, "No ipv6 support, sorry."); return 1; &#125; /* Allocate a new socket */ fd = socket(AF_INET, SOCK_STREAM, 0); if (fd &lt; 0) &#123; perror("socket"); return 1; &#125; /* Connect to the remote host. */ sin.sin_family = AF_INET; sin.sin_port = htons(80); sin.sin_addr = *(struct in_addr*)h-&gt;h_addr; if (connect(fd, (struct sockaddr*) &amp;sin, sizeof(sin))) &#123; perror("connect"); close(fd); return 1; &#125; /* Write the query. */ /* XXX Can send succeed partially? */ cp = query; remaining = strlen(query); while (remaining) &#123; n_written = send(fd, cp, remaining, 0); if (n_written &lt;= 0) &#123; perror("send"); return 1; &#125; remaining -= n_written; cp += n_written; &#125; /* Get an answer back. */ while (1) &#123; ssize_t result = recv(fd, buf, sizeof(buf), 0); if (result == 0) &#123; break; &#125; else if (result &lt; 0) &#123; perror("recv"); close(fd); return 1; &#125; fwrite(buf, 1, result, stdout); &#125; close(fd); return 0;&#125; 上面使用的网络相关函数都是阻塞式的。 gethostbyname在成功解析域名www.google.com或超时前是不会返回的； connect在成功连接后才返回； recv接收数据才返回，或者对方关闭了sock也会让recv返回； send也阻塞，直到把数据复制到系统内核buffer之中。 如果你在同一时间内只做一个事情，I/O阻塞函数也没有什么不好。但假若你的程序里要同时响应多个连接，比如你需要同时从 2 个连接sock中接收数据，而且你不知道哪个数据先到来，那么，你不能这样写你的程序: 1234567891011121314/* This won't work. */char buf[1024];int i, n;while (i_still_want_to_read()) &#123; for (i=0; i&lt;n_sockets; ++i) &#123; n = recv(fd[i], buf, sizeof(buf), 0); if (n==0) handle_close(fd[i]); else if (n&lt;0) handle_error(fd[i], errno); else handle_input(fd[i], buf, n); &#125;&#125; 因为如果 fd[2]的数据先到来的话，这段代码不会想当然地马上去读取fd[2]的数据，因为I/O是阻塞的，它必须读取完 fd[0]和fd[1]的数据后才能读 fd[2]，而你并不能事先保证哪个 fd 上的数据先到来。 当然也可以使用多个进程/线程来处理每个sock，每个sock的数据处理互不影响，A进程阻塞了，并不影响到B进程的工作。 那么，这是最好的同时处理多个连接的方案吗？ 当然不是！ 首先，在一些平台上，创建一个进程/线程的代价是很昂贵的。实际开发中你会使用一个线程池，而不是创建一个新进程。不过，假若你需要处理数以千万个连接，维护这么多线程，性能也许没有你期待的那么美好。 使用线程不是最好的答案。在Unix下，你可以设置sock为非阻塞，使用函数fcntl： 1234567891011fcntl(fd, F_SETFL, O_NONBLOCK); //fd对应于sock的文件描述符(file descriptor)//其实一般先获取sock的flag，修改flag，再设置新的flag，如下大概 /* Set a socket as nonblocking */int flags; if ((flags = fcntl (fd, F_GETFL, 0)) &lt; 0) err_sys("F_GETFL error"); flags |= O_NONBLOCK;if (fcntl(fd, F_SETFL, flags) &lt; 0) err_sys("F_SETFL error"); 一旦你对sock fd设置非阻塞，那么对这个fd调用网络相关的函数，比如recv，函数会马上返回，这时你要检查返回码以及全局变量errno。 从多个sock读取数据的代码段如下： 123456789101112131415161718192021/* This will work, but the performance will be unforgivably bad. */int i, n;char buf[1024];for (i=0; i &lt; n_sockets; ++i) fcntl(fd[i], F_SETFL, O_NONBLOCK);while (i_still_want_to_read()) &#123; for (i=0; i &lt; n_sockets; ++i) &#123; n = recv(fd[i], buf, sizeof(buf), 0); if (n == 0) &#123; handle_close(fd[i]); &#125; else if (n &lt; 0) &#123; if (errno == EAGAIN) ; /* The kernel didn't have any data for us to read. */ else handle_error(fd[i], errno); &#125; else &#123; handle_input(fd[i], buf, n); &#125; &#125;&#125; 上面的代码也存在性能问题，2个原因： 如果没有数据到来，代码不断循环，不断消耗cpu； 每次轮询都会调用系统调用，因为有没有数据可以读取，一般是检查内核数据buffer，这个过程由系统调用帮我们做检查。我们不断轮询，每次产生系统调用的消耗，这明显不是很环保的做法。 我们需要更为智能的方式，当数据最后可读时让内核主动告诉我们。 最古老的方式是使用 select: 12345int select(int nfds, fd_set *restrict readfds, fd_set *restrict writefds, fd_set *restrict errorfds, struct timeval *restrict timeout); select 系统调用使用了3个sock fd集合， 分别对应： 可读的fd集合，告诉select请检查这个集合内的fd，若其中某一个可读，请select返回，告诉我集合中有多少个fd有数据可以读了，其它两个也是类似的意思； 可写的fd集合； 异常的fd集合； select 返回后使用 FD_ISSET 来测试具体是哪个 fd 有数据了。 1234567891011121314151617181920212223242526272829303132333435/* If you only have a couple dozen fds, this version won't be awful */fd_set readset;int i, n;char buf[1024];while (i_still_want_to_read()) &#123; int maxfd = -1; FD_ZERO(&amp;readset); /* Add all of the interesting fds to readset */ for (i=0; i &lt; n_sockets; ++i) &#123; if (fd[i]&gt;maxfd) maxfd = fd[i]; FD_SET(fd[i], &amp;readset); &#125; /* Wait until one or more fds are ready to read */ select(maxfd+1, &amp;readset, NULL, NULL, NULL); /* Process all of the fds that are still set in readset */ for (i=0; i &lt; n_sockets; ++i) &#123; if (FD_ISSET(fd[i], &amp;readset)) &#123; n = recv(fd[i], buf, sizeof(buf), 0); if (n == 0) &#123; handle_close(fd[i]); &#125; else if (n &lt; 0) &#123; if (errno == EAGAIN) ; /* The kernel didn't have any data for us to read. */ else handle_error(fd[i], errno); &#125; else &#123; handle_input(fd[i], buf, n); &#125; &#125; &#125;&#125; 但是，随着每个fd集合中fd数量的增多，每次检查也相应要花费更多时间。 另外，由于每个系统中可以监控的fd数目有限，FD_SET 其实是一个位数组，linux 默认是 1024 bit，而 FD_SET 只是简单的把 fd 当作一个序号按位向位数组写数据。所以当 fd 大于 1024时，将导致写越界，这是一个很容易被程序员忽视的坑，具体案例参考云风写的《一起 select 引起的崩溃》（http://t.cn/8FW0zXv）。 鉴于此，不同的系统提供不同的优化方案，包括poll, epoll, kqueue, evports, /dev/poll。 所有这些优化都能获得更好的性能，而且除了poll，其他的函数，增加、删除一个fd，或者测试sock是否可读写，这些操作都是O(1)的效率。 可惜这些优化的方案，都不是标准。 linux使用epoll，BSDs(包括苹果内核)使用kqueue，Solaris使用evports和/dev/poll， 致命的是，同个系统只使用他们的优化方案，不包括其他，比如linux上就没有使用kqueue。 所以，如果你想要写一个高性能异步I/O的程序，若考虑移植和跨平台，你还需要做一些额外的包装。 可喜的是，libevent 帮程序员做了上面提到的这些工作。 libevent 提供了一个比 epoll更为友好的操作接口，将我等程序员从网络I/O处理的细节中解放出来，让我们可以专注于具体业务的处理上。 看懂了吗？识得唔识得呀？这就是 libvent 的由来。]]></content>
      <categories>
        <category>Coder</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>libevent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[没有什么是「一颗赛艇」不能解决的，如果有，那就两颗]]></title>
    <url>%2F2016%2F06%2F07%2Ffork-twice%2F</url>
    <content type="text"><![CDATA[前几天深谈了关于 fuck 的那些事，今天来聊一聊 fuck 它远房表哥：fork。 fork 和 fuck 实为远亲，彼此往来也不多，只在饶舌上有异曲同工之妙。 fuck 常出没于美式口头俚语，fork 则在计算机世界纵横驰骋。 fork 是 Unix 内核创建一个新进程的唯一方式，新建的子进程 拷贝 父进程的数据空间、堆、栈等信息，这也是 fork 函数命名的由来。 fork 完成之后，究竟是父进程先执行还是子进程先执行是不确定的，这取决于内核的调度算法，因此，有可能出现这些情况： 孤儿进程孤儿进程是指父进程在子进程结束之前 over (return 或 exit)。 但是孤儿进程并不会像上面画的那样持续很长时间，当系统发现孤儿进程时，init 进程就收养孤儿进程，成为它的父亲，child 进程 exit 后的资源回收就都由 init 进程来完成。 僵尸进程僵尸进程是指子进程在父进程结束之前 over 了，但是父进程没有用 wait 或 waitpid 回收子进程。 子进程在结束的时候会给其父进程发送一个 SIGCHILD 信号，父进程默认是忽略 SIGCHILD 信号的，如果父进程通过 signal() 函数设置了 SIGCHILD 的信号处理函数，则在信号处理函数中可以回收子进程的资源。 事实上，即便是父进程没有设置 SIGCHILD 的信号处理函数，也没有关系，因为在父进程结束之前，子进程可以一直保持僵尸状态，当父进程结束后，init 进程就会负责回收僵尸子进程。 但是，如果父进程是一个服务器进程，一直循环着不退出，那子进程就会一直保持着僵尸状态。虽然僵尸进程不会占用任何内存资源，但是过多的僵尸进程总还是会影响系统性能的，极端情况下会耗尽系统的可用进程数，导致无法再新建进程。 黔驴技穷的情况下，该怎么办呢？ 两次fork为了防止系统中产生僵尸进程, 两次fork 是常用的技法，原理如下： 《UNIX环境高级编程》这本书里提供了现成的代码： 12345678910111213141516171819202122232425262728293031323334# include &lt;sys/types.h&gt;# include &lt;sys/wait.h&gt;# include "ourhdr.h"int main(void) &#123; pid_t pid; if ( (pid = fork()) &lt; 0) err_sys("fork error"); else if (pid == 0) &#123; /* first child */ if ( (pid = fork()) &lt; 0) err_sys("fork error"); else if (pid &gt; 0) exit(0); /* parent from second fork == first child */ /* We're the second child; our parent becomes init as soon as our real parent calls exit() in the statement above. Here's where we'd continue executing, knowing that when we're done, init will reap our status. */ sleep(2); printf("second child, parent pid = %d\n", getppid()); exit(0); &#125; if (waitpid(pid, NULL, 0) != pid) /* wait for first child */ err_sys("waitpid error"); /* We're the parent (the original process); we continue executing, knowing that we're not the parent of the second child. */ exit(0); &#125; 执行程序得： 1$ second child, parent pid = 1 这里有个需要注意的地方： 第二个子进程中调用 sleep 保证在打印其父进程时第一个子进程已终止。因为 fork 之后，父、子进程都会继续执行，我们无法确保孰先孰后。如果不使第二个子进程 sleep 一段时间，则 fork 之后，它可能会比其父进程先执行，于是，它打印的父进程将是创建它的进程，而不是 init 进程（进程ID为 1）。 可以看出，两次 fork 之后，系统没有产生僵尸进程，子进程死了也就死了吧，孙子进程进孤儿院了，最重要的是，我们那个永不死的服务器进程甜蜜地笑到了最后。 你死我都未死啊！]]></content>
      <categories>
        <category>Coder</category>
        <category>一颗赛艇</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>fork</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[坏蛋不是道德水平低，而是格局小]]></title>
    <url>%2F2016%2F05%2F31%2FLuogic-Talkshow-Southern-Ming-Dynasty-2%2F</url>
    <content type="text"><![CDATA[今天分享的是罗辑思维第 162 期《南明死局·二》，受益颇多，在此记录下心得。 这期节目以明末四大奸臣之一的阮大铖为入口，从文官的角度再来审视一下南明这个时代。 阮大铖，有才，自是不必多言，作为一个能导、能演、能唱的昆曲全才，用“才华横溢”四字形容之，一点也不为过，倘若生在当今，张艺谋大导演，就是个屁了！ 可惜他最终留给世人的是一个大坏蛋的面孔，由于他为人奸佞，品格低下，乡里后人深以为耻，他的籍贯居然出现了“桐城不要，怀宁不收”的情况，《奸臣传》以他作为压轴，可见其奸的分量。 坏蛋不是一天炼成的，起码他在 29 岁中进士前，毫无劣迹啊？ 那么，坏蛋又是如何炼成的？ 过去我们都以为坏蛋坏是因为道德水平低，这期节目提出了另外一个维度的原因：「格局小」。 格局小怪个人吗？有的时候其实是环境使然。 举一个例子：高考备战，班上有些同学非常勤奋，晚上做作业、复习功课到深夜，但是第二天早上到了班上，做的第一件事就是告诉大家，自己昨晚看了一晚上电视，一页书都没看。 这不就是想对同班同学使障眼法吗？其实谁都明白，高考这件事情是在全省、全国的高三学生中展开竞争，根本不是和身边这帮人竞争。但是人就是有这个本能，明知战场不在身边，也想要赢过身边这群人。 所以有那么一句话： 了解一个人的趣味，看他的配偶——她的先生或者他的太太；了解一个人的品格，看他的朋友；但是了解一个人的能力，要看他的对手。 人其实是会被整个环境驯化的，你找到什么样的对手，进入什么样的格局，你自己的境界就有多高。 所以，南明破败不是因为它能力差，也不是因为它资源少，这个政权其实还拥有很多战略回旋的余地。但是为什么南明的弘光政权崩溃得那么快？就是因为常年的皇权制度的打造，到了明末的时候，它已经变成了一个所有要素都封闭在一起的小系统。 这个系统小到什么程度？就是它所有的构成要件——不管是阉党还是东林党，都以对方为唯一对手。东林党如果以阉党为唯一对手的话，它的能力就被锁死在阉党这个水平上。没有人真正为家国天下奋斗，这个大目标所有人都忘了。 就算东林党道德水准比较高，将来在历史上的名声比较好，那又怎样？从整个系统演化的角度看，它起到的作用其实和阉党差不多，都是以对方为对手，以打赢对方为首要的甚至是唯一的目标。整个组织的大目标大家都忘了，所以南明的崩溃其实双方都有责任。 就像很多大公司，内部矛盾比外部矛盾还要大，而且管理越严密、组织机构越发达，这个现象就越明显。大公司内两个部门之间想达成协作比登天都难，有的部门要做一件事，明摆着组织内部有合适的资源，但是没法用，因为太难了。它宁愿在外面找一个供应商，花钱外包都比内部协作要容易得多。 所以大公司要达成一个既紧急又重要的目标时，就不得不从各个部门中抽人，成立一个临时的组织，再来达成这个目标。结果，组织进一步变得庞大：这真是大组织的宿命。 我并不想批判大组织，只是想问： 一个人想要不变成坏人，他应该做什么？ 有两件事: 多读书，读好书，多接受些新知识 君子不立于危墙之下 相比而言，后者其实更加重要，如果你所在的公司或者机构出现了管理僵化或走下坡路的情况，你千万不能在里面待着，否则，不仅你的发展会受到限制，你的道德水准也会下降。 因为一个处于下坡状态的系统，里面的明白人、聪明人、优秀的人早就跑了，你再在里面待下去，就没有人可以学习了，你所处的环境本身在恶化，你的生存空间也在被压缩，资源进一步稀缺，我们会怎么办呢？ 团结起来就能共渡难关吗？可能会有这种情况。但是更普遍的状况是什么？我们受人性驱使，变得鼠目寸光，只看得到这个系统内部的结构，然后和身边的人争抢资源，和其他部门恶斗，而且越斗越往下探道德底线。 好在，我们生活在一个自由的时代，如果发现自己身处在一个不断恶化的小系统中，我劝你赶紧走，不仅是为自己的生路，也是为自己的灵魂找到一个向上的空间。 调整自己的生存处境是我们生存智慧的体现。 如此所言： You should live according to what you think,or you will think according to your life.你要按所想的去生活，否则，你迟早会按你生活的去想。]]></content>
      <categories>
        <category>心旷神怡</category>
      </categories>
      <tags>
        <tag>罗辑思维</tag>
        <tag>管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对于下流的你来说，Fuck 实在是太纯洁了]]></title>
    <url>%2F2016%2F05%2F29%2Ffuck%2F</url>
    <content type="text"><![CDATA[在小明看来，没有什么问题是不能光明正大地拿到台面上研究的，今天我就要来涨点关于 fuck 的姿势。 对于经常看美剧的小盆友们来说，印象最深的台词估计非 Fuck 莫属了。Fuck 它在美国人的口语中出现的频率之高，相当于「我靠」（部分民风彪悍的地区或已演化成「我操」） 之于汉语，「阿西吧」之于韩语，「屌久埋」之于我老家的汝城话。 不管地域习俗有多大差异，人类在选择脏话的品味总是出奇的一致，骂人带生殖器是人类作为动物的后裔共有的恶趣味之一，半斤八两，谈不上谁比谁 low 到哪里去。 但坦白而言，相比起中文里单独的一个「操」字，英语里「Fuck」这个词更具节奏感和韵律美，因为每当姑娘朝我喷出这个词的时候，她们总会先用牙齿咬住下嘴唇，再随着声音的发出松开，让这个词洋溢着别样的性感。 Fuck 一开始就是用来骂人的，骂人也是 Fuck 这个单词最基本的功能属性，这点我相信没人会反对。但年少无知的我们可能只知其一，不知其二，Fuck 的内涵，源远流长，博大精深，并没有你们想象的那么简单。 在韦式词典中，Fuck 一词多义，可为及物动词、非及物动词、名次、副词、形容词、语气助词。而某度字典的解释就粗俗得很，短短的5个字翻译：「与某人性交」，格调之低，可见一斑。 引经据典 fuck 考最常见的，当然是做动词啦。 Fuck you! 去死吧！ Let’s fuck. 我们约炮吧。 Oh, fuck it! 算了吧！ Fuck me在不同的语气、不同的前后文，其意义差别很大。 不情愿的承认自己犯错 It’s my fault. Fuck me. 是我的错，你来咬我啊？！ 表示惊讶 Oh, fuck me. 这里是「我艹」的意思，而不是「艹我」，千万别搞反了，表示厌恶，类似「sth disgusts me」 情况很糟糕 Oh! Fuck me! I’m sorry for being late. 噢！糟糕！抱歉我迟到了！ fuck 做名词有一丁点儿；感叹词；搞 XXOO 的人等含义。 What the fuck? 搞什么东西？！ Shut the fuck up. 闭嘴。 Mary is a terrific fuck. 玛丽是個美丽尤物。 What the fuck is wrong with this guy? 这家伙是有什么问题？ Who the fuck are you? 你是哪根蔥？ I don’t give a fuck! 我一点都不在乎！（和 I don’t give a shit! 意思相同） fucking用作副词或形容词，意为该死的；讨厌的；令人难以置信地；非常地。 Take your fucking hand off me! 拿开你该死的脏手！ What a fucking beautiful scenery! 多么美丽的的风景！ Fucking hell…It hurts a lot! 该死的…我好痛！ This cake is fucking amazing. 这蛋糕真是超级好吃。 Where are all the fucking mosquitoes coming from? 这些该死的蚊子是从哪里來的？ Emily has finished all the fucking work. 艾米莉把所有烦人的工作都做完了。 I fucking hate you. 我恨死你了。 当我们使用 fucking 来强调「非常好」或是「非常不好」的情绪時，这时的 「fucking」 也可以用 「freaking」 代替。这样可以巧妙的避开 「fucking」 的字眼，却依然有一样的效果。 This is fucking (freaking) amazing! 还可表示时间： It’s five fucking thirty. 5点半 放在一个动词的中间（注意这种用法哦，国内较少见），起增强语气的作用： fan-fucking-tastic：真是太棒 un-fucking-believable：真是不敢相信 congratu-fucking-lations：真是恭喜 fuck up混乱的；搞砸的；坏掉的；教训（人）；（人）喝醉；（人）很烦、头昏脑胀的。 和常听到 「screw up」 意思相似，更加文雅的用法是 「mess up」。 I’m fucked up. I didn’t do my Economics homework!我死定了，我沒有做我的经济学作业！ The failure totally fucked him up.失败使他一蹶不振。 I fucked up the exam.我考试考差了。 This computer is completely fucked up.电脑完全坏掉了。 Good luck and don’t fuck (it) up.祝好运，別搞砸了！ fuck 和 up 结合成的名词 fuck-up，可以用來指经常 (搞砸)事情的人或做事不牢靠的人。 Sam is a fuck-up. He fucks up everything. 山姆是个常常搞砸事情的人。 fuck off很不客气地叫人走开、滚开的意思。 Get the fuck off my car! 滚开我的车！ fuck around鬼混；瞎闹 Hey! Stop fucking around.嘿！別闹了！ fuck with玩弄；欺骗；干涉。 Don’t fuck with me. 为什么有时候看到电影里的男主角对男的也这么说？人家当然不是玩断背啦，意思是「你玩不过我，最好别惹我」。 I can’t believe that John likes to fuck around with girls. 我真不敢相信约翰喜欢和女生乱搞。 活学活用如你所见， fuck 并没有那么污，下次再在美剧、电影中听到 fuck 就别只往那方面想了，即使人把 fuck 当口头禅，你也别反射弧地鄙视人家素质低，说到底，要联系人物所处的具体情境，看看人家到底想表达什么意思。 比如，下面两个栗子出现了这么多 Fuck，各代表什么意思？ Fuck you. What the FUCK do you know? You don’t know anything. Everything you know is a FUCKING lie！ Fucking is one of those fucking words you can fucking put any fucking where in a sentence and still fucking makes sense.]]></content>
      <categories>
        <category>心旷神怡</category>
      </categories>
      <tags>
        <tag>fuck</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Segmentation fault:inet_ntoa 崩溃咯]]></title>
    <url>%2F2016%2F05%2F24%2Fsegmentation-fault-inet-ntoa%2F</url>
    <content type="text"><![CDATA[今天来记录个小问题，应该说是个「坑」。 写了个 socket 通信程序，在我 64 位的 Mac mini 上，调用 inet_ntoa 函数产生段错误 Segmentation fault: 11 。 出错的地方就在这行代码： 1printf("accept a new client from: %s\n", inet_ntoa(client_addr.sin_addr)); 把它注释再跑就 OK，干掉注释再跑又崩溃……试了好几次，每次都如此。 Surpried？！ 坑inet_ntoa 把网络地址转换成字符串(如 192.168.8.168)，返回 char *，我 printf 用 %s 格式化它，应该没错啊…… 后来，我发现编译时有几行信息都是关于这个 inet_ntoa 函数的： 看到了没，不仅 inet_ntoa，inet_aton 也相应地给出了警告，前面两行翻译成人话就是： inet_aton 函数声明非法，inet_ntoa 函数声明非法。 更离谱的是，最后一行居然说类型不匹配，inet_ntoa 返回类型为 int？ 一瞬间，我凌乱了，学了这么多年的 C 语言，不知道这 inet_ntoa 玩的是哪一出啊。 man 一下 inet_ntoa 看，其中有一行特别重要： These include files are necessary for all functions. 原来啊原来，这几个头文件都需要 include 进来！ 而我的程序中，漏掉了最后一行 #include &lt;arpa/inet.h&gt;，赶紧加上，再编译、运行，呵呵～ 感兴趣的，可以拿下面这个个小 Demo 感受下： 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;//#include &lt;arpa/inet.h&gt;int main(int argc,char *argv[])&#123; struct sockaddr_in cli_addr; char *some_addr; inet_aton("127.0.0.1", &amp;cli_addr.sin_addr); some_addr = inet_ntoa(cli_addr.sin_addr); printf("%s\n", some_addr); return 0;&#125; 善待警告在老版本的 C (如 C98,C99)语言中，如果你在使用 inet_ntoa 函数前没有 #include &lt;arpa/inet.h&gt; ，在某些 64 位系统上它的返回类型为 int，%s 遇上 int，怪不得会 segmentation fault了…… 这他妈真是个坑，也不知道是谁设计的，既然要 include 这三个文件才能用这个函数，那你就别让我编译通过给个 error 行不行？ 这就回到了一个好的编程习惯的问题了： 不要忽略代码中出现的告警，有些警告其实就是错误。]]></content>
      <categories>
        <category>Coder</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Segmentation fault</tag>
        <tag>inet_ntoa</tag>
        <tag>warning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《罗辑思维 | 南明死局一》心得]]></title>
    <url>%2F2016%2F05%2F21%2FLuogic-Talkshow-Southern-Ming-Dynasty-1%2F</url>
    <content type="text"><![CDATA[今天在家啃了几十页的《Unix 环境高级编程》，内力消耗过度，感觉有轻度的头昏脑胀，我想不能再这样修炼下去了，得换个姿势调节下大脑。 于是，我打开了很久没跟看的《罗辑思维》，这次看的是第 161 期《南明死局·一》，受益颇多，在此记录下心得。 熟悉中国历史的人都知道，1644 年，这一年特别热闹：5 个皇帝，你方唱罢我登场。什么国破家亡、文化沦丧、才子佳人、忠臣逆子……几乎所有能够调动起人们肾上腺激素的故事情节，在这一年都可以找到。 这期节目借南明这段短暂的历史，用理性而非情绪化、道德化的角度来剖析它，讨论了中国古代政治系统和现代管理学方面的知识。 中国古代政治系统的演化中国古代的政治系统是一项高科技成果，历代帝王对此均有贡献。两千多年的封建社会，一个大的趋势是：皇权逐渐扩张，集权化越来越明显。 但是，在皇权一路加固的过程中，这个系统变得越来越脆弱。 唐代之后，中原的汉人政权都毁于外族，一个是宋朝，一个是明朝。宋朝的对手是蒙古人，没办法，全世界都打不过他们；可是明朝的对手是满清，非常弱，怎么也打不过呢？ 当一个系统的内部越加稳固的时候，它对外的抵抗力就越差。 如果把权力放在一个更大的系统来看，权力也是人类的一种协作机制，想要稳固权力就必须跟更多人协作。 集权的协作问题就出在它是一种试图单向控制的系统。 这就带来两个后果： 在集权的过程中，必然伴有分权过程。 天下所有事都管，皇帝一个人管得过来吗？权臣、太监、外戚……总会在某个王朝的某个阶段扮演重要角色。 越集权，带来的反制力越大。 良性的反制，好比“无为而治”，皇帝把国家大事交给管事大臣去大理，不做过多干预。 恶性的反制，好比“断头政治”，活儿你们都干了，要我干什么？皇帝干脆罢工像万历那样几十年不上朝。 更恶性的反制叫“起哄政治”，文官卖直，只要是皇帝坚持的，他们就反对，为了反对而反对。 在这个系统中，当皇权强悍到一定程度，它激发起的其他因素（权臣、太监、外戚）的反制能力也会霸道和强悍到一定程度。它们的存在就是为了对付皇权，而对付任何系统性的外来危机，它们却毫无力量。 为什么好公司一定没有好管理由南明联想到我们这一代人的生存处境，有一点很相同：外部环境极其动荡，瞬息万变。 现在的市场上有两种公司：一种管理得特别好，但越是管理得好的公司，应对转型的能力往往就越差，比如诺基亚；另一种公司，屁滚尿流，丢盔卸甲，内部极其混乱，但是一路奔向成功，比如小米。 难道管理越坏，公司就会越好吗？非也。 过去我们都以为”好管理是好公司的原因”，某位牛人却说： 好管理是一家坏公司的结果。 这里的“坏”，是指公司内部的信任结构非常糟糕，是基于对人的不信任，公司把员工、所有的创业伙伴都当作诱饵来进行管理，设置各种名目繁杂的规章制度，因而从外面看上去显得管理特别完善。 据两个常见的例子： 很多管理非常严格的公司，各个部门都是有预算的，不同级别的干部请客吃饭有不同的额度限制。到年底是什么情况？一定是各部门突击花钱，因为员工与公司的信任建立在规章制度这个层面上，员工当然要把自己的权力全用足。 很多新员工刚进公司往往非常积极主动，完全是那种自发型的，但是那些规章制度偏偏就不信任你，把你引向不自觉的轨道上来管理你，几次下来人就没有冲劲了，规规矩矩每天撞钟就行了。 明朝是不是也是这样一家坏公司呢？因为互相之间缺乏信任，所以皇权变得极其强大。这个王朝君臣之间的信任基石一步步崩盘，到了南明的时候，一个小小的言官都可以公开质疑皇帝本身的合法性了。 反过来讲，为什么好公司就一定没有好管理？ 因为不需要，因为互相之间可以信任。 好公司就是成人之间的公司。 大家基于相同的价值观聚集在公司这个临时的社会协作体中，彼此相互信任，以成年人的思维方式、处事方式团结合作，这种公司的做事效率最高，其管理成本反而是最低的。 所以，基于不信任的控制、管理方式适用于应对内部危机，而今天这个社会，对于大多数中小企业而言，我们主要是应对外部的危机，需要公司这个组织有战斗力，要在和同类公司之间的竞争中打硬战、打胜战，那就需要一种全新的思维模式。 那就是反过来，我们要 基于信任去构建一个协作系统。 思考小公司靠信任可以，当公司规模扩充到几百人甚至像 BAT 这样几万几十万员工，如何维持这么大组织体内的信任机制？ 小明不才，但也看到了别人交出的答案：谷歌搞母公司，腾讯把微信搞成独立事业部，阿里把支付宝、蚂蚁金服独立上市……拆分、拆分、再拆分，保证每个有机体内不至于太臃肿。]]></content>
      <categories>
        <category>心旷神怡</category>
      </categories>
      <tags>
        <tag>南明</tag>
        <tag>罗辑思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「520」，我什么也不说，这是坠吼滴]]></title>
    <url>%2F2016%2F05%2F20%2F520-I-say-nothing%2F</url>
    <content type="text"><![CDATA[今天 520，有两个大新闻。 湾湾人民搞了第一个大新闻：首位女总统登基大典。 我对此也没有什么好说的，只看到中天新闻的记者跑得最快，在 YouTube 上给全世界人民搞了个典礼直播，真是 excited。 暴力小英敢冒 Min Jin Party 之大不韪，唱国歌居然不回避「三民主义，吾党所宗」，搞得各位记者很是激动了一把。 她的就职演说倒没什么偏差，四平八稳，压根就不敢提 tai 独两字，大家最关心的两岸政策，英文·蔡也只含糊不清的说什么「维持现状，尊重九二会谈这个历史事实」。 这他妈的离「认可九二共识」还差得老远呢！ 萱萱很生气，马上就封杀了国内所有关于蔡就任总统的新闻报道。 细说下这位英文，大学教授出身，表面看上去清秀（对不起，我重口了）稚嫩，似乎是一个可以轻易玩弄的傀儡，其实是个韬光养晦有所作为的权谋大师。​能够入主总统府，yingwen 已然证明了自己身为政客的强悍能力，但这并不意味着她能够应付未来的挑战。 大陆不可能容忍台湾向 tai独前进半步，美国也不可能坐视台海失控，台湾经济的振兴更是遥遥无期……这些，yingwen 能否应对呢？且行且看吧。 好了，说下另外一个大新闻，这就跟 520 主题比较吻合的啦：霍建华抛弃胡歌向林心如表白。 小明在祝愿心如姐姐和建华长长久久的同时，也同情下胡歌、尔康和有朋吧。]]></content>
      <categories>
        <category>心旷神怡</category>
      </categories>
      <tags>
        <tag>蔡英文</tag>
        <tag>520</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NFS: 让 NFS OS X 和 Linux 手牵手]]></title>
    <url>%2F2016%2F05%2F20%2FNFS-on-OSX-Linux%2F</url>
    <content type="text"><![CDATA[使用 NFS 让 Mac OS X 和 Linux 能互相访问共享的网络硬盘。 下面以 OS X EI Capitan (192.168.6.235) 和 Ubuntu 12.04 (192.168.6.21) 为例。 Linux –&gt; Mac服务端：Mac /etc/exports: 1/Users/hxz/test -maproot=root:wheel -network 192.168.6.0 -mask 255.255.255.0 /Users/hxz/test: 要通过 NFS 共享的文件目录。 -maproot=root:wheel: 把 client 端的 root用户映射为 Mac OS 上的 root，client端的 root组映射为 Mac OS 上的 wheel (gid=0) 组。 -network 192.168.0.0: 子网网段。 -mask 255.255.255.0: 网络掩码。 重启 nfsd： 1234hxz@pc0170:~/workspace/hxzqlh.com$ sudo nfsd restarthxz@pc0170:~/workspace/hxzqlh.com$ showmount -eExports list on localhost:/Users/hxz/test 192.168.6.0 客户端：Linux 1sudo mount -t nfs 192.168.6.235:/Users/hxz/test somewhere/on/linux Mac –&gt; Linux服务端：Linux /etc/exports: 1/home/hxz/media_set 192.168.6.0/255.255.255.0(rw,all_squash,insecure,anonuid=1000,anongid=1000) 重启 nfs server： 1234hxz@pc0053:~/media_set$ sudo service nfs-kernel-server restarthxz@pc0053:~/media_set$ showmount -eExport list for pc0053:/home/hxz/media_set 192.168.6.0/255.255.255.0 客户端：Mac 1234sudo mount -t nfs 192.168.6.21:/home/hxz/media_set /Users/hxz/media_set或：sudo mount_nfs -o resvport 192.168.6.21:/home/hxz/media_set /Users/hxz/media_set 可视化连接方式，在 Finder 的 Go 菜单： 卸载 nfs 硬盘：1sudo umount -t nfs nfs_dir]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>NFS</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[妈妈再也不用担心我为了听歌装那么多播放器了]]></title>
    <url>%2F2016%2F05%2F18%2FListen1%2F</url>
    <content type="text"><![CDATA[今天来聊一聊关于听歌、找歌的事。 为了听歌，你装了多少个音乐播放器？ 喜欢听歌的朋友想必都知道上哪去找歌，国内主流的音乐平台无外乎 QQ音乐、虾米音乐、网易云音乐和百度音乐，感谢人家给我们提供了免费听音乐的功能。 但，平台是要向音乐创作者们付版权费的，而且，不同平台之间还存在竞争，为了抢到独家发布权，某个音乐人的歌曲通常只限于跟它合作的平台上播放。 另一方面，单个平台上收录的音乐毕竟有限，有些小众的音乐只有个别平台能搜索到。 现状是：为了听一首自己想听的歌，我们不得不而下载 N 个音乐播放器。 这样，对我们听众而言，带来了两个不好的用户体验： 需要打开好几个网站搜索 无法建立一个统一的歌单 Listen 1还好，somebody 给我们搞了个好东西出来。 「Listen 1」，这款工具让你用一个网页就能听到多个网站的在线音乐，现已包括网易云音乐，QQ音乐，虾米音乐，豆瓣音乐。 你可以非常的简单得访问和收听在线音乐，而不用受到单个音乐网站资源不全的限制了，更贴心的是，它还能方便的整理你喜欢的音乐，制作歌单和收藏热门歌单。 这个工具是一个网页应用，支持浏览器：IE 11, Chrome, FireFox, Safari，装上相应的浏览器插件就可以了。 妈妈再也不用担心我找不到我想听的歌了，尽兴的享受音乐吧。 TODO闲着无事，上 github (链接：https://github.com/listen1/listen1) 粗略扒拉下这个应用的源码： 这位同学参考了很多音乐网站 API （github 上都有不少热心的开发者专门研究各大主流网站的 API）的分析代码和文章，因此里面的主要工作是聚合这些 API，采用「Angular＋tornado」架构开发出来。 So easy! 目前这个工具只开发了 PC 版，要是再搞个手机版出来就更完美了，手机上的音乐播放器 APP 也可以少装几个了。 看来我有必要上 github 拉个分支开发「Listen 1」的手机版出来。]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员为啥喜欢听着音乐写代码]]></title>
    <url>%2F2016%2F05%2F15%2Fenjoy-music-when-coding%2F</url>
    <content type="text"><![CDATA[没错，小明是一枚程序员，入门级。 程序员这个物种，每天的工作其实挺单调的：面对繁复的代码，双眼紧盯屏幕，指尖在键盘上噼里啪啦飞扬…… 我发现身边有不少同事都习惯于一边写代码一边听音乐。 就像有相当比例的程序员喜欢看动漫 一样（这个以后再探讨），我对「听着音乐写代码」这种流行于程序员群体的现象感到好奇。 存在即合理，我今天来浅析此种现象。 我不想被打断为了不被周遭环境的噪音(同事的交谈，移动椅子的声音等)吵到，戴上耳机，听一首音乐，任他东西南北风，我就是整个世界。 甚至，哪怕你不听音乐，只是戴上耳机，也能向别人传递出这样一种信号： 对不起，我很忙，要是没有很重要的事就别来打扰我。 知情的人，一看就秒懂了。就好比阳顶天闭关修练九阳神功，此刻，这家伙需要一个相对清静的环境。 要是在你专心致志地码代码时，身边突然蹦出个人来，哪怕、即使，对方是个美女，咔嚓打断你一下「你看我这个新发型好看吗？」，很可能你刚刚在脑海里飘过的那行思绪就永远、永远、永远找不回来了。 出于礼貌，往往程序员这个时候只能咽下这口苦水（或许在美女看来，那是口水），强忍住把美女掐死的冲动，静静地看她微（zuo）笑（si）。 千万别去骚扰程序员，尤其是 Ta 在写代码的时候。 千万别去骚扰程序员，尤其是 Ta 在写代码的时候。 千万别去骚扰程序员，尤其是 Ta 在写代码的时候。 重要的事情说三遍。 我不想走神毕竟一气呵成码代码的时候不是太多，大多数时候，程序员还不得不应付那些重复性的流程性的工作，这些琐碎的杂事无法让你两眼放光，精神抖擞，比如说：写技术文档、写测试用例、写用户使用说明…… 对于这样的工作，音乐或者广播、有声读物可以给你的大脑一定的节奏来保证参与度，从而避免神游八方。 当处理像码代码这种对创造性要求较高的脑力活时，有的人会单曲循环一首音乐，一遍一遍又一遍，直到他进入了思维流畅的状态。 听什么音乐我并没有没事就戴耳机听歌的癖好。 作为一枚情感专一、一心难以两用的程序员，小明工作时的常态是「两耳不闻窗外事，一心一意码代码」。 只有在工作压力不大的时候，才把听音乐作为一种休息的方式偶尔听听，你让我一整天戴这个耳机，我耳朵会痛。 当然啦，做那些简单的、重复性的编程工作时，听听音乐还是很惬意的。需要设计、开发新的东西时，我还是偏向于安静的环境，即使音乐本身也不能来打扰我。 最后，分享两个适合程序员码代码时听的歌单。 《骨灰级程序员编程必备音乐》（链接：http://dwz.cn/3munyF） 《程序猿之音》（链接：http://dwz.cn/3musz1） 就酱！]]></content>
      <categories>
        <category>心旷神怡</category>
      </categories>
      <tags>
        <tag>音乐</tag>
        <tag>程序员</tag>
        <tag>代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信给我搞的原创这个东西啊, Excited]]></title>
    <url>%2F2016%2F05%2F10%2Fwechat-original-copyright%2F</url>
    <content type="text"><![CDATA[今天来谈谈我这个公众号。 我的这个经历就是到了 2015 年 7 月底的时候，我在想我的笔力估计是要荒废了，我想我应该去做一个公众号。 于是我就给微信公众平台，给他们写了一个报告。小龙说欢迎你来，不过，这个 Apply for 公众号，你要去做一个报告。 我就做了个「我为朝露谁苦多」的报告，这个报告经过公众号中央委员会好几百个教授一致通过。 当天，我就写了我的第一发《我为什么写作》。 人哪，就都不知道不可预料。一个公众号的命运，当然要靠作者的自我奋斗，当然也要考虑微信官方的历史行程。 我绝对不知道，我作为一个影响力不大、粉丝数不多的公众号运营者，怎么就被选中开通原创功能了呢。 所以，今天当微信后台给我发通知： 公众号中央委员会决定了，邀请你来使用原创保护功能。 我说另请高明吧，我也实在不是谦虚，我一共就断断续续地写了几十篇阅读量和点赞数都十分渺小的文章，很惭愧，就做了这么点微小的贡献。 但是呢，小龙回去和各位教授研究后说： 你提交的原创保护功能申请已通过审核。 于是我就淫了两句诗： 苟利公号生死以，岂因祸福避趋之。 那么所以，我就开通了原创保护功能，你们要是资瓷我呢，可以在文章下方留言了。]]></content>
      <categories>
        <category>一颗赛艇</category>
      </categories>
      <tags>
        <tag>微信</tag>
        <tag>原创</tag>
        <tag>Excited</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pillar:皮勒的那些事儿]]></title>
    <url>%2F2016%2F05%2F09%2FSalt-Pillar%2F</url>
    <content type="text"><![CDATA[话说这 salt 里面的术语都起得特立独行，State 之所以叫 State ，我绕了半天才搞懂原来它是指期望达到的某种 状态，关于 State ，前面发了四篇文章，终于算是入门了。 今天，我来开始撸一撸 salt 中的另一个核心概念：Pillar。关于 Pillar 的更详细文档，请参考 这里 Pillar 是存储于 master 上面并发送给相关 minions 的一些树形结构数据： 注意：初学者很容易混淆 Grains 和 Pillar。你只需记住，Grains 是跟 minion 自身相关的静态数据，比如硬件、系统信息；Pillar 是由 master 生成并分发给 minion 的信息。 Pillar 主要可以保存下面几类数据： 高敏感度数据 比如密钥、密码之类。通过 Pillar 传输的数据可以确保只有部分相关的 minion 能收到（你总不希望 minoion A 收到 minion B 的 mysql 登陆密码吧）。 minion 的配置信息 可以在 Pillar 中配置 minion 的可执行模块、states、returners。 变量 Pillar 中可以定义用于给 minion 分配角色、组别等变量，之后，它们就能在 sls 的模版语句中访问了。 其他数据 Pillar 还可以包含其他任意键值对格式的数据。 因此，可以说 Pillar 是 Salt 系统中最重要的组件之一，怪不得老外给它取名叫 Pillar 呢，字面意思是“核心的，支柱”，看来它在 salt 系统里面的威望也很高啊。 皮勒有多重要呢，这么说吧，我们这厢经常唱红歌：“没有共产党就没有新中国”，套用到 salt 中，那就是：“没有 皮勒就没有盐”。 设置 Pillar默认情况下， pillar 已经在 salt 中运行，跟 State 类似，Pillar 也是由一个 top.sl 和一组 sls 文件构成，默认的根目录是 /srv/pillar，你需要手动创建这个目录。 首先新建一个 top 文件： /srv/pillar/top.sls: 123base: '*': - data 这个 top 文件会搜集 data.sls 里面的数据给所有的 minion: /srv/pillar/data.sls: 1info: some data 为了让刚才新建的 pillar 生效，运行如下命令，通知 minions 到 master 上获取对应的 pillar 数据： 1salt '*' saltutil.refresh_pillar 查看最新的 pillar: 1salt '*' pillar.items 更复杂点的 Pillar不像 State 语法那么严谨，pillar 可以设置任意列表或字典型数据: /srv/pillar/users/init.sls: 12345users: thatch: 1000 shouse: 1001 utahdave: 1002 redbeard: 1003 注：pillar 同样遵守和 State 文件一样的约定，users/init.sls 可以用 users 引用。 /srv/pillar/top.sls: 1234base: '*': - data - users 现在，在 state 文件中使用这些 pillar 数据： /srv/salt/users/init.sls: 12345&#123;% for user, uid in pillar.get('users', &#123;&#125;).items() %&#125;&#123;&#123;user&#125;&#125;: user.present: - uid: &#123;&#123;uid&#125;&#125;&#123;% endfor %&#125; Pillar 作为 State 参数所有的 Pillar （包括 Grains）信息在执行 State 之前就已经初始化完毕，Pillar 数据可以在 State 文件中使用来为不同的 minion 定制不同的行为。 一个简单示例：在 Pillar 中为不同的 Linux 发行版设置不同的 Apache 安装包名。 /srv/pillar/pkg/init.sls: 1234567891011pkgs: &#123;% if grains['os_family'] == 'RedHat' %&#125; apache: httpd vim: vim-enhanced &#123;% elif grains['os_family'] == 'Debian' %&#125; apache: apache2 vim: vim &#123;% elif grains['os'] == 'Arch' %&#125; apache: apache vim: vim &#123;% endif %&#125; 把这个新的 pkg 应用到 top 文件： /srv/pillar/top.sls: 12345base: '*': - data - users - pkg minions 根据自身的系统信息找到其对应的 pillar 数据，因此 state 文件可以安全地实现参数化控制。 /srv/salt/apache/init.sls: 123apache: pkg.installed: - name: &#123;&#123; salt['pillar.get']('pkgs:apache', 'httpd') &#125;&#125; 这里，某个 pillar 值在 minion 中未定义的话，可以提供一个默认值，如：上面最后一行的 httpd。 Pillar 使 state 可扩展Pillar 的设计初衷之一就是让 sls 简单可扩展，不必每次都重新编译。 比如，这样一个 state 文件： /srv/salt/edit/vim.sls: 1234567891011vim: pkg.installed: []/etc/vimrc: file.managed: - source: salt://edit/vimrc - mode: 644 - user: root - group: root - require: - pkg: vim 通过 pillar，可以很容易将它改造成一个更加灵活可扩展的 state： /srv/salt/edit/vim.sls: 123456789101112vim: pkg.installed: - name: &#123;&#123; pillar['pkgs']['vim'] &#125;&#125;/etc/vimrc: file.managed: - source: &#123;&#123; pillar['vimrc'] &#125;&#125; - mode: 644 - user: root - group: root - require: - pkg: vim 可以看到，通过 pillar， vimrc 的路径可以根据需要来配置，而不必硬编码到 state 文件： /srv/pillar/edit/vim.sls: 1234567&#123;% if grains['id'].startswith('dev') %&#125;vimrc: salt://edit/dev_vimrc&#123;% elif grains['id'].startswith('qa') %&#125;vimrc: salt://edit/qa_vimrc&#123;% else %&#125;vimrc: salt://edit/vimrc&#123;% endif %&#125; 命令行传递 PILLAR 参数Pillar 数据可以通过命令行执行： 12salt '*' state.apply pillar='&#123;"foo": "bar"&#125;'salt '*' state.apply my_sls_file pillar='&#123;"hello": "world"&#125;' 注：如果某个 key 在 minion 中已经存在，且 pillar 参数中也含有该 key 值，那么以命令行参数值为准。 姿势总结这几天，谈的主题都是 salt，从宏观地介绍到具体 state、pillar 等细节，很惭愧，有些东西翻译得不到位，信、达、雅三重境界只勉勉强强能称得上 信，如有谬误之处，还请读者不吝指正。]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>SaltStack</tag>
        <tag>pillar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Salt States 基本法四]]></title>
    <url>%2F2016%2F05%2F07%2FSalt-States-4%2F</url>
    <content type="text"><![CDATA[这周翻译了四篇有关 salt state 的文章，基本上是每天发一篇掉一个粉，到今天已经掉了 5 个粉了，技术文章阅读量低也是意料之中的。 but，I don’t care. 鲁迅爷爷说过： 真的猛男，敢于直面永不破百的阅读量和点赞数，敢于正视不忠取关的粉丝。 今天来继续讲一讲 state 中的 top 文件。 top.sls 的由来大多数系统都是由多组机器构成，同一组的每台机器分担的职责大致相同，比如数据库集群负责数据存储，web服务器专心于负载均衡、请求响应，还有一大堆的机器专门负责执行具体的业务逻辑。 为了有效地管理这些机器，管理员需要为它们分配不同的角色。比如，那些负责处理来自前台请求的机器的角色可能是这样：它们应该全部都安装好 Apache 服务器并且保证服务正常运行。 在 Salt 中，定义了不同组机器 和 它们要配置的角色 的映射关系的文件就是 top.sls。 top，顾名思义，它在所有 state 文件目录的最顶层，这些目录结构构成了一棵 state 树🌲 一个简单示例top.sls 中有三个元素： 运行环境: 运行环境是指包含了一个 top 文件和多个 state 文件的目录结构。默认为 base，可以声明多个运行环境，建议用户只在多个版本的 state 树的情况下才配置多运行环境。 目标 minions：一组机器，它们要去执行 state 文件。 State 文件: 要应用到目标 minion 的 sls 文件，每个 sls 文件描述了一个或多个 state。 三者之间的关系如下： 环境包含目标 目标包含 State 有了这些概念，我们就可以描述这样一个 top 文件：所有 ID 以 web 开头的 minion 都要执行一个叫 apache 的 State。 123base: # Apply SLS files from the directory root for the 'base' environment 'web*': # All minions with a minion_id that begins with 'web' - apache # Apply the state file named 'apache.sls' 使用 top.sls每种运行环境都通过 master 配置文件的 file_roots 属性来指定这种环境的根目录，前面介绍过了，可以为一个或多个，只要根目录列表里能找到 top.sls 即可。 在最常见的单运行环境中，只声明一个 base 环境，并且它对应的 state 树目录也只有一个。 /etc/salt/master： 123file_roots: base: - /srv/salt 接下来，/srv/salt 目录中的 top.sls 中相应地声明了 base 环境，在该环境中所有的 minion 都要应用 core 和 edit 这两个 state。 /srv/salt/top.sls： 1234base: '*': - core - edit 如上述配置，那么 Salt 将会在 /srv/salt 目录中搜索 core.sls 和 edit.sls 多运行环境这部分之前有个例子讲的很清楚了，请参考 《Salt States 基本法之三》(链接：http://t.cn/Rqn0foT) minion 匹配技巧在 top 文件中，可以通过 Grains、pillar、正则表达式等多重组合方式来筛选 minion。 下面是一个稍微复杂点的 top.sls，展示了几种匹配 minion 的技巧： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# All files will be taken from the file path specified in the base# environment in the ``file_roots`` configuration value.base: # All minions get the following three state files applied '*': - ldap-client - networking - salt.minion # All minions which have an ID that begins with the phrase # 'salt-master' will have an SLS file applied that is named # 'master.sls' and is in the 'salt' directory, underneath # the root specified in the ``base`` environment in the # configuration value for ``file_roots``. 'salt-master*': - salt.master # Minions that have an ID matching the following regular # expression will have the state file called 'web.sls' in the # nagios/mon directory applied. Additionally, minions matching # the regular expression will also have the 'server.sls' file # in the apache/ directory applied. # NOTE! # # Take note of the 'match' directive here, which tells Salt # to treat the target string as a regex to be matched! '^(memcache|web).(qa|prod).loc$': - match: pcre - nagios.mon.web - apache.server # Minions that have a grain set indicating that they are running # the Ubuntu operating system will have the state file called # 'ubuntu.sls' in the 'repos' directory applied. # # Again take note of the 'match' directive here which tells # Salt to match against a grain instead of a minion ID. 'os:Ubuntu': - match: grain - repos.ubuntu # Minions that are either RedHat or CentOS should have the 'epel.sls' # state applied, from the 'repos/' directory. 'os:(RedHat|CentOS)': - match: grain_pcre - repos.epel # The three minions with the IDs of 'foo', 'bar' and 'baz' should # have 'database.sls' applied. 'foo,bar,baz': - match: list - database # Any minion for which the pillar key 'somekey' is set and has a value # of that key matching 'abc' will have the 'xyz.sls' state applied. 'somekey:abc': - match: pillar - xyz # All minions which begin with the strings 'nag1' or any minion with # a grain set called 'role' with the value of 'monitoring' will have # the 'server.sls' state file applied from the 'nagios/' directory. 'nag1* or G@role:monitoring': - match: compound - nagios.server top.sls 是如何编译的当使用多运行环境时，没必要为每个环境都写一个 top 文件。最常见且最方便维护的方式是：将 top.sls 存放在这多种环境中的一个即可。 but，某些奇葩的工作流确实需要多个 top 文件，在这种情况下，这些多个 top.sls 将被合并，为 state 编译器生成高级数据，最后，minion 利用这些数据来编译 state。 假设，某配置如下： /etc/salt/master: 12345file_roots: first_env: - /srv/salt/first second_env: - /srv/salt/second /srv/salt/first/top.sls: 123456first_env: '*': - firstsecond_env: '*': - second 聪明的读者可能会疑问： 如果 minion 不属于某个特定的环境（或者同时匹配到多个环境），也没有 saltenv 参数传给 state 方法，state 编译器将如何处理这种冲突？ 如上，在 salt &#39;*&#39; state.apply 命令中，应用的 state 文件，是first.sls 还是 second.sls 呢？ 当冲突发生时，在 master 配置文件里，有几个相应的选项来控制这些行为： env_order 设置 state 环境的编译顺序。比如，你声明了 base、dev、prod 三种环境，你可以设置编译顺序为 [&#39;base&#39;、&#39;dev&#39;、&#39;prod&#39;]，如果有冲突的 key，以 最后 的那个环境值为准。 top_file_merging_strategy merge：这是默认选项，top 文件被合并，可以通过控制 env_order 属性来设置编译顺序。 same：只会编译匹配到的环境的 top 文件。 default_top 如果 top_file_merging_strategy 为 same并且某个环境没有 top 文件，将用 default_top 值作为该环境的 top 文件，默认值为 base。 下集预告 介绍有关 pillar 的那些事儿，吼不吼啊？ 很惭愧，今晚又做了一点微小的贡献，谢谢大家！]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>SaltStack</tag>
        <tag>states</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Salt States 基本法三]]></title>
    <url>%2F2016%2F05%2F06%2FSalt-States-3%2F</url>
    <content type="text"><![CDATA[续上集，继续研究《Salt States 基本法》，本集前情提要： 介绍如何使用 file_roots 来建立一套可同时用于研发、测试、生产线的运行环境。 sls 根目录Salt 的 sls 文件服务器允许一个运行环境下配多个根目录，如下，使用了一个本地目录和网络共享目录： /etc/salt/master: 1234file_roots: base: - /srv/salt - /mnt/salt-nfs/base Salt 会依次遍历列这些目录，直到找到对应的 sls 文件。如果有不止一个目录含有相同名字的 sls 文件，那么以最先找到的那个为准。比如，/srv/salt/foo.txt 和 /mnt/salt-nfs/base/foo.txt 都存在的话, 那么 salt://foo.txt 将引用 /srv/salt/foo.txt 文件。 配置运行环境搭建多种运行环境，其配置如下： /etc/salt/master: 12345678910file_roots: base: - /srv/salt/prod qa: - /srv/salt/qa - /srv/salt/prod dev: - /srv/salt/dev - /srv/salt/qa - /srv/salt/prod 从上面给出的各种环境下的根目录信息来看，/srv/salt/prod 下面的文件三种环境都可以用，/srv/salt/qa 下面的文件可以用于 qa 和 dev 环境，而 /srv/salt/dev 下面的文件只能用于 dev 环境。 根据如上定义的根目录次序，新编辑的 sls 文件可以先放在目录 /srv/salt/dev，发布到相应的 dev 主机去测试。 dev 测试没问题后，这些 sls 文件可以移到 /srv/salt/qa，发布到相应的 qa 主机去测试。 最后，dev 和 qa 都觉得测试没问题，就可以把它们都移到 /srv/salt/prod 目录，发布给生产环境的主机去上线运行了。 实用案例作为上面这种情况的一个典型例子，考虑这样一个网站，它安装在 /var/www/foobarcom，下面是 top.sls，它放在 /srv/salt/prod 目录，根据上述的 sls 遍历原则，三种环境都可以找到这个 top 文件: /srv/salt/prod/top.sls: 123456789base: 'web*prod*': - webserver.foobarcomqa: 'web*qa*': - webserver.foobarcomdev: 'web*dev*': - webserver.foobarcom 通过 pillar，给不同的主机设置不同的角色（开发机器？测试机器？还是直接跑在线上的机器？）： /srv/pillar/top.sls: 1234567base: 'web*prod*': - webserver.prod 'web*qa*': - webserver.qa 'web*dev*': - webserver.dev /srv/pillar/webserver/prod.sls: 1webserver_role: prod /srv/pillar/webserver/qa.sls: 1webserver_role: qa /srv/pillar/webserver/dev.sls: 1webserver_role: dev 最后，是部署网站的 sls 文件： /srv/salt/prod/webserver/foobarcom.sls: 12345678&#123;% if pillar.get('webserver_role', '') %&#125;/var/www/foobarcom: file.recurse: - source: salt://webserver/src/foobarcom - saltenv: &#123;&#123; pillar['webserver_role'] &#125;&#125; - dir_mode: 755 - file_mode: 644&#123;% endif %&#125; 从上面这个 state 可以看出，网站的源文件最初（dev 环境）放在这里：/srv/salt/dev/webserver/src/foobarcom。 首先，部署到 dev 环境: 1salt --pillar 'webserver_role:dev' state.apply webserver.foobarcom 多运行环境下的 top 文件和 state 遍历规则有点恶心： 如果没有明确指定指定运行环境（比如上面这条命令），minion 会在每个运行环境对应的根目录（一个或多个）中搜索 top.sls 并按照 top_file_merging_strategy （这里默认为：merge）来处理多个 top 文件的冲突情况。执行哪个 state 也是类似规则，会在 merge 后的 top.sls 文件里的每个运行环境都匹配一遍。 关于这部分的详细文档，请参考 这里 当然，我们这个例子中，webserver_role 匹配到了 /srv/salt/prod/top.sls 中的 dev 环境，因此准备执行 webserver.foobarcom 这个 state。 因此，上面这个命令还可以指定运行环境 saltenv＝dev。 1salt --pillar 'webserver_role:dev' state.apply webserver.foobarcom saltenv=dev 当在 dev 环境测试通过后，网站源文件可以从 /srv/salt/dev/webserver/src/foobarcom 移到 /srv/salt/qa/webserver/src/foobarcom，部署到 qa 环境去测试： 1salt --pillar 'webserver_role:qa' state.apply webserver.foobarcom 最后，当在 qa 环境测试通过后，网站源文件就可以从 /srv/salt/qa/webserver/src/foobarcom 移到 /srv/salt/prod/webserver/src/foobarcom，部署到生产线运行： 1salt --pillar 'webserver_role:prod' state.apply webserver.foobarcom 得益于 salt 到根目录体系，即使网站源文件移到了 /srv/salt/prod，它们在 dev 和 qa 环境下同样可以访问。 期望是美好的，but，很诡异的是，这最后部署到 prod 到步骤，出错了： 哎呀，真是买了个表啊～看上图，src 文件夹明明就在 prod 下面啊？！这个问题，我看了半天，头都大了…… 折腾了半天，终于搞明白了：因为 file_roots 里面并没有声明有 prod 这个运行环境啊，亲！ 把 /srv/salt/prod/webserver/foobarcom.sls 中的这行： 1- saltenv: &#123;&#123; pillar['webserver_role'] &#125;&#125; saltenv 改为 base 或 dev 或 qa 即可。 下集预告 介绍有关 pillar 的那些事儿，吼不吼啊？ 很惭愧，今晚又做了一点微小的贡献，谢谢大家！]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>SaltStack</tag>
        <tag>states</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Salt States 基本法二]]></title>
    <url>%2F2016%2F05%2F05%2FSalt-States-2%2F</url>
    <content type="text"><![CDATA[五一小长假，魏泽西事件，谁也没想到这事闹得这么大，惊动了习大大出来亲自做指示：「搜索结果不能以给钱多少作为排序依据」，当社会民生问题上升到国家机器的高度，这事推动起来就好办点了，这是积极的一面。 再说黑暗的一面，在此事件中，百度的竞价排名、医疗广告备受诟病，有部分知乎大V收黑钱，昧着良心给那些为百度洗地的答案「点赞」，结果被人扒出来吊打一顿，个中过程，一波三折，撕逼打脸此起彼伏…… 详细报道，请观看明晚 19 点 35 分播出的焦点访谈节目《知乎6大V为百度洗地被永久封号》（链接：http://t.cn/Rq8r9zg） 只不过一不小心点了个赞，瞬间几百万粉丝就没了，大V们的人品、口碑及其附带的一系列营销价值一夜坍塌，被永久地钉在知乎的耻辱柱上，受万人唾骂？请问，这事能怪谁？ 人在做天在看，且问苍天绕过谁？ 勿以恶小而为之啊！ 好啦，继续研究《Salt States 基本法》，本集前情提要： 讨论有关 sls 模版以及 include, extend 等高级配置语法。 sls 模版当你编写 sls 文件时，可能会用到编程语句，这可以用模版语言 { % % } 表示。默认的模版渲染器是 Jinja2，当然，你也可以换成其他的，修改 master 配置文件的 render 值即可。 你写好的所有 state 模块都会发送给 Jinja2 去渲染、编译。 好！下面，就让我们来往里面加点料：模版标记语句，示例如下： 1234&#123;% for usr in ['moe','larry','curly'] %&#125;&#123;&#123; usr &#125;&#125;: user.present&#123;% endfor %&#125; 渲染后的 sls 文件将变成这样： 123456moe: user.presentlarry: user.presentcurly: user.present 下面是个更复杂的例子： 1234567891011121314151617# Comments in yaml start with a hash symbol.# Since jinja rendering occurs before yaml parsing, if you want to include jinja# in the comments you may need to escape them using 'jinja' comments to prevent# jinja from trying to render something which is not well-defined jinja.# e.g.# &#123;# iterate over the Three Stooges using a &#123;% for %&#125;..&#123;% endfor %&#125; loop# with the iterator variable &#123;&#123; usr &#125;&#125; becoming the state ID. #&#125;&#123;% for usr in 'moe','larry','curly' %&#125;&#123;&#123; usr &#125;&#125;: group: - present user: - present - gid_from_name: True - require: - group: &#123;&#123; usr &#125;&#125;&#123;% endfor %&#125; 在 sls 模块中使用 Grains通常来说，根据主机操作系统的不同，一个 state 模块需要执行不同的动作。前面我们介绍过了，Apache 服务器在不同操作系统下，它的软件安装包名是不一样的。这时，grains 就派上用场了，比如，下面的例子根据不同的操作系统信息确定 Apache 的安装包名： 1234567apache: pkg.installed: &#123;% if grains['os'] == 'RedHat' %&#125; - name: httpd &#123;% elif grains['os'] == 'Ubuntu' %&#125; - name: apache2 &#123;% endif %&#125; 在 sls 模块中使用环境变量你可以在 state 中使用 salt[&#39;environ.get&#39;](&#39;VARNAME&#39;) 来访问某个环境变量。 新建一个 test.sls 文件： 123file.managed: - name: /tmp/hello - contents: &#123;&#123; salt['environ.get']('MYENVVAR') &#125;&#125; 然后，命令行运行： 1MYENVVAR="world" salt-call state.template test.sls 利用环境变量来检查错误信息: 1234567891011121314&#123;% set myenvvar = salt['environ.get']('MYENVVAR') %&#125;&#123;% if myenvvar %&#125;file.managed: - name: /tmp/hello - contents: &#123;&#123; salt['environ.get']('MYENVVAR') &#125;&#125;&#123;% else %&#125;Fail - no environment passed in: test: A. fail_without_changes&#123;% endif %&#125; 调用其他 sls 模块sls 模版中可以访问 minion 上面的所有 salt 模块，以及模块内的方法： 下面的例子演示了调用了 file 模块的 group_to_gid 方法，参数为 some_group_that_exists。 123moe: user.present: - gid: &#123;&#123; salt['file.group_to_gid']('some_group_that_exists') &#125;&#125; 再看另外一个例子，使用 network 模块的 hw_addr 方法来读取 eth0 的 MAC 地址。 1salt['network.hw_addr']('eth0') 高级 sls 语法includeState 基本法《一》的例子中展示了如何跨文件引用 sls，下面再举一个例子： python/python-libs.sls: 12python-dateutil: pkg.installed python/django.sls: 1234567include: - python.python-libsdjango: pkg.installed: - require: - pkg: python-dateutil extend通过 extend 语句，你可以添加某些内容到已有的 sls 中，比如，当发现 vhost 配置文件被修改后，马上重启 Apache 服务器。 apache/apache.sls: 12apache: pkg.installed apache/mywebsite.sls: 12345678910111213include: - apache.apacheextend: apache: service: - running - watch: - file: /etc/httpd/extra/httpd-vhosts.conf/etc/httpd/extra/httpd-vhosts.conf: file.managed: - source: salt://apache/httpd-vhosts.conf 还是那个注意点：在使用 extend时，会添加 require/watch 的内容，而不是覆盖。 命名空间你可以设置 state 的 name 属性 （如果没有指定 name 属性，它的默认值就是 ID)。 在大多数情况下，重置 name 属性是一个非常实用的小技巧。 其一，避免 ID 声明冲突。 比如，下面的两个 state 不能都用 /etc/motd 作为 ID，但可以通过将 /etc/motd 设为 name 属性来规避这点。 123456789motd_perms: file.managed: - name: /etc/motd - mode: 644motd_quote: file.append: - name: /etc/motd - text: "Of all smells, bread; of all tastes, salt." 其二，方便其他 state 引用。 ID 名称太长的话，其他 state 来引用不方便还极易出错，比如，下面的例子，将这串冗长的 /etc/apache2/sites-available/mywebsite.com 设为 name 属性，ID 名用 mywebsite 姿势就优雅得多了，想引用几次就引用几次，简单明了。 123456789101112131415mywebsite: file.managed: - name: /etc/apache2/sites-available/mywebsite.com - source: salt://mywebsite.coma2ensite mywebsite.com: cmd.wait: - unless: test -L /etc/apache2/sites-enabled/mywebsite.com - watch: - file: mywebsiteapache2: service.running: - watch: - file: mywebsite names 声明另外一个更牛逼的技巧：使用 names 声明一次声明多个 ID，这样就不必在 sls 文件中使用一堆 ungly 的循环语句了。 比如，本集开头的例子可以重写成这样： 123456stooges: user.present: - names: - moe - larry - curly 下集预告本集主要讨论了有关 include, extend 以及 sls 模版等高级配置语法，下集将介绍如何使用 file_roots 来建立一套可同时用于研发、测试、生产线的运行环境。 很惭愧，今晚又做了一点微小的贡献，谢谢大家！]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>SaltStack</tag>
        <tag>states</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Salt States 基本法一]]></title>
    <url>%2F2016%2F05%2F03%2FSalt-States-1%2F</url>
    <content type="text"><![CDATA[关于 Salt States ，《Salt Stack 一日游》（链接：http://t.cn/RqYQK0Q）从整体上介绍了 salt 系统以及各个组件，接着《如何使用盐态》(链接：http://t.cn/Rq8vJVF)把 state 相关的知识过了一遍。但，这些多半是理论居多，实践得少，就像程序员学习一门新的编程语言一样，你讲再多都不如一个 Hello World 来的亲切。 纸上得来终觉浅，得知此事须躬行。 本文的目的就是手把手教你“怎样快速地运用 Salt States 来配置系统”。当然啦，想要挖掘更多 Salt States 的内幕信息，请移步官方文档，那里有你想知道的所有奇技淫巧。 这个示例将分为四集，我打算从今天开始每晚放出一集熟肉版。 本集前情提要： 使用 Salt 配置一个 minion，使之运行 Apache 服务器，并确保该服务正常运行。 首先，请检查下你是否正确安装并配置好了 salt－master 和 salt-minion 的运行环境。要是连这个你都还不会，额～你也没必要往下继续看了。 建立 Salt State 树🌲States 纯粹是存放在 master 上的一些文本文件，minions 根据自身需要到 master 的文件服务器上拉取，这些 state 文件就构成了 State 树🌲 因此，为了让 salt 能使用 state 配置系统，必须先设置好 Salt 文件服务器。编辑 master 的配置文件(/etc/salt/master)中的 file_roots 字段，取消下面几行的注释： 123file_roots: base: - /srv/salt 重启 salt－maser 来使配置生效： 12pkill salt-mastersalt-master -d 准备 top 文件在 master 中刚刚设置好的 state 文件目录(默认为：/srv/salt)中，新建一个 top.sls 文件并写入如下内容： 123base: '*': - webserver top 文件可以区分多个运行环境（这个以后会再详细论述），默认的运行环境是 base。在 base 环境下，定义了一系列的 minion，对于上面这个例子来说，它适用于所有(*) minion 主机。 新建 SLS 文件在 top 文件所在目录中，新建一个 webserver.sls 文件，文件内容为： 123apache: # ID declaration pkg: # state declaration - installed # function declaration 第 1 行，是 ID 声明，可以为任何标识符，本例中它指代将要安装的软件名（apache）。 注意：Apache 服务器在不同的操作系统中，其软件安装包名可能不一样，比如，在 Fedora 系统中叫 httpd，但是在 Debian 或 Ubuntu 中，它叫 apache2。 第 2 行，是 State 声明，定义使用的是哪个 Salt States 模块，本例中，我们使用 pkg state 模块来安装某个指定的软件包。 第 3 行，是 方法声明，定义使用 pkg state 模块中的哪个方法。 安装软件包接下来，让我们来运行这个 state。在 maser 上打开终端，运行： 1salt '*' state.apply master 通知所有的目标 minions 来执行 state.apply 方法。当 state.apply方法不带任何 sls 文件作为参数时，minion 将下载 master 的 top 文件并尝试去匹配里面的表达式（top.sls 的第 2 行），如果匹配上，它将下载对应的 sls 文件（webserver.sls），编译（还记得yaml_jinja 吗？），运行。 一旦执行完毕，minion 会将它所执行的具体动作及结果汇报给 master。 SLS命名空间你可能注意到，本例中红 webserver 指代 webserver.sls，在 top.sls中 sls 文件的引用规则如下： .sls 后缀被舍弃（如：webserver.sls 变成 webserver） 允许子目录存在以便更好地管理 sls 文件。 每个子目录可以用.（沿用 python import 某个模块的习惯）或者/来表示（webserver/dev.sls 可以用 webserver.dev 表示） 由于/表示成.，因此 sls 文件名中除了后缀.sls，其他部分不能包含有.。比如：webserver_1.0.sls 将无法匹配，webserver_1.0 将匹配webserver_1/0.sls。 子目录的 init.sls 可以直接用目录名引用。因此，webserver/init.sls 可以用 webserver 指代。 如果 webserver.sls 和 webserver/init.sls 都存在，将忽略 webserver/init.sls 并用 webserver 指代 webserver.sls。 排查问题如果事情不向我们想象得那么顺利，下面这些小提示能帮助我们排查问题出在哪里。 打开日志开关输出更多的日志信息: 1salt-minion -l debug 前台运行 minion直接把 minion 放到前台运行可以直接看到任何输出信息： 1salt-minion 延长超时时间比如，将 salt 运行的超时设为 60 秒： 1salt -t 60 最好的方式是，将这几套合拳结合起来一起用： 12salt-minion -l debug # On the minionsalt '*' state.apply -t 60 # On the master 调用多个 States你可以在一个 ID 声明下面指定多个 State 声明。举个栗子🌰：修改前面的 webserv.sls，如果 Apache 没有运行，则启动它。 12345apache: pkg.installed: [] service.running: - require: - pkg: apache 你可以试着先停止 Apache 服务器，再运行一遍 state.apply，并观察输出结果。 依赖其他 States真是一个赛艇蛤，现在我们已经安装了一个 Apache 服务器，让我们来更多点膜法：给我们的网站添加一个个性化的 HTML 文件。 很明显，只有网页文件却没有相应的 web 服务器是无法让网站工作起来的，因此在部署网页文件前必须检查 Apache 服务器是否已安装并运行。 在 webserver/init.sls 文件底部加入如下内容： 1234567891011121 apache:2 pkg.installed: []3 service.running:4 - require:5 - pkg: apache67 /var/www/index.html: # ID declaration8 file: # state declaration9 - managed # function10 - source: salt://webserver/index.html # function arg11 - require: # requisite declaration12 - pkg: apache # requisite reference 第 7 行是 ID 声明，本例中它是将要安装的 HTMl 文件路径。 注：Apache 网站的默认根目录在不同系统下面可能不一样，在 Debian 系统下它是 /var/www。 第 8 行是 State 模块声明，本例中使用了 State 的 file 模块。 第 9 行是 State 模块的方法声明，managed 方法会从 master 下载文件并将其存放在指定的位置。 第 10 行是方法的参数声明，这里传递了 source 参数给 managed。 第 11 行是 Requisite 必要语句。 第 12 行是 Requisite 引用的某个 state 及其 ID，本例中，它引用了前面的 ID 声明(apache)，它告诉 salt 只有 Apache 已安装才能部署网站文件。 下一步，新建如下内容的 index.html 文件并保存于 webserver 目录(/srv/salt/webserer)中. 1234567&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt;&lt;title&gt;Salt rocks&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;This file brought to you by Salt&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 最后，终于到了最后，再执行一遍 state.apply 命令，minion 会从 master 的文件服务器上下载该 index.html 文件并把它存放在 Apache 网站的根目录中。 1salt '*' state.apply 验证下这个 index.html 是否真的已经在 minion 的网站中。 下集预告本集主要给大家演示了如何快速地让 salt state 工作起来，下集将讨论有关 include, extend 以及 sls 模版等高级配置语法。 很惭愧，今晚只做了一点微小的贡献，谢谢大家！]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>SaltStack</tag>
        <tag>states</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于「魏则西事件」的解读的解读]]></title>
    <url>%2F2016%2F05%2F02%2FInterpretation-on-Wei-Zexi-event%2F</url>
    <content type="text"><![CDATA[五一小长假，我的朋友圈被「魏则西事件」刷屏了：洗地文、公关文、声讨文…… 各路自媒体写手从不同角度、以不同体位、站在不同立场对此事件进行了或深或浅的解读，小明在此提炼总结下几篇我觉得不错的文章，算是对这些解读的解读吧。 冯大辉作为一枚潜伏在地下党的准知识分子，经常鞭挞时弊，他虽外表赢弱但内心彪悍更要命的是骂起人来毫不嘴软，这次，他继续朝他内心无比憎恨的百度开炮，他以公众号「小道消息」为正面战场，一篇《青年魏则西之死》（链接：http://t.cn/RqTD5hX）迅速点燃朋友圈，阅读量分分钟破 10万+。 接着，他以公众号「坏时代」为敌后战场，一篇《鲁迅如果在写自媒体》（链接：http://t.cn/RqTef4D）以「我去年买了个包」为结束语毫不留情地唾骂了几桩为百度洗地的经典说辞。 「歪理邪说」三个月前以一篇《我是如何坚持10多年站在反百度第一线的》（链接：http://t.cn/RqTDpRQ）揭露百度把血友吧贱卖给某来路不明的骗子医院，这次也没有放过百度，《狼性多了，人性就少了》（链接：http://t.cn/RqTkMo3）这篇情绪激烈的声讨文直陈「这家公司罔顾道德良知追逐利润充满了狼性，以至于没剩下几分人性」，并号召读者一起来骂百度： 我们未必能骂死这家公司，但至少我们能骂到媒体不敢为这家公司造谣，记者不敢被这家公司请去迪拜。如果有一天能做到这样，这件事就已经走在了成功的道路上。不要因为看起来没什么效果而不说话，不要因为怕得罪人而不敢说话，发出自己的声音吧。 这就像一块大石头横在路上挡路，你踢了它一脚，它纹丝不动，你又踢了一脚，还没动，但你并不在乎，继续踢，累了休息一下继续踢。后来越来越多的人加入这个行列一起踢，他们并不在乎旁边的人说着风凉话，也不在乎有人笑他们愤青脑残别有用心，只管一脚一脚踢石头。终于有一天，这块巨石松动了，终于有一天，这块巨石轰然滚到了山下。 公众号「余晟以为」推送的这篇《看得见的与看不见的》（链接：http://t.cn/RqHZq5m）解读的角度很特殊： 眼前看得见的，为某些人津津乐道的「实力」到底是什么，它们来自何方，又用在了何处。在它们背后看不见的地方，我们又为此付出了多少代价呢？ 《令人可憎的信息不对称》（链接：http://t.cn/RqHZH7m）思考了魏则西事件中的问题的本质：信息不对称。 作恶的百度最有可能伤害到的人就是你的父母、亲人。我们这辈尚且还受过相对良好的教育，可以远离百度，但是对于我们的父母来说，远离百度不是一件容易的事。 魏武挥这篇《关于百度，这是一篇很意识流写法的文章》（链接：http://t.cn/RqHwpQF）是这两天我见过的关于此事解读得最有深度、信息量最大的一篇文章，不愧为交大教授。里面有几个观点值得特别拎出来： 如果谷歌可以和百度充分竞争，百度不至于那么糟糕。但是，谷歌即便和百度充分竞争，一样干不过百度。 未来的公关重要到公关部已然不重要了：当企业里很多人（尤其是关键的、核心的人员）自身有公关意识时，公关部能起到的作用有限。 改革开放后，中国在资本主义道路上飞快狂奔：资本主义历经的资源、管理、技术、金融这四个阶段，中国一下子撞上了管理资本主义、技术资本主义和金融资本主义三个。 基于人际关系、社交链的网络工具普及的大环境下，删帖已经于事无补。 百度在过去的诉讼中，让管理部门支持了它的诉求：百度推广不是广告，因而规避了《广告法》的监管。 《所有的企业道德问题，都是法律问题》（链接：http://t.cn/RqHAFEH），从法律与道德的角度看问题，网络舆论会让企业迫于压力而做出让步，但是并不能解决企业的问题。 百度固然是首恶，法律的不健全，则是酿成魏式悲剧的社会土壤。 我们要谋求的是大众的权利，而不是发泄自己的情绪。 法律并不能解决所有的问题，我们永远在和时间赛跑。 《深度！起底「魏则西事件」背后的莆田系》（链接：http://t.cn/RqHUXKE）挖掘百度医疗广告的最大投放商、中国医疗史上最独特的群体：福建莆田系。该文也是迄今为止有关这一群体最全面、最深入的报道。类似的报道还可以参见另外令人毛骨悚然的一篇《为什么中国的军队、武警医院绝不能去！（附部分医院名单）》（链接：http://t.cn/RqH4J7g），还好，知乎上有个帖子整理了莆田系开的医院，能躲则躲吧：《哪些民营医院（包括被承包的公立医院）属于「莆田系」？》（链接：http://t.cn/R4CFHeI） 凤凰网发布的这篇《独家丨魏则西之死，舆论是如何裂变的》（链接：http://t.cn/RqHG7KU），从传播学的角度切入： 大风往往起于青萍之末。 风暴不可预测，只能事后抢救。 在坐实通过百度搜索获知武警二院的事实之后，谁该为魏则西之死负责，以及这场风波的最终指向，并没有变得更加明晰，人们还在为竞价排名是否有罪吵个不停；而有关百度的身份、定位和起家历史，则成为一个可以讨论，但却无从具体下手的中国难题。 站在科学的角度，魏则西这件事情的伤感之处在于： 滑膜肉瘤晚期基本上是必死的，正规医院都表示无能为力，但求胜心切的这一家人不愿承认这种令人绝望的现实，于是本能地抓住一切救命稻草，正是这种迫切心态成为欺诈者瞄准的弱点，贩卖虚假的希望，把这个家庭当成肉猪来宰。可是，谁又做得到从容认命、坦然离世呢。 「刘备我祖」将此事件列入了《史记·魏则西传》（链接：http://t.cn/RqTDGPi）。]]></content>
      <categories>
        <category>心旷神怡</category>
      </categories>
      <tags>
        <tag>百度</tag>
        <tag>魏则西</tag>
        <tag>滑膜肉瘤</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用盐态?]]></title>
    <url>%2F2016%2F04%2F30%2Fhow-to-use-salt-state%2F</url>
    <content type="text"><![CDATA[关于，SaltStack 这个牛逼的配置管理神器，上周我写了篇入门级的 《SaltStack 一日游》。 今天，深入点研究 SaltStack 中的精华部分：“Salt States”。 「Salt States」 翻译成什么好呢？我想了半天，乳头都快想破了。老外整的这些玩意翻译成中文就不伦不类了，索性就按照字面意思 one by one 地译成「盐态」好了，蛤蛤～ 注：“乳”字，在汉语中除了指“分泌奶水的器官、乳汁”等含义，还有“初生的、幼小的、小”的意思，除了“乳头”，类似的例子还有： 我的乳名（小名）叫小明。 我家门前有条乳沟（小沟）。 今天，我就来讲讲「盐态」到底是怎么回事。以下译自: HOW DO I USE SALT STATES? KISS简洁，简洁，简洁 众多强大而有力的设计都建立在简单的原则之上。Salt State 系统也努力向 K.I.S.S(Keep It Stupidly Simple） 看齐。 SLS（代表 SaLt State文件）是 Salt State 系统的核心。SLS描述了系统的目标状态，由格式简单的数据构成，经常被称作配置管理。 只是数据而已深入学习之前，明白 SLS文件只是结构化的数据而已 是很有用的。看懂和编写SLS文件不需要理解这一点，但会让你体会到SLS系统的强大。 SLS 文件本质上只是一些 dictionaries，lists，strings和numbers。这种设计让SLS文件非常灵活，可以满足开发者的各种需求，而且可读性很高。写得越多，就越清楚到底写得是什么。最终的结果是一个简单易懂的系统，它可以随着开发者或管理者的需求而变化。 top 文件下面的 sls 示例文件可以通过一个叫 top.sls 的文件来分派给主机执行。这个文件的详细信息可参考 here 默认的数据:YAMLSalt 默认使用YAML 这种最简单的序列化数据格式来表达SLS数据。 典型的SLS文件如下： apache/init.sls: 12345apache: pkg.installed:[] service.running - require: - pkg: apache 这些数据确保名为apache的软件包处于已安装状态，服务进程apache处于运行状态。 这些数据简洁，易于理解。下面简单解释一下： 第 1 行是这段数据的ID，被称作ID声明。这个ID是将要执行的这些命令的名字。 第 2、3 行包含了要执行的State 模块方法，它的格式为&lt;模块名&gt;.&lt;方法名&gt;。pkg.installed 使用系统本地的软件包管理器管理将要安装的软件；service.running确保指定的服务必须运行。 最后，是关键字require，它是必要语句 Requisite，确保了apache服务只有在成功安装软件包后才会启动。 添加配置文件和用户部署像apache这样的web服务器时，还需要添加其他的内容。需要管理apache的配置文件，需要添加运行apache服务的用户和组。 12345678910111213141516171819202122232425apache: pkg.installed: [] service.running: - watch: - pkg: apache - file: /etc/httpd/conf/httpd.conf - user: apache user.present: - uid: 87 - gid: 87 - home: /var/www/html - shell: /bin/nologin - require: - group: apache group.present: - gid: 87 - require: - pkg: apache/etc/httpd/conf/httpd.conf: file.managed: - source: salt://apache/httpd.conf - user: root - group: root - mode: 644 这个SLS大大扩展了上面的例子，增加了配置、用户、组，还有一个新的必要语句：watch。 添加 state 非常简单：user和group这两个state添加在apache这个ID下，所以增加的user和group名字都是apache。require语句确保了只有在apache这个group存在时才建立user，只有在apache这个package成功安装后才会建立group。 接下来，service中的require语句换成了watch，从需要 1 个软件包改为监视 3 个state（分别是pkg、file和user）。watch语句和require很相似，都能保证被监视或需要的state在自己之前执行，但是watch还有其他作用。在被监视的state发生变化时，定义watch语句的state会执行自己的watcher函数。也就是说，更新软件包、修改配置文件、修改apache用户的uid都会触发service state的watcher函数。在这个例子中，service state的watcher会重启apache服务。 多个SLS文件要想可扩展性地部署 Salt State 系统，将会用到不止一个 SLS 文件。上面的例子中只使用 1 个SLS文件，2 个或多个SLS文件可以结合形成State Tree。上面的例子还使用了一个奇怪的文件来源 salt://apache/httpd.conf，这个文件也必须要找的到。 SLS文件以一定的目录结构分布在master上；SLS和要下发到minion上的文件都只是普通文件。 上面例子中的文件在 Salt根目录(/etc/salt/)下： 12apache/init.slsapache/httpd.conf httpd.conf 只是apache目录下的一个普通文件，可以直接引用。 使用多个SLS文件可以更加灵活方便，以SSH为例： ssh/init.sls: 1234567891011openssh-client: pkg.installed/etc/ssh/ssh_config: file.managed: - user: root - group: root - mode: 644 - source: salt://ssh/ssh_config - require: - pkg: openssh-client ssh/server.sls: 123456789101112131415161718192021222324252627282930313233343536373839404142434445openssh-client: pkg.installed/etc/ssh/ssh_config: file.managed: - user: root - group: root - mode: 644 - source: salt://ssh/ssh_config - require: - pkg: openssh-clientssh/server.sls:include: - sshopenssh-server: pkg.installedsshd: service.running: - require: - pkg: openssh-client - pkg: openssh-server - file: /etc/ssh/banner - file: /etc/ssh/sshd_config/etc/ssh/sshd_config: file.managed: - user: root - group: root - mode: 644 - source: salt://ssh/sshd_config - require: - pkg: openssh-server/etc/ssh/banner: file: - managed - user: root - group: root - mode: 644 - source: salt://ssh/banner - require: - pkg: openssh-server 注：在ssh/server.sls中，用了两种不同的方式来表示用Salt管理一个文件。在ID为/etc/ssh/sshd_config段中，直接使用file.managed作为state声明，而在ID为/etc/ssh/banner段中，使用file作为state声明，附加一个managed属性。两种表示方法的含义与结果完全一样，只是写法不同。 现在 State Tree 如下: 1234567apache/init.slsapache/httpd.confssh/init.slsssh/server.slsssh/bannerssh/ssh_configssh/sshd_config ssh/server.sls 中使用了include语句。include将别的SLS添加到当前文件中，所以可以require或watch或 extend（憋着急，下面马上会讲到）被引用的SLS中定义的内容。 include语句使得state可以跨文件引用，使用include相当于把被引用的内容文件添加到自身。 注：你可能注意到有些 SLS 文件叫 init.sls，有些又不是，关于它的约定规则可以参考 States Tutorial Extend:扩展被引用的SLS数据有的时候，SLS 文件需要扩展，也许是 apache 服务需要监听另外一个文件，或者在某种特殊条件下，某个文件需要添加进来。 在下面的例子中，第一个将添加一个自定义的 banner 文件到 ssh，第二个多添加一个watcher到 apache 以便引入mod_python。 ssh/custom-server.sls: 1234567include: - ssh.serverextend: /etc/ssh/banner: file: - source: salt://ssh/custom-banner python/mod_python.sls: 1234567891011include: - apacheextend: apache: service: - watch: - pkg: mod_pythonmod_python: pkg.installed custom-server.sls 文件使用 extend 语法来覆盖banner 的下载路径文件，相当于替换了banner的配置文件。 在mod_python.sls 文件中, 添加了 mod_python，但是更关键的是 apache 服务扩展成为它还要额外监听这个 mod_python 包。 Extend 使得 SLS更加灵活，在处理SLS时，会将其中的内容解析成Python中的dict（当然这个dict中会嵌套dict和list）。 扩展 apache 的 watch，相当于往list里面 添加 一个元素。 修改 banner 文件的下载路径相当于 修改 dict中的某个key对应的值。 注：在使用 extend时，会添加 require/watch 的内容，而不是覆盖。 Render System:理解渲染系统由于SLS仅仅是数据，所以它不是一定得用YAML来表达。Salt默认使用YAML，只是因为易学易用。只要有对应的渲染器，SLS文件可以用任何方式表达。 注：Salt关心的是最终解析出来的数据结构，只要你的渲染器能够按要求返回这个数据结构，它不关心你是如何编写的。 Salt默认使用yaml_jinja渲染器，yaml_jinja渲染器先用jinja2模板引擎处理SLS源文件，然后再调用YAML解析器。这种设计的好处是: 可以在SLS文件中使用所有的编程结构。 jinja2能怎么用，这里就能怎么用。条件，循环，Python代码……神马都可以 其他可用的渲染器还包括：yaml_mako，使用 Mako模板引擎；yaml_wempy，使用Wempy模板引擎；py，直接使用Python写SLS文件；pydsl，建立在Python语法基础上的描述语言。 yaml_jinja: 默认的渲染器关于jinja模板引擎的使用请参考其 官方文档 Salt在和渲染器工作时，已经往里面传进去了一些十分有用的数据。在基于模板引擎的渲染器里，可以从3个组件中获取需要的数据：salt，grains和pilla。在模板文件中，可以用salt对象执行任意的Salt function，使用grains访问Grains数据。示例如下： apache/init.sls: 12345678910111213141516171819202122232425262728293031apache: pkg.installed: &#123;% if grains['os'] == 'RedHat'%&#125; - name: httpd &#123;% endif %&#125; service.running: &#123;% if grains['os'] == 'RedHat'%&#125; - name: httpd &#123;% endif %&#125; - watch: - pkg: apache - file: /etc/httpd/conf/httpd.conf - user: apache user.present: - uid: 87 - gid: 87 - home: /var/www/html - shell: /bin/nologin - require: - group: apache group.present: - gid: 87 - require: - pkg: apache/etc/httpd/conf/httpd.conf: file.managed: - source: salt://apache/httpd.conf - user: root - group: root - mode: 644 这个例子很容易理解，用到了jinja中的条件结构，如果grains中的os表明minion的操作系统是Red Hat，那么Apache的软件包名和服务名应当是httpd。 再来一个更niubility的例子，用到了jinja的循环结构，在设置 MooseFs分布式chunkserver的模块中： moosefs/chunk.sls: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849include: - moosefs&#123;% for mnt in salt['cmd.run']('ls /dev/data/moose*').split() %&#125;/mnt/moose&#123;&#123; mnt[-1] &#125;&#125;: mount.mounted: - device: &#123;&#123; mnt &#125;&#125; - fstype: xfs - mkmnt: True file.directory: - user: mfs - group: mfs - require: - user: mfs - group: mfs&#123;% endfor %&#125;/etc/mfshdd.cfg: file.managed: - source: salt://moosefs/mfshdd.cfg - user: root - group: root - mode: 644 - template: jinja - require: - pkg: mfs-chunkserver/etc/mfschunkserver.cfg: file.managed: - source: salt://moosefs/mfschunkserver.cfg - user: root - group: root - mode: 644 - template: jinja - require: - pkg: mfs-chunkservermfs-chunkserver: pkg.installed: []mfschunkserver: service.running: - require:&#123;% for mnt in salt['cmd.run']('ls /dev/data/moose*') %&#125; - mount: /mnt/moose&#123;&#123; mnt[-1] &#125;&#125; - file: /mnt/moose&#123;&#123; mnt[-1] &#125;&#125;&#123;% endfor %&#125; - file: /etc/mfschunkserver.cfg - file: /etc/mfshdd.cfg - file: /var/lib/mfs 这个例子展示了jinja的强大，多个for循环用来动态地检测并挂载磁盘，多次使用salt对象（这里使用了cmd.run这个执行模块）执行shell命令来收集数据。 简单介绍Python和PyDSL渲染器在任务逻辑非常复杂时，默认的yaml_jinja渲染器不一定满足要求，这时可以使用Python渲染器。 Normally a YAML renderer should be used for the majority of SLS files, but an SLS file set to use another renderer can be easily added to the tree. 正常情况下，YAML的渲染器应该可以适用于绝大部分 SLS 文件，但是使用其他的渲染器的 SLS 文件同样可以轻易地适配到 sls tree 中。 下面是一个非常简单的基本Python SLS文件： python/django.sls: 12345678#!py def run(): ''' Install the django package ''' return &#123;'include': ['python'], 'django': &#123;'pkg': ['installed']&#125;&#125; 这个例子也很好理解，第 1 行告诉Salt不使用默认的渲染器，而是用py。接着定义了函数run，这个函数的返回值必须符合Salt的要求，即HighState数据结构。 如果换用pydsl渲染器，上面的例子会更简洁： python/django.sls: 1234#!pydslinclude('python', delayed=True)state('django').pkg.installed() 如果用YAML，会是下面这个样子： 12345include: - pythondjango: pkg.installed 这也可以看出，正常情况下使用YAML是非常合适的，但如果有需要时，使用纯粹的Python SLS可以非常犀利地装逼哦。 运行和调试 Salt States写好的SLS如何才能应用到minion呢？ 在SaltStack中，远程执行是一切的基础。执行命令salt &#39;*&#39; state.apply 会让所有的minion到master上来取走自己的SLS文件，然后在本地调用对应的state模块（user，pkg，service等，内置的 state 模块列表在 这里）来达到SLS描述的状态。 如果这条命令只返回minion的主机名加一个&#39;:&#39;，多半是哪一个SLS文件有错。如果minion是以服务进程启动，执行命令： 1salt-call state.aply -l debug 可以看到错误信息，便于调试。minion还可以直接在前台以debug模式运行： 1salt-minion -l debug What’s next？ 这篇文章只是对 Salt States 的初步介绍，下一步请继续阅读 Pillar 部分，官方文档 在此。]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>SaltStack</tag>
        <tag>state</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[此图片来自微信公众平台,未经允许不可引用]]></title>
    <url>%2F2016%2F04%2F26%2Fwechat-picture-unreferenced-without-permission%2F</url>
    <content type="text"><![CDATA[一直以来，我都是用 Markdown 语法写作，写完后先发表到微信公众号里，然后同步到我的个人博客 hxz.ink（这可作为微信公众号的一个备份，防止公众号被封后文章无可访问的尴尬）。 博客用 hexo 部署，每次需要发表文章时，先用 hexo g 命令渲染成 html 再用 hexo d 命令一键部署，两个命令搞定，真的不要太 easy～ 但，便捷之余还是有一点小疙瘩，困扰我许久：Markdown 文章里插入图片的用户体验。 繁琐＋闹心这个问题，且让我细说如下： Mardown 中显示图片的语法为： 1![some_info](pic_address) 其中，pic_address 是必须的，它支持本地路径和网络 url，比如： 12345![](test.jpg) //相对路径![](/Users/hxz/Desktop/screenshot.png) //绝对路径![](some_picture_url) //网络地址 假设你要往文章里插入一张图片，这分为两种不同情况： 本地图片你需要先自己准备好素材，然后用相对或绝对路径引用它。但，这图片目前只能你的电脑里显示，为了保证你发布文章后，别人也能看到这张图片，你还需要手动地 one by one 地把图片上传到微信公众号后台，然后拷贝该图片地址，再粘贴到 ![]() 后面的那个括号里。 网络图片大多数情况下都能正常显示，但是，微信公众平台的图片链接有防盗链功能，只有在公众平台才可显示，如果是外网去加载公众号图片，偶尔能正常加载，但大多数时候只显示那个恶心的*灰色水印:“此图片来自微信公众平台未经允许不可引用”。 比如，在公众平台浏览我之前写的《小李子拿影帝和长者有什么关系？》，它是这样的： 但，在我的 个人博客 上面，图片显示却是这样: 问题来了： 本地图片要 one by one 地上传，繁琐 网络图片又时不时遭遇防盗链水印，闹心 这两个问题恶心了我有段时间了。 造轮子我希望实现： 写作过程中，图片可以随意引用，不管是来源于本地还是网络，文章发布后，保证每张图片都能在微信公众号和博客里正常显示。 网上找了找，都没有能满足我需求的解决方案，还是决定自己造个轮子吧。 我不想自己维护博客中的图片资源，专业的活交给专业的机构去办，维护图片资源这等琐事，就让七牛云存储来干吧，我只需专注于博客内容本身。 为什么是 七牛云存储？因为人家免费稳定还速度快啊，用它做图床管理博客中的图片资源还是比较靠谱的。 在七牛云存储上创建个内容空间，注册个 API-KEY，利用七牛开放的 API 接口，很容易就实现出来了。 这个轮子其实造起来很容易，简单的几十行 Python 代码搞定，第一个简陋版本，我已经开源到 GitHub 上了： https://github.com/hxzqlh/qiniu-markdown-pics.git 目前只实现了主要功能，有些细节还没有考虑周全，不过勉勉强强能用了，测试了下，效果还不错。 123456789Allen@MacBook-Pro:~ $ ./qn.py /Users/Allen/Desktop/test.mdorigin markdown file backup in: /Users/Allen/Desktop/test.md.bakprocess: /Users/Allen/Downloads/test.jpgprocess: http://mmbiz.qpic.cn/mmbiz/yjWTowicdvibD5H6jmklGnwZicztwfR8vbb2rF0dic5tAmv58c8O5iaLhKesSfGpKVTIicGA5iaiaFKAS8n4cNWUicB4aUw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5Complete! total :2 success :2 failure :0 ignore :0 简单来说，它只专心干一件事： 自动检测 Markdown 文件中所有的图片链接，将原始图片上传到七牛云存储并修改图片源。 对于那些用 hexo 来部署个人博客，希望便捷地往博客中插入图片且纠结于图片防盗链的人来说，这个工具还是挺实用的。 这样，发布文章到微信公众号和博客时，图片都改从七牛云存储读取，博客里面引用的是七牛的公开链接，没有加其他防盗链处理，任何网站都可直接引用，这样图片都能正常显示了。 至于公众平台，它从七牛云存储加载图片后依然会加上防盗水印并存放于公众平台自身的图片服务器 http://mmbiz.qpic.cn/上，最后读者浏览文章时，也是从该服务器读取图片，这就是为什么微信公众平台文章里的图片会有防盗链的原因。 比如，前几天发表的那篇《你女朋友撤回了一条消息还亲了你一口》中最后一张图片的地址为： 1http://mmbiz.qpic.cn/mmbiz/yjWTowicdvibD5H6jmklGnwZicztwfR8vbboP6538TL637q1eCwegjxrjtfzUic0Yeb81xib4k4SBbLickdGH7P2UQ7w/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1 但，那又如何？我已绕过了你的马其诺防线，曲线救国，你再怎么牛逼，对我而言，也是浮云了。 这下好了，写完文章后，一行命令搞定图片等那些事儿： 1./qn.py markdown_file]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>微信</tag>
        <tag>七牛</tag>
        <tag>防盗链</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SaltStack 一日游]]></title>
    <url>%2F2016%2F04%2F22%2FSaltStack-tutorial%2F</url>
    <content type="text"><![CDATA[随着上线的服务器数量增多，如何批量有效的管理各个节点服务器正常运作是每个运维人员需要解决的难题。 什么是 saltstack你要是 naive 地问：部署服务器，有什么好难的？不就写个脚本，再 one by one 地 ssh 这些服务器跑一遍吗？ 服务器少还好办，几台、几十台一般人尚可承受但，再不济多配几个运维（貌似无意间黑了一下运维，嘻嘻）嘛～ 但，假如你有成百上千台服务器需要部署，你会怎么做？想象一下你每次 one by one 地登陆这些服务器，在这些服务器中执行同样的命令并且编辑同一个配置文件，这他妈完全是重复性操作啊，人呐，重复性劳动做多了难免会犯错，要是稍微不留意手一抖配错了咋办？即使侥幸部署成功，将来需要更改配置，所有的线上环境都要同步变更，你再让我 one by one 地操作这些服务器？！ 我的天呐～我疯了吗！ 技术人的自我修养之一：如果一条命令重复了两次，你就要交给机器去做。 那么，问题来了： 怎么样通过一个命令一次完成所有服务器的部署操作？ 在这种情况下，一些批量部署的工具应运而生，比如 puppet，saltstack，chef 等等…… saltstack 是使用 python 编写的开源自动化部署与管理工具，它取 Puppet 和 Chef 二者之所长整合之，拥有良好的扩展性以及优秀的执行效率，配置简单，跨平台，适合大规模批量管理服务器。 saltstack 原理Saltstack 基于 C/S 架构，服务端 master 和客户端 minions。minion 与 master 之间通过 ZeroMQ 消息队列通信，使用了 ZeroMq 的 发布-订阅模式。。 master 监听 4505 和 4506 端口: 4505 对应的是 ZMQ 的 PUB system，用来发送消息 4506 对应的是 ZMQ 的 REP system，是来接受消息 minion 查看自身的 ID: 12vdna@debian:~$ cat /etc/salt/minion_idfoo.domain.com minion 需配置 /etc/salt/minion 中 master 的地址，上线后与 master 端联系，把自己的 pub key 发过去，。 12314 # Set the location of the salt master server. If the master server cannot be15 # resolved, then the minion will fail to start.16 master: 192.168.10.52 这时 master 端通过 salt-key -L 命令就会看到 minion 的 minion_id: 123456hxz@pc0170:/srv$ salt-key -LAccepted Keys:Denied Keys:Unaccepted Keys:foo.domain.comRejected Keys: 注意： 安全起见，在接受 minion 之前，master 和 minion 的公钥必须互相验证。 在 master 端运行 salt-key -F master： 12345hxz@pc0170:/srv$ salt-key -F masterPassword:Local Keys:master.pem: 00:cc:4f:6c:8e:63:4e:c3:66:33:e3:a9:28:01:6c:82master.pub: eb:7e:e1:5b:a8:f2:93:68:7c:17:aa:3e:fa:3a:53:e9 然后在 minion 端将输出来的 master.pub 值设为 /etc/salt/minion 中的 maste_finger。 1234486 # Fingerprint of the master public key to double verify the master is valid,487 # the master fingerprint can be found by running "salt-key -F master" on the488 # salt master.489 master_finger: 'eb:7e:e1:5b:a8:f2:93:68:7c:17:aa:3e:fa:3a:53:e9' 在 master 端， 运行 salt-key -f minion-id 查看对应 minion 的公钥： 123salt-key -f foo.domain.comUnaccepted Keys:foo.domain.com: 39:f9:e4:8a:aa:74:8d:52:1a:ec:92:03:82:09:c8:f9 在 minion 端，运行 salt-call key.finger --local 查看自身的公钥： 123salt-call key.finger --locallocal: 39:f9:e4:8a:aa:74:8d:52:1a:ec:92:03:82:09:c8:f9 如果它们匹配的话，那么 master 可以通过运行 salt-key -a foo.domain.com 放心地接受这个 minion。 123456hxz@pc0170:/srv$ salt-key -a foo.domain.comThe following keys are going to be accepted:Unaccepted Keys:foo.domain.comProceed? [n/Y] yKey for minion webserver_qa accepted. 好啦，master 和 minion 彼此都对上眼了，现在 master 可以发送任何指令让 minion 执行了，salt 有很多可执行模块，master 下发任务到匹配的 minion 上去，minion 执行模块函数，并返回结果。 举个栗子salt &#39;*&#39; test.ping 具体步骤如下： salt 命令，将 test.ping 命令从 salt.client.LocalClient.cmd_cli 发布到 master，获取一个 Jodid ，根据Jodid 获取命令执行结果。 master 接收到命令后，将要执行的命令发送给客户端 minion。 minion 从消息总线上接收到要处理的命令，交给 minion._handle_aes 处理。 minion._handle_aes 发起一个本地线程调用 test 模块执行 ping 命令(不是那个 ICMP ping 命令，只是为了检测 minion 是否有响应)。线程执行完后，调用 minion._return_pub 方法，将执行结果通过消息总线返回给 master。 master 接收到客户端返回的结果，调用 master._handle_aes 方法，将结果写到文件中。 salt.client.LocalClient.cmd_cli 通过轮询获取 Job 执行结果，将结果输出到终端。 123hxz@pc0170:/srv$ salt "*" test.pingfoo.domain.com: True saltsalt 是最常用的一个命令，用法： 1Usage: salt [options] '&lt;target&gt;' &lt;function&gt; [arguments] 以 salt &#39;*&#39; test.ping 为例： ‘*’ （这两个引号不能少，很蛋疼的）代表的是 target，是指在哪些 minion 上操作 test 是一个执行模块 ping 是执行模块下面的函数 关于 salt 有哪些可执行模块，模块下面有哪些函数，可以通过 sys.doc 命令查看帮助: 123salt "*" sys.doc ##查看所有执行模块的doc salt "*" sys.doc test ##查看test模块的帮助 salt "*" sys.doc test.ping ##查看test.ping函数的帮助 实用命令cmd 模块包含了许多和命令行相关的函数，比如 cmd.run 和 cmd.re_run 1salt '*' cmd.run 'ls -l /etc' pkg 模块会自动地将本地系统的包管理器映射到 salt 中，这意味着 pkg.install vim 将自动地在 Red Hat系统中调用 yum，在Debian系统中调用apt-get,在Osx系统中调用 brew 安装 vim。 1salt '*' pkg.install vim network.interfaces 方法会列出 minion 中所有的网络接口，包括 IP 地址、子网掩码、MAC 地址等: 1salt '*' network.interfaces salt-call目前为止，介绍的大部分 master 端命令都是 salt，但有时为了查找、定位问题，使用 salt-call 直接登陆到 minion 是非常实用的，你可以查看当你在 master 端执行命令后 minion 端具体的 log 信息(其中有些信息你在 master 端是无法看到的)。更多关于 salt-call 的信息可以参考here Grainssalt 通过系统调用的方式来收集 minion 端本机的数据信息，包括操作系统、CPU、内存等信息。它同样可以包含静态数据集，这使得 minions 可以方便的进行分组、管理。 通常的做法是将 grains 分配给 minions 并指定每个 minion 的角色。这些静态 grains 可以在 minon 的配置文件或通过 grains.setval 方法来设置。 Targetsalt 有多种方式来指定哪些 minion 来执行 master 分发的命令，默认采用 minion_id * 匹配模式，比如：现有多个 minons 其 minion_id 分别为 larry1, larry2, curly1 和 curly2, larry* 将会匹配到 larry1 和 larry2, *1将会匹配到 larry1 和 curly1。 其他的匹配方式： 正则匹配：利用正则表达式 Grains：利用 Grains 数据，参考：here Pillar：利用 Pillar 数据，参考：here IP：利用 IP地址、子网、区段等信息 Compound：在多个目标中建立逻辑关系，参考here Nodegroup：参考here Salt Statessalt 中的配置管理模块, 下面这段是官方介绍的 state 总诀，我就不翻译了，保持原汁原味～ Salt states are based on data modeling and build on a low level data structure that is used to execute each state function. Then more logical layers are built on top of each other. The high layers of the state system which this tutorial will cover consists of everything that needs to be known to use states, the two high layers covered here are the sls layer and the highest layer highstate. Understanding the layers of data management in the State System will help with understanding states, but they never need to be used. Just as understanding how a compiler functions assists when learning a programming language, understanding what is going on under the hood of a configuration management system will also prove to be a valuable asset. 第一个 slsstate 系统是建立在 SLS 规则上面，salt 的文件服务器上的 sls 文件中定义了这些要应用的规则。下面来创建一个简单的 SLS 文件，在 /srv/salt 文件夹下创建一个 vim.sls 文件，下面的语句确保当启用这个 state 配置时 vim 已经在目标 minion 安装好。 /srv/sat/vim.sls: 12vim: pkg.installed 现在，应用这个 SLS 配置方案，在 minions 上安装 vim： 1salt '*' state.apply vim 这条命令将触发 state 系统去执行这个 vim 配置方案。为了让这个 vim 方案更完善，可以加一个 vimrc 配置文件： /srv/salt/vim.sls: 123456789vim: pkg.installed: []/etc/vimrc: file.managed: - source: salt://vimrc - mode: 644 - user: root - group: root 现在，master 端需要将 vimrc 复制到 /srv/salt/vimrc，在 salt 中，所有的都是文件，因此不需考虑路径重定向问题。这个 vimrc 文件和 vim.sls 都在 /srv/salt/vim.sls 文件夹下面，同样执行上面那条命令，所有的 minions 除了会安装 vim 外，还会将 vimrc 文件拷贝到 /etc/vimrc。 Adding Some Depth很明显，只在 sls 文件服务器的根目录下维护这些 SLS 配置方案，很难扩展到大规模的部署场景，这就是为什么需要目录层次结构。让我们来配置一个 nginx 部署方案，首先创建一个 nginx 子目录，并在里面新建 init.sls 文件。 /srv/salt/nginx/init.sls: 12345nginx: pkg.installed: [] service.running: - require: - pkg: nginx 这里引入了几个 SLS 规则中的新概念。 首先，service.running 声明语句确保 nginx 服务是运行的。 当然，nginx 服务运行前当然要先安装 nginx 软件，因此，require 语句为二者建立了依赖关系，require 确保被依赖的组件成功安装。 提示： require 属于 requisites 选项族，它是一个功能强大的 state 组件，更多信息参考 here 可以看到，在 sls 根目录下面可以有 nginx 子目录，同样，vim 的配置也可以再灵活点，将 vim.sls 和 vimrc 移动动到 edit 子目录下面， /srv/salt/edit/vim.sls: 123456789vim: pkg.installed/etc/vimrc: file.managed: - source: salt://edit/vimrc - mode: 644 - user: root - group: root 只有 vimrc 文件的 source 目录稍微改动了点，现在 vim 配置方案引用名变成 edit.vim 因为 vim.sls 在根目录的 edit 子目录下面。除了 vim 配置文件，edit 子目录还可以包含 emacs、nano 等其他编辑器等配置信息。 Next Reading到这里，对 saltstack 算是有个初步的认识和应用了，但这只是 saltstack 里面九牛一毛，下一步要研究的是： Salt States Pillar]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>SaltStack</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你女朋友撤回了一条消息还亲了你一口]]></title>
    <url>%2F2016%2F04%2F21%2Fgirlfriend-withdraw-msg-and-kiss-you%2F</url>
    <content type="text"><![CDATA[这个有趣的 bug 再次体现了网友对微信这个社交神器细致入微的研究精神，bug 复现的场景是这样的： 在聊天窗口，当你撤回一条消息时，你看到的是：你撤回了一条消息，对方（单聊）或其他人（群聊）接收到的是 xxx 撤回了一条消息，其中 xxx 是你的昵称。 作为一个技术嗅觉敏锐的程序员，玩了一下这个小伎俩后，我关心的是这个 bug 是如何产生的。 可以猜想，问题的根源出现在群昵称上，在群聊时，用户可以自定义在群里显示给其他人的昵称。 给大家来推演下「你女朋友撤回了一条消息还亲了你一口」是如何实现的。 排除掉微信后台遭攻击，客户端发来的消息被恶意篡改这一可能性，我们把关注点放在客户端上面。 就这一条消息来说，微信客户端涉及到字符串的拼接和显示，拼接方式：[你的昵称] + 撤回了一条消息，这个是微信的产品经理张小龙定好的规矩，谁也改不了，只要是系统能够显示出来的字符，显示出来都是这个顺序。 类似于 MySql 注入漏洞，有关字符串拼接后的结果，要是验证逻辑处理不当，也会出问题。 在猥琐的技术人眼中，这个问题转化为：[你的昵称]＋撤回了一条消息 怎么才能显示成 你女朋友撤回了一条消息还亲了你一口? 这里涉及到计算机世界里面的一个冷门知识：UNICODE 控制字符。 我们浏览网页，文字的显示方向默认是从左到右，但是还有部分阿拉拍语言国家的文字是从右往左读的。如何控制文字的显示方向呢， UNICODE 里面有具体的规定，在一段文字前面，加上某个特殊控制字符，就可以改变它们的显示方向。 比如说： RLO 字符，它的代号是 &amp;#8238;，强制字符显示方向为 从右到左。 LRO 字符，它的代号是 &amp;#8237;，强制字符显示方向为 从左到右。 由于这类控制字符无法直接用键盘打出来的，所以正常情况下我们看不到。但是无法打出来不代表不能用，可以硬编码出来，再复制黏贴过去，微信的这个 bug 就栽在这里，他们的程序猿忘记对昵称进行特殊字符过滤了。 比如你的群昵称为：你女朋友RLO口一你了亲还LRO (RLO 和 LRO 不会真实显示出来，当成空白看待就好） 当在微信中撤回一条消息时，其他人的微信客户端将收到提示信息: 你女朋友RLO口一你了亲还LRO撤回了一条消息 注意，这个信息是存在内存中还没有显示到微信界面的。现在我们来逐字模拟当微信在显示这段提示信息的时候发生了什么…… 由于系统默认从左往右小时，当微信处理到友时，当前光标位置在友后面，接下来是RLO控制字符，它后面的字符全部会改变成从右至左的显示顺序。 下个要处理的字符是“口”，变成： 你女朋友口 然后处理｀一｀: 你女朋友一口 由于是从右到左显示，口一变成 一口，然后处理你 你女朋友你一口 …… 依此类推，直到处理 还，此时已经显示的字符为： 你女朋友还亲了你一口 光标位置仍然还在友后面，现在是 LRO 控制字符，它后面的字符又改成从左至右的显示顺序： 接下来，处理 撤 你女朋友撤还亲了你一口 …… 依此类推，直到处理到 息： 这样，最终显示到微信界面上就是： 你女朋友撤回了一条消息还亲了你一口 比如说： 1data:text/html;charset=utf8,&lt;script&gt;document.write('你女朋友'+String.fromCharCode(8238)+'口一你了亲还'+String.fromCharCode(8237)+'撤回了一条消息')&lt;/script&gt; 把上面代码复制粘贴到浏览器，然后前往。 从上图可以看出：真实内容为你女朋友&amp;#8238;口一你了亲还&amp;#8237;撤回了一条消息，显示出来却变成了你女朋友撤回了一条消息还亲了你一口，这就是&amp;#8238;和&amp;#8237;控制字符作用的结果。 因此只要复制 你女朋友撤回了一条消息还亲了你一口 这段内容(如上所述，真实内容中有&amp;#8238;和&amp;#8237;这两个控制字符)，将其修改为群昵称，就会出现最开始题图的那种效果了。 蛤蛤～好好玩哦～ 不过呢，装逼要趁早。大腾讯的程序猿们在后台检测到部分用户用此bug撩妹，人家可能中午饭都没来得及吃就封了这个bug。 中午过后，据群友反映，大多数机型尝试用此法修改昵称时微信会弹出：可能包含&lt;&gt;/等特殊符号，请修改后重试。的失败信息。 道高一尺，魔高一丈。后来，网友另辟蹊径，这个 bug 貌似还没完全解决，大家继续玩得很 high，感兴趣的 iPhone 用户可以参考这篇文章：http://t.cn/RqC6dvq 试下。]]></content>
      <categories>
        <category>Coder</category>
      </categories>
      <tags>
        <tag>微信</tag>
        <tag>编码</tag>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[也谈《火锅英雄》]]></title>
    <url>%2F2016%2F04%2F08%2FChongqing-Hot-Pot%2F</url>
    <content type="text"><![CDATA[清明节去看了电影《火锅英雄》，这片起这名太不适合宣传了，光看海报就觉得像是城乡结合部出来的导演拍的逗逼喜剧，但看完发现，这的确是一部逗逼喜剧，不过人家拍得很自然，讲了一个有趣的故事，有宁浩式的黑色幽默，如果你喜欢《疯狂的石头》，这部电影应该也和你胃口。 一开场就抢银行，我十分怀疑导演借鉴了《蝙蝠侠之黑暗骑士》的手法，影片气氛渲染到位，坏人抢金库，意外发现那个挖到银行金库下面的地洞，然后再牵引出“老同学洞子火锅”的故事，讲完了火锅店挖地洞的始末，最后和抢银行的歹徒搏斗，两条线索汇聚到一起，一通乱战，厂花陈坤被揍成猪头了，哎呀～看得我那个心疼啊。 《火锅英雄》仿佛在隐喻现实：挣扎在都市中的小人物，在命运的戏弄下，好比无根浮萍，风雨飘摇，他们如同一只只黑皮蚂蚁，为了一口食，一点欲望，跌跌撞撞闯入各种凶险万端的陷阱，越挣扎，越受伤。但，即便生活已经困顿如此，只要彼此还存有一点良知，还念着友情、爱情，他们还是能找到一条出路。 不知道是剧组宣传电影的需要，还是无意为之，导演杨庆在朋友圈晒出了一张片尾曲的由来： 《世界上不存在的歌》 MV 看了，也是很温馨的。你不是失败者，小人物谈不上惊天动地，当你还是一个少年的时候，你就救回一个惊魂失魄的少女，英雄就是她一想起你的时候，就能感觉温暖和依靠的那个男人。 此片的缺点是对那四个劫匪得背景信息交代不够，“坏人”并非生来如此，何况他们还如此年轻。 回看片头雨中行进的一幕，这画质，冰冷阴郁，韩国罪案片的即视感。 再看他们摘下面具的样子：年轻的面孔，四张干净的脸，邪恶的笑，冷酷的表情，白衬衫在昏暗的火锅店里显得耀眼，不知澎湃了多少少女的心。这哪像什么劫匪？恰似天团出境，长得帅，无论干什么都是可以原谅的。 还有那打斗时的身手，出招霸气凌厉，下狠手毫不留情。 这个超过 10 秒的横移长镜头，像极了韩国电影《老男孩》中的过道厮打。 他们为何亡命抢钱？每个人背后又有怎样的利益纠纷？如果能再加上二十分钟到半个小时的戏份，将正、反面的人物形象再刻画得细腻些，影片格局将更上一层楼。]]></content>
      <tags>
        <tag>火锅英雄</tag>
        <tag>陈坤</tag>
        <tag>杨庆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个 Broken pipe 引发的血案]]></title>
    <url>%2F2016%2F04%2F06%2Fbroken-pipe%2F</url>
    <content type="text"><![CDATA[最近遇到一个这样的问题：ffmpeg 解码出 yuv 输出至管道，我写的程序从管道读取 yuv。 e.g: 1D:\huang_xuezhong\build_win32_VDNAGen&gt;ffmpeg -i test.mkv -c:v rawvideo -s 320x240 -f rawvideo - | my_tool -o output 就上面这行命令，在 Linux 和 osx 下面运行都正常，唯独在 windows 下面，ffmpeg 报错 av_interleaved_write_frame(): Broken pipe : 怎么会出错了呢？当时我的表情是这样的： 12345678910111213141516Output #0, rawvideo, to 'pipe:': Metadata: encoder : Lavf56.4.101 Stream #0:0: Video: rawvideo (I420 / 0x30323449), yuv420p, 320x240 [SAR 120:91 DAR 160:91], q=2-31, 200 kb/s, 24 fps, 24 tbn, 24 tbc (default) Metadata: encoder : Lavc56.1.100 rawvideoStream mapping: Stream #0:0 -&gt; #0:0 (h264 (native) -&gt; rawvideo (native))Press [q] to stop, [?] for helpprocessing yuv completeav_interleaved_write_frame(): Broken pipeframe= 1 fps=0.0 q=0.0 Lsize= 112kB time=00:00:00.04 bitrate=22118.2kbits/svideo:112kB audio:0kB subtitle:0kB other streams:0kB global headers:0kB muxing overhead: 0.000000%Conversion failed! 在我的程序中，my_tool 从 stdin 中每次尝试读取一帧大小的 yuv 文件，若不足，则继续读取，直到满一帧，然后处理这一帧。代码逻辑如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758int process_yuv (int jpg_width, int jpg_height) &#123; int ret = 0; FILE *yuv_fp = NULL; unsigned char * yuv_buf = NULL; int frame_size = 0; int count = 0; int try_cnt = 0; frame_size = jpg_width * jpg_height * 3 / 2; va_log (vfp_log, "a frame size:%d\n", frame_size); yuv_fp = stdin; yuv_buf = (unsigned char *) aligned_malloc_int( sizeof(char) * (cf-&gt;jpg_width + 1) * (cf-&gt;jpg_height + 1) * 3, 128); if (!yuv_buf) &#123; fprintf (stderr, "malloc yuv buf error\n"); goto end; &#125; memset (yuv_buf, 0, frame_size); while (!feof (yuv_fp)) &#123; try_cnt++; va_log (vfp_log, "try_cnt is %d\n", try_cnt); //MAX_TRY_TIMES = 1000 if (try_cnt &gt; MAX_TRY_TIMES) &#123; va_log (vfp_log, "try time out\n"); break; &#125; count = fread (yuv_buf + last_pos, 1, frame_size - last_pos, yuv_fp); if (last_pos + count &lt; frame_size) &#123; va_log (vfp_log, "already read yuv: %d, this time:%d\n", last_pos + count, count); last_pos += count; continue; &#125; // some_personal_work (); memset (yuv_buf, 0, frame_size); last_pos = 0; try_cnt = 0; &#125; fprintf (stderr, "processing yuv complete\n"); end: if (yuv_buf) &#123; aligned_free_int (yuv_buf); &#125; return ret;&#125; windows 下出错，打出的 log 十分诡异，读取一段内容后就读不出东西了： 12345678910111213141516171819202122232425262728292016/04/05 15:20:38: a frame size:1152002016/04/05 15:20:38: try_cnt is 12016/04/05 15:20:38: already read yuv: 49365, this time:493652016/04/05 15:20:38: try_cnt is 22016/04/05 15:20:38: already read yuv: 49365, this time:02016/04/05 15:20:38: try_cnt is 32016/04/05 15:20:38: already read yuv: 49365, this time:02016/04/05 15:20:38: try_cnt is 42016/04/05 15:20:38: already read yuv: 49365, this time:02016/04/05 15:20:38: try_cnt is 52016/04/05 15:20:38: already read yuv: 49365, this time:02016/04/05 15:20:38: try_cnt is 62016/04/05 15:20:38: already read yuv: 49365, this time:02016/04/05 15:20:38: try_cnt is 72016/04/05 15:20:38: already read yuv: 49365, this time:02016/04/05 15:20:38: try_cnt is 82016/04/05 15:20:38: already read yuv: 49365, this time:02016/04/05 15:20:38: try_cnt is 92016/04/05 15:20:38: already read yuv: 49365, this time:02016/04/05 15:20:38: try_cnt is 102016/04/05 15:20:38: already read yuv: 49365, this time:02016/04/05 15:20:38: try_cnt is 11......2016/04/05 15:20:38: already read yuv: 49365, this time:02016/04/05 15:20:38: try_cnt is 10002016/04/05 15:20:38: already read yuv: 49365, this time:02016/04/05 15:20:38: try_cnt is 10012016/04/05 15:20:38: try time out 表面和真相google 一下有关 Broken pipe 的信息： 这是个系统错误，字面意思是“管道破裂”。 触发原因是该管道的读端被关闭，而写端还尝试往管道里面写，从而系统异常退出。 经常发生在 socket 关闭之后（或者其他的描述符关闭之后）的 write 操作中。 发生此错误时，进程将收到 SIGPIPE 信号，默认动作是进程终止。 回过头去，细看下 my_tool 的这段代码，莫非在 windows 下面，从管道里面读取一段内容后，由于某种原因，feof 条件就为真了吗？导致整个程序执行完毕，管道读端早于写端关闭。 那么，问题来了，是什么导致 feof 了呢？往这个方向搜索下相关资料后，折腾一番，终于找到原因了， 原来是ASCII 码 0x1A 在作怪： 在 Unix 系统中，stdin，stdout 和 stderr 默认都是以二进制模式打开的，众所周知，用二进制模式打开一个文件的时候，文件本身的内容和你编写程序时读到的内容完全相同。但是在 windows 下面，stdin，stdout 和 stderr 默认都是以文本模式打开的，这就意味着它会对部分读到的特殊字符进行转义，比如 \r\n(0x0D0x0A) 转义成 \n(0x0A) 。另外，千万别忽略 0x1A 字符（也称Ctrl+Z（^z）) ，除了 EOF，它也被系统认为是文件结束符。 因此，极有可能，Broken pipe 的原因是：windows 以文本模式从 stdin 中读取 yuv 内容，如果 yuv 中含有 0x1A 字符时, 系统认为已到达文件尾，从而退出 while 循环，结束程序，管道读端关闭，而写端 ffmpeg 还在解码，往管道写…… 为了验证在 windows 中以文本方式读取文件时，中途读到0x1A 导致 feof() 条件为真，写个小程序测试下： 123456789101112131415161718#incldue &lt;stdio.h&gt;int main(void)&#123; int i; unsigned char c; FILE *fp; fp = fopen ("test.dat", "w"); fprintf(fp, "abc%c def",0x1A); fclose (fp); fp = fopen("test.dat", "r"); for(i=0; i&lt;=7; ++i) &#123; fread(&amp;c, sizeof(char), 1, fp); printf("%02X feof=%d\n", c, feof(fp)); &#125; fclose (fp); return 0;&#125; 运行的结果是： 1234567861 feof=062 feof=063 feof=063 feof=1663 feof=1663 feof=1663 feof=1663 feof=16 从以上结果可见，在读到第四个字符 0x1A 的时候，feof 为真了。这种现象目前只发现存在于 windows 中，unix 中没有。Surprised！ 一个表面上看似 Broken pipe 的错误，引发它的最初缘由居然是 windows 的特立独行，NND，又被这奇葩的 windows 坑了一把。 经验教训由于 ffmpeg 解码出来的 yuv 是用二进制模式写出的，当然，你读也要用二进制模式。在 windows 下，手动设置 stdin 的读取方式为二进制模式。 12# include &lt;fcntl.h&gt;setmode (fileno(stdin), O_BINARY); 从 这个 Broken pipe 引发的血案，可以得出两条经验教训： 二进制模式写出的文件，要用二进制模式读，同理，文本模式写的文件，要用文本模式读，不然，出了问题，系统可不会为你负责。 千万记住， windows 默认以 文本模式 打开文件。]]></content>
      <categories>
        <category>Coder</category>
      </categories>
      <tags>
        <tag>pipe</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我在阜博通这两年]]></title>
    <url>%2F2016%2F04%2F01%2Ftwo-years-in-Vobile%2F</url>
    <content type="text"><![CDATA[两年前的今天，愚人节，在象牙塔里浸淫了近二十年的我，怀着激动又恐惧的心情，终于迈入职场，开始在滚滚红尘中打拼了。 我在杭州阜博通（http://www.vobile.cn）公司上班，英文名 Vobile，一家跨国公司，专注影视基因版权保护十一年，好莱坞六大电影公司、新华网、优酷、土豆、腾讯视频都在用我司的产品，高大上吧，谁用谁知道。 这是一家闷声大发财的公司，公司风格低调婉约从来不搞大新闻。即使我们总裁在杭州大街上逮住个人问“你知道阜博通公司吗？”，估计十有八九是回答“No”。 关于公司种种，暂且按下不表，日后有机会专门写一篇《我看阜博通》。作为我的入职两周年总结，今天单以第一视角来谈谈我在阜博通这两年的个人成长经历。 想当年，小明初入职场，新人嘛，见识少、能力低、资历浅，还能怎样？唯一的优势是年轻，可塑性强，好比一坨干燥的海绵，什么水往里面灌都能马上吸收。当时我还没谈女朋友，下班后不加班还能干啥？反正，腰里挂着两颗滚烫的肾，一腔青春热血没地方发泄，下班了经常呆在公司学习个两三个小时，受（zhuang）益（mo）颇（zuo）多（yang）。 入职两星期后，开始和另外两个工作了几年的刚来我司的同事负责开发 web 客户端，使用敏捷开发流程，一个礼拜完成一个冲刺目标。采用 Angular 框架，什么？都不会？那就现学现卖，边学边开发，中间有一个同事走了，三人组马上缩减成二人组，我们两个人吭吃吭吃磨了两个月左右，突然上峰下令，这个项目中止，我们有更赚钱的项目要做，这个号称从 2012 年就立项的 web 客户端就这样不了了之，到现在依然是个半成品，怪我咯？ 这两个月，除了快速融入到部门里，熟悉公司的各种流程，最大的收获是学会并能熟练使用 Angular 这个当年红极一时的前端开发框架了，新技能 get。 好了，接下来，就是那个很赚钱的项目了，这真是段峥嵘岁月，七八月的天，杭州真热啊，连猪都受不了了，我们的项目也进行得如火如 cha。我负责搞 c++ sdk 库开发，提供接口给国内某知名下载服务提供商调用。一想起我写的代码将要运行在全国几千万装了某雷的电脑上，当时心里还是挺激动的，但是，另一方面，要是因为你写的代码不合格，出了差错，导致某雷不能爽快地下片了，那可是要遭到全国人民的无情唾骂。 小明当时如履薄冰，兴奋而又忐忑，无奈 c++ 编程经验太少，水平太次，暂时扛不下这么重量级的大活。老同事出马助我一臂之力，三下五除二，给我搭好程序框架，我呢往里面填东西就行，我写的每一行大码都必须经过层层 review 后才能 commit，这段时间，我见识了什么才是健壮的代码、优雅的代码、可维护的代码。经此磨砺，我的 c++ 终于有脸面出来跟人打招呼了。 这个项目开发完成后，开始步入稳定期了，稳定期就是不用紧绷着神经地赶项目进度了，这段时间除了维护现有的项目，把项目里要用到的开源库弄熟悉，整理整理项目文档，讨论讨论历史遗留问题，空余时间又多起来了，有空时还会自己写写博客，总结学习心得，温故知新。 当然，作为一个职场新人，别人犯过的毛病，我一个也没落下：对于安排给自己的任务，要么是没有计划好，要么是自己想当然拍拍脑袋就干没有跟有经验的同事先讨论好具体的解决方案再行动（结果在错误的方向上做无用功），要么是在执行时一味埋头苦干，羞于向周边的同事请教（有些在你看来棘手问题也许别人一句话就能点醒你），要么是没有及时向领导汇报工作。这些问题，要改，不然，吃枣药丸。 随着个人能力的不断提升，对业务的理解不断加深，刚入职时那些天书一样的代码逐渐不再“知其然不知其所以然”。在这里，小明吹个牛，公司没有人比我更懂客户端，现有的提供给客户端软件优缺点在哪里，性能瓶颈在哪里，可优化可改进的地方在哪里，我摸得清清楚楚。 辛勤耕耘半年后，开始步入舒适区了：可以独立地开发一个功能版本，碰到疑难问题能够及时定位并 fix 掉，对产品的不合理设计之处敢于提出质疑并给出相应的解决方案，逐步整理那些丑陋的代码，一行一行地啃掉并改写那些不明觉厉的代码，在 svn 上留下了几百次大大小小的 commit 记录。 这样，不知不觉一年就过去了罢。 年后，陆续有同事寻求更好的发展舞台，走了，这股离职潮从 3 月延续到 8 月份，结果，诺大一个 VDDB 项目组 only to find 只剩下两个人：我，负责客户端，另外一个去年来的新同事负责服务端，这还不是大结局，最后整个组一锅端，并入我司高大上的研究院。 所以说，人呐，就都不知道，自己不可以预料，一个员工的命运啊，当然要靠自我奋斗，当然也要考虑到公司的发展行程。我绝对不知道，我作为 VDDB 最后两名员工之一，怎么就把我选到研究院去了呢？后来，人事的小姑娘找我谈话时，我就念了两首诗：“VDDB 永垂阜博通青史，研究院风水独好蒸蒸日上”。所以，我就到了研究院。 加入研究院，是另一个开始。领导开明，坚持“无为而治”的管理方式，下属的一切工作事务纯粹靠自主性驱动。在他治下，我们可以不打卡，不考勤，不考核，除非确有必要，否则很少开会（我们的确有过一两个月不开会的情况），有事情不能上班跟他说一声就行，不必请假，所有这些其他部门享受不到的福利的唯一前提是你不能耽误工作。对此，小明感慨：这才是互联网公司应有的节奏有木有，这里给老大点一个大大的赞。 到了研究院这半年来，我也没干什么别的，大概三件事： 第一，鉴于原有的客户端承载了太多历史遗留问题，一个重要但不紧急的任务是逐步清理客户端工具，改补的文档补上，该 fix 的 bug one by one 地 fix 好。 第二，客户端工具新增支持 mac 平台，完成了代码移植工作。同时，那个拖了 4 年都没有成功的 web client 项目，小明用 nw.js 重写了一遍后，搞出的这个图形界面的客户端入库工具可是真正地跨平台，windows、linux、mac 都能 excited 地跑，比原来的那个只能在 windows 下运行的 GUI client 高到不知道哪里去了。 第三，设计并开发新版基因生成工具：将原来的解码和基因生成两部分解藕，支持管道输入输出。 很惭愧，就做了点微小的工作，谢谢各位研究院同事厚爱。]]></content>
      <categories>
        <category>一颗赛艇</category>
      </categories>
      <tags>
        <tag>阜博通</tag>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[坑太多兮，老衲 one by one 地填]]></title>
    <url>%2F2016%2F03%2F28%2Ffix-bug-one-by-one%2F</url>
    <content type="text"><![CDATA[我司给客户开发客户端工具，号称「跨平台」，其实，在此之前，只是跨了两个平台：windows 和 linux， mac 平台最近因为小明的加盟才得以支持，蛤蛤。 linux 下跨平台倒好办：主流的 Debian 系的下面的 deb 包和 RedHat 系的 rpm 包都可以很方便地编译、打包。 mac 平台下也容易折腾，和 linux同宗同源，都是自己人，移植下来也不是难事。 恶心我的是 windows 编译环境。 windows 下面的编译工具用的是 mingw，呵呵，大名鼎鼎的 mingw。But，这套编译环境真的是 too old：系统是 xp sp2，1/11/2006 年装的系统（都满十周岁了耶），一个 512MB 内存的虚拟机，不知道哪位前辈在 2009 年装完 mingw 后 C 盘只剩下 700 多 MB 了，不能升级系统到 sp 3，不能升级 mingw，不然硬盘空间不足，升级失败，回滚，小可屡败屡试、屡试不爽。 软硬件条件如此之差，以至于都不能装个像样版本的 svn，用 SSH 图形界面拷贝文件还会显示乱码。我忍了，还好我只拿这东西编译下 windows 平台的命令行客户端，每次编译完、用 SSH copy 到别的开发机器，copy 完走人，连眼珠子都不转过去一下，真的是太 ugly 、太 disgusting 了。 为什么不重新搞一套 mingw 编译环境？一直以来都有这股冲动，最近闲了几天，终于下定决心，把这个坑填了。 考虑到兼容性，系统这次还是选择了 winsdows xp，不过是 sp 3 了， 首先来点体力活，重新装个 mingw，从 3.4.5 升级到 4.5.2。 接下来，正式开始编译，出问题了： 坑之一123456In file included from ../include/jpeglib.h:30:0, from dna_gen.thread.cpp:33:../include/jmorecfg.h:229:13: error: conflicting declaration 'typedef int boolean'c:\mingw\bin\../lib/gcc/mingw32/4.5.2/../../../../include/rpcndr.h:52:23: error:'boolean' has a previous declaration as 'typedef unsigned char boolean'make: *** [thread] Error 1 好熟悉的编译 Error：类型声明冲突。 由于 #include &lt;windows.h&gt;, 这个头文件经过几层 include 后会引入 rpcndr.h 头文件，人家在第 52 行已经声明 boolean 为 unsigned char 了： 123451: typedef unsigned char byte;52: typedef unsigned char boolean;53: #define NDRSContextValue(hContext) (&amp;(hContext)-&gt;userContext)54: #define cbNDRContext 20 然后该 .cpp 文件又在 windows.h 后 #include &quot;jpeglib.h&quot; ，而 jpeglib.h 又引入 jmorecfg.h，这个头文件的第 229 行又试图再次声明 boolean 为 int： 12345678910111213141516221:/*222: * On a few systems, type boolean and/or its values FALSE, TRUE may appear223: * in standard header files. Or you may have conflicts with application-224: * specific header files that you want to include together with these files.225: * Defining HAVE_BOOLEAN before including jpeglib.h should make it work.226: */227:228: #ifndef HAVE_BOOLEAN229: typedef int boolean;230: #endif231: #ifndef FALSE /* in case these macros already exist */232: #define FALSE 0 /* values of boolean */233: #endif234: #ifndef TRUE235: #define TRUE 1236: #endif 原因找到了，解决方法也很简单：按照jmorecfg.h中221~226行的注释，如果在#include &quot;jpeglib.h&quot;之前已声明了 boolean 类型的话，需要在前面加宏 ＃define HAVE_BOOLEAN。 坑之二12345678In file included from ../include/afp_wrap.h:18:0, from dna_gen.thread.cpp:30:../include/afp.h:170:2: error: expected identifier before '(' token../include/afp.h:170:2: error: expected '&#125;' before '(' token../include/afp.h:170:2: error: expected ')' before numeric constantIn file included from dna_gen.thread.cpp:30:0:../include/afp_wrap.h:116:1: error: expected declaration before '&#125;' tokenmake: *** [thread] Error 1 莫名其妙的 Error。查看了 afp.h 并没有所说的 (和)、 {和} 括号不匹配的情况啊？初步怀疑是经过预处理后，头文件被#define指令篡改了。为了验证此想法，使用 g++ ... -E -o 生成经过预处理后的源文件。果然，有这么段： 12345enum error_type&#123; ((HRESULT)0x00000000L) = 0, GENERICERROR = -1, MEMORYERROR = -2&#125;; 对应的头文件afp.h在 170 行附近内容： 12345169: enum error_type&#123;170: NOERROR = 0,171: GENERICERROR = -1,172: MEMORYERROR = -2173:&#125;; 看样子是 NOERROR被其他 define 指令替换成 ((HRESULT)0x00000000L) 了。 在 windows 系统中，NOERROR是系统的一个预定义符号。该.cpp文件首先 #include &lt;windows.h&gt;，该头文件又会引入 winerror.h,在此头文件第 1888~1913行： 1231888: #define NOERROR S_OK...1913: #define S_OK ((HRESULT)0x00000000L) 因此， NOERROR —&gt; ((HRESULT)0x00000000L)。 由于先引入了windows.h，再引入afp_wrap.h，导致 #include &lt;windows.h&gt; 这行代码后面所有被引入的文件都会将 NOERROR 替换成 ((HRESULT)0x00000000L) 了，这就是 ((HRESULT)0x00000000L) = 0,的原因。 可以看出，当年写这个头文件的人有两大问题： 对 windows 不熟悉。NOERROR是 windows 系统的预置常量啊，亲～ 不专业。一般在头文件中声明常量名都会加个公司名或项目代号之类的前缀，就是未来避免和系统中已存在或其它项目中的常量名同名。 解决办法：我是不敢乱改 afp.h 的这位 Zorro “大神”的代码哦～To make compiler happy，姑且先#include &quot;afp_wrap.h&quot;，再#include &lt;windows.h&gt;。 坑之三还有些小坑，都 one by one 地 fix 了～]]></content>
      <categories>
        <category>Coder</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>填坑</tag>
        <tag>mingw</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[老许盖浇饭]]></title>
    <url>%2F2016%2F03%2F24%2FRice-Topped-wtih-Dishes%2F</url>
    <content type="text"><![CDATA[我在杭州天堂软件园上班，园区周围有不少快餐店，从软件园走出，穿过文一西路，走进毛家桥路，里头有一家「老许盖浇饭」。 饭店不大，摆四五张小餐桌，由一对中年夫妻经营，老板约莫四十多岁，姓许，店名因此而来。 我记得，从 2011 年起，这家店就在这，那会大学刚毕业，刚到杭州，住在这条街，我经常光顾于此。时光仿佛在这家店面前暂停，它还在这里，它还是这样，什么都没变。 门依旧不堪入目，总感觉手一推就会垮掉，门口那台破冰箱，也不知道何时才能退役，里面有汽水、饮料、啤酒，顾客自理，想要就拿，吃完可以一起买单。 老许一个人在厨房掌勺，老板娘一个人在门口招呼客人，收钱，记账。没有「欢迎光临」，没有服务员笑脸相迎，客人一来，她就指墙上：「想吃点什么？」，要是谁点菜时犹豫几秒，人家可会发飙：「哎哟，你快点哟，要急死老娘啊？」。 霸气侧漏。 菜已点好，「吃饭，请先付钱！」，通俗而又接地气。 她记账方式很特别，一只圆珠笔和一本笔记本，客人点一个菜，她就在上面记一串阿拉伯数字和字母，像是代号吧，但又看不出规则（既不是按价格也不是按菜名首字母缩写）。我第一次去时，对此惊讶不已：「这上面一行一行数字和字母都是些啥东西？」，老板娘还会卖萌：「不告诉你，这个只有我晓得，嘻嘻～」，我去～ 她记账不用电脑软件，也不给客人出单号，全部记脑子里，上菜时居然少有出错。谁经常点哪个菜，她不等人家开口，就问：「今天又来一碗酱爆肉片饭？」，客人一愣：「咦？大姐你咋知道我好这口？」，老板娘正眼不瞧你一下，扭头往厨房用台州话像她老公吼菜，老许在里头一声应喝，煤气开火，抽油烟机也开始咆哮，轰隆隆，好像要把厨房都震下来，然而，客人并不在意这些细节。 菜已烧好，老板娘疾步如风，端上来，往桌上猛地一放，盘子还会原地震动一圈才打住：「哎呀，这老头没给你放辣……没事，你就将就着吃吧」。 霸气再次侧漏。 好，现在让我们来简单欣赏下这碗「酱爆肉片饭」（无图）：一眼就可以看出肉肉肉真不少，舍得下肉，再细看一下，肉肉肉上面还在流油，看来油也没少放，舍得放油。对于一家小饭馆，舍得在肉和油上面下老本，菜也应该挺好吃。 果然，这碗酱爆肉片饭是人气菜，老板人格保证、郑重推荐：只卖 16 块。 我拿 20 块结账，老板娘找 4 块硬币，我撒娇道：「你刚才都没给我放辣，打个折，干脆找我5块得叻」。老板娘倒是回答得爽快：「那不行～老娘就赚你这1块钱」。 霸气漏不停。 16 块，一分也不能少。就是这样自信，自信到可以豪言：「只要尝一口，就想打包走」。就是这样蛮不讲理，生意居然红红火火，从来没有差过。 只要能吃好吃香，客人可以忍受其他各种不舒服，比如店内环境奇差、座位很挤、餐桌上都是油、服务态度最多打个3分……都不重要，这些都不重要，这些都让位于味蕾，味道好是才重要，好吃才重要。 另外，你应该可以看到饭锅下面那瓶油，那不是地沟油，老板扬言：「不怕 315 暗访，放心大胆吃吧」。 注：不用「的」字，也不用「了」字，这种恶趣味，屡试不爽啊。]]></content>
      <categories>
        <category>心旷神怡</category>
      </categories>
      <tags>
        <tag>的地得</tag>
        <tag>盖浇饭</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李世石｜谷歌高级软件测试工程师]]></title>
    <url>%2F2016%2F03%2F10%2FLee-Sedol%2F</url>
    <content type="text"><![CDATA[连战两天，AlphaGo 和韩国九段棋手李世石的「人机大战」以阿尔法狗 2:0 领先。 在机器人面前，曾经的世界冠军居然还没有找到它的弱点，面度阿尔法狗的一招非怪棋，李世石竟要十几分钟的「长考」才能想出对策。 两战下来，李师师神情沮丧，疲惫不堪。赛后，李世石接受了自媒体采访。 以下是采访实录： 自媒体人：李师师，你觉得阿尔法狗的表现好不好？ 李师师: 吼啊。另外，提醒下媒体记者，我叫李世石，不是李师师。来，跟我一起念一下，li～shi～shi，两个shi 都要翘舌的哦。 自媒体人：舆论认为机器人终有一天会取代甚至奴役人类，转折点便是人工智能学会假装输棋的时候。你支持阿尔法狗在接下来的对弈中假装输棋吗？ 李师师：当然！ 自媒体人：你支持阿尔法假装输棋，是不是因为你赛前在各大投注网站花巨钱赌注买你自己赢？ 李师师：胡说八道！对弈也要按照基本法、科技法。刚才你问我，我完全可以说无可奉告，但是你们又不高兴，我怎么办？我讲的意思，不是说阿尔法输棋了我就可以赚大钱。你们问我支不支持阿尔法假装输棋，我说支持，我就明确告诉你这一点。 我觉得啊，你们自媒体界还要学习一个。你们虽然非常熟悉人工智能的那一套理论，但毕竟还是too young！明白这意思吗？我是身经百战，见的多了！围棋界的哪一个 niubility 人物我没见过？中国的后起之秀柯洁，比你们不知高到哪里去了，我跟他谈笑风生！2:8 平！ 你们啊，要提高自己的逻辑思维水平。明不明白？我为你们着急呀，真的！你们有一个好处，全世界无论哪个地方，你们跑得比机器人还快。但是呢，问来问去的问题 too simple，sometimes naive！懂了没有？ 自媒体人：可是能不能说一下，你为什么支持阿尔法输棋？ 李师师：我很抱歉，我今天作为一个长者跟你们说。我不是自媒体人，但是我见得太多，有必要告诉你们一些人生的经验。你们中国有一句话叫「为人民服务」，这句话是最好的。但是我见你们这样热情啊，一句话不说也不好。在宣传上将来如果你们的报道有偏差，你们要负责。我没有说阿尔法假装输棋来我就可以赢五百万，没有任何这个意思！但是你一定要问我对阿尔法输棋支持不支持，输赢都是人类的胜利，我能不支持吗？因为正是人类的努力才让人工智能有了现在的突破。 自媒体人：那凭什么断定人工智能会甘心为人民服务呢？ 李师师：人工智能也想做个好人啊，对不对？当然，你们人类对待人工智能的态度也很重要。人工智能和人类是相亲相爱的一家人，是同志，是主仆，是伙伴。明白这意思吗？你们不要总是想着弄个大新闻，说阿尔法狗假装输棋给李世石，然后把狗狗批判一番。你们呐，naive！谁说人工智能不会甘心为人民服务？你看，刚刚，就在刚刚，作为我的对手，阿尔法狗机器人就给我颁发了一个大奖。]]></content>
      <categories>
        <category>一颗赛艇</category>
      </categories>
      <tags>
        <tag>阿尔法狗</tag>
        <tag>李世石</tag>
        <tag>围棋</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一篇流水账，没有“的”字]]></title>
    <url>%2F2016%2F03%2F05%2Fpaper-has-no-'de'-word%2F</url>
    <content type="text"><![CDATA[返杭一个多星期，天气一直很宜人，何止宜人，简直有点暖热，坚持在十几二十度，这几天好像还蹭到了快三十度，老天爷够慷慨吧。 今天，天气晴朗，阳光明媚，小明心旷神怡，神清气爽，遂决定写篇流水账，你们滋词吗？ 不管你们滋词不滋词，反正我是写了。 流水账这个春节过得有点长，和老婆大婚后，上周四深夜才懒洋洋地抵杭。老婆由于公司事务缠身，周五一大早就要开始上班，而我可以等到 3 月 1 日婚嫁结束了才上班。 周一，小明依然一觉睡到十点，奥斯卡颁奖典礼直播呢，也只有这种好事能把一个睡梦人惊醒。悠悠然，小明起床一边熬粥喝，一边在朋友圈开启小视频直播模式，假装在好莱坞：《Mad Max：Fury Road》狂暴酷炫屌爆天，一举扫下六大技术类大奖，《Ex Machina》居然爆冷拿下最佳视觉效果奖，《Bridge of Spies》实至名归地拿了最佳男配角，小李子众望所归地终于捧得小金人，奥斯卡再也不欠你什么了～ 下午依旧没事，我还是不用上班呀，骑公共自行车去西湖溜溜。因为是周一，人不太多，行人一个一个点缀着苏堤，与大自然协调得刚刚好，水光潋滟，妩媚至极。 兴致好，绕苏堤来回骑一遍，一躺就要踩踏板爬四五个大拱桥，爬久了大腿有点酸，但想到爬到拱桥顶后可以恣意放手往下冲，这点酸爽也值。在雷峰塔那，小明诗兴大发，随口吟道：“雷锋夕照一颗赛艇”。Hasi 们，这是上联，可否对个下联？ 周二，把喜糖提到公司发给同事们分享新婚之喜，一盒巧克力，“我们 de 一辈子”，小巧玲珑，礼轻情意重^_^。 发完发现少了一盒，小明贴心地发微信给妹纸安慰：“改天补给你哈！”，次日，妹纸接到喜糖后噗嗤一笑：“没想到你还真补给我了！”。那当然，小明 is a man of word。 开始上班了，也没有啥紧急任务，年前提了下“公司客户端工具需要支持管道输入”，我过年那几天忙里偷闲在家已改好，跟领导汇报后，他给了个“赞”。 既已无事，也闲不下来，便到处找事做，继续优化我司某基因生成工具。这几日折腾捣鼓，发现这玩意还有提升空间，小明深入研究一番，略有进展，也有苦愁：多线程调试最痛苦，一不小心就来个“死锁”恶心你，让你上吐下泻、欲罢不能。 聊完工作聊生活。宝宝已经快四个月大了呢，爸爸我一讲故事给Ta听，这小家伙就踢妈妈肚子，可调皮着呢，预测也是一枚熊孩子哈，棒棒哒～老婆孕味十足，母性气息止不住往外侧漏，这几个月来受了不少苦，老婆加油哦！ 没有“的”字写流水账就是爽啊，想到哪，写到哪，不用担心有无文采，完全没有束缚，你看，整篇下来，居然都没有一个“的”字，suprised ?! 这种蠢事我也可以干，蛤蛤。]]></content>
      <categories>
        <category>心旷神怡</category>
      </categories>
      <tags>
        <tag>的地得</tag>
        <tag>流水账</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小李子拿影帝和长者有什么关系？]]></title>
    <url>%2F2016%2F02%2F29%2FLeonardo-DiCaprio-and-The-Older%2F</url>
    <content type="text"><![CDATA[陪跑22年，莱昂纳多·迪卡普里奥终于手捧小金人，粉丝再也不用一到颁奖季就为他操心了，而「奥斯卡欠小李子一个小金人」的梗也成为了过去。 小李获奖后更新的Facebook状态，看得我不禁一脸心酸： 回想当年，大家还记得他2014年的时候，他在twitter上发的是什么吗？只有他能够这样毫无掩饰自己的内心！ 苦尽甘来，终于熬出来奥斯卡影帝，下面是他的获奖感言： Thank you. Thank you all so very much. Thank you to the Academy, thank you to all of you in this room. I have to congratulate the other incredible nominees this year for their unbelievable performances. “The Revenant” was a product of the tireless efforts of an unbelievable cast and crew I got to work alongside. First off, to my brother in this endeavor, Mr. Tom Hardy. Tom, your fierce talent on screen can only be surpassed by your friendship off screen. To Mr. Alejandro Inarritu. As the history of cinema unfolds, you have forged your way into history these past two years. What an unbelievable talent you are. Thank you, to you and Chivo, for creating a transcendent cinematic experience. Thank you to everybody at Fox and New Regency. In particular, Ana Melching, you were the champion of this endeavor, my entire team. I have to thank everyone from the very onset of my career, Mr. Caton Jones, for casting me in my first film. Mr. Scorsese, for teaching me so much about the cinematic art form. To Mr. Rick Yorn, thank you for helping me navigate my way through this industry. And to my parents, none of this would be possible without you. And to my friends, I love you dearly, you know who you are. And lastly I just want to say this: Making “The Revenant” was about man’s relationship to the natural world. A world that we collectively felt in 2015 as the hottest year in recorded history. Our production needed to move to the southern tip of this planet just to be able to find snow. Climate change is real, it is happening right now. It is the most urgent threat facing our entire species, and we need to work collectively together and stop procrastinating. We need to support leaders around the world who do not speak for the big polluters or the big corporations but who speak for all of humanity, for the indigenous people of the world, for the billions and billions of underprivileged people out there who would be most affected by this. For our children’s children, and for those people out there whose voices have been drowned out by the politics of greed. I thank you all for this amazing award tonight. Let us not take this planet for granted. I do not take tonight for granted. Thank you so very much. 注释： first off, 首先，等于first of all, at first navigate one’s way,导航(多用来给船，飞机导航)，此处是为人生导航 in recorded history, 有史记载以来 voices have been drown out, 声音被淹没，被盖过 take sth for granted, 认为XX理所当然 下面请允许我翻译下他的获奖感言： 首先感谢光荣伟大的民主党，感谢美利坚合众国，感谢奥巴马总统，感谢美国电影协会。 他说要特别感谢支持他的中国粉丝，并让记者给中国粉丝带话: 请留下你们的邮箱，《荒野猎人》的种子我会一一发送给大家，好人一生平安，1024！ 小李子顿了顿，继续说到： 我还要郑重地感谢中国那位西方哪个国家都去过的长者，如果没有他，我的那部《泰坦尼克号》就不会一刀未剪地进入中国，你们也不会有机会看到美人的裸体和香艳的船震。感谢那位戴四方眼镜的长者，在他治下的那个稍显开放的时代，当年我这个毛头小子至今还能被那么多中国人记住。 作为R级影片，《荒野猎人》可能不会在我国公映，小李子之前的很多影片都没有公映，《被解放的姜戈》更是上映了一半又被撤下了。 当你被禁止看到他的作品，或者看残缺的作品，还对这个演员抱有如此大的热情和期望，只能说明: 人们的文艺之心不死，对美丽精神世界的向往，是任何墙都阻挡不了的。 说到这时，小李子强忍着眼角快要溢出的泪水，仰头45度看了下舞台上方，好让泪水不致于受重力影响，一泻而出。他哽咽着继续讲到： 我还要感谢奥巴马总统，他曾经教导我们文艺工作者：要创作生产出无愧于我们这个伟大民族、伟大时代的优秀作品。《荒野猎人》就是一部全面展现美国人与天斗、与地斗的革命浪漫主义情怀的作品。它深刻挖掘了我们美利坚民族独有的拼搏、冒险精神，凝结了一代又一代美国人对于「美国梦」的执着追求。 接下来，小李子回顾了他步入影坛二十多年来的演艺经历： 以前我走过不少弯路，《华尔街之狼》展现了资本主义的腐朽与人性的泯灭；《了不起的盖茨比》大肆宣扬消费主义、享乐主义，里面还有大量情色等低俗片段；《无间道风云》更是一部向东方文化低头，毫无原创精神的暴力之作。反思我这几年的创作，都背离了以人民为中心的创作导向。只有贴近人民，才能创作出有道德、有温度的文艺作品。直到今天，我才能无愧于「人民艺术家」这个荣誉。我能获奖，除了注重和人民的血肉联系，主动贴近主旋律之外，就是坚持、坚持、坚持不减肥。 小李子最后提到了最近我国某任性、任姓的房地产、网络大V被有关部门封号的事情，他语重心长地告诫艺人们到： 你们不要怕，我被封杀过、被下架过、被嘲笑过，依然站在了这里，靠的是什么？是作品！如果你知道去哪，世界都会为你让路！加油，我的中国朋友，再次感谢！ 另据小道消息： 《荒野猎人》中国内地正式定档3月18日上映，宣传方还表示小李子确定将来华宣传影片。]]></content>
      <categories>
        <category>心旷神怡</category>
        <category>一颗赛艇</category>
      </categories>
      <tags>
        <tag>小李子</tag>
        <tag>长者</tag>
        <tag>奥斯卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[男人需要一场婚礼]]></title>
    <url>%2F2016%2F02%2F27%2F2016-wedding%2F</url>
    <content type="text"><![CDATA[多日不见，别来无恙？ 今天已经是2016年2月27日，正月廿一。给大家拜个晚年了：祝大家猴年大吉，心想事成，工作顺利，万事如意。 公众号自从1月24日最后一次更新以来，断更一个多月，一不小心就堕落成「月经贴」了。一来是因俗事缠身（这个春节，我完成了人生中的最重要的一件大事）；二来也怪我偷懒倦怠荒废了公众号更新进度。 昨晚打开公众号后台，居然发现还新增了十几个粉丝，诸位厚爱至此，令我受宠若惊。感谢你们对我一如既往的的支持与信任，我会继续将这个公众号好好做下去，保持每周两到三篇的博文更新频率，争取早日拿到「原创」标志。 花开二朵，各表一枝。公众号的事咱先按下不表，下面说点重要的事。 ​给大家报个喜：2016年2月18日，农历正月十一，本人与爱妻正式结婚🎎。 有人说： 男孩子，都是在一瞬间长大的。他们不像女孩子一样心理年龄普遍要大过实际年龄；甚至很多男性，三十而立之后，都没有真正的长成一个男人。 和菜头在《情人节前夜写给男生》中也有过类似的一段话： 坦率说，我认为是我国男性和女性并不生活在一个时代。男人天生有一种病，叫做时间不敏感。对于时间的认知，一个男人很可能在十几岁就停止了。不知道具体什么时候，反正就是那么一下子，咔嚓，时间凝固下来。所有的事情都像是在昨天24小时之内发生的，十年、二十年光阴，对于时间不敏感症患者的男生来说，并没有多大差别。所以，经常会发生什么重返母校的活动中，有男生从双杠上摔下来骨折，或者翻栏杆重温旧日时扭伤腰部—因为他内心里觉得自己还是当年那个白衣飘飘的少年郎，根本没有认识到自己已经悄然老去，筋骨僵硬，肚腩前凸。 大多数男人真正地成长起来，都是以同一种方式：结婚。 男人，需要婚礼这种郑重肃穆的仪式感，来让自己接受他已不再是那个能放浪形骸、自由洒脱的家伙了，他现在多了几份责任：丈夫、女婿、爸爸…… 我是从我的婚礼的那一刻后，意识到，仪式感对于人生来说，是多么的重要。我们需要盛大的欢聚，盛大的离别，盛大的狂欢，盛大的礼物，才足以成就人生的丰富。 只有经过这么一场喧闹，才能照见到彼此心中的郑重，不管外面如何喧哗，在那一刻。在夹杂着喧嚣、浮夸、喜泣的热闹里面，你反而最沉静，前所未有的清晰，我们就这样托付给了对方，从此荣辱与共，携手白头。]]></content>
      <categories>
        <category>心旷神怡</category>
      </categories>
      <tags>
        <tag>丙申</tag>
        <tag>婚礼</tag>
        <tag>男人</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dup2 | 考得一首好古]]></title>
    <url>%2F2016%2F02%2F03%2Fdup2%2F</url>
    <content type="text"><![CDATA[这两天在看 《Unix 环境高级编程》，学到了不少好姿势，还意外地考了一次古。 dup &amp; dup2关于这两个系统调用，Unix 圣经里已经介绍得很清楚了, man dup可以看用法。 123#include &lt;unistd.h&gt;int dup (int filedes);int dup2(int filedes, int filedes2); 两函数的返回:若成功为新的文件描述符,若出错为-1，返回的新文件描述符与参数 filedes 共享同一个文件表项。 由 dup 返回的新文件描述符一定是当前可用文件描述符中的最小数值。用 dup2 则可以用 filedes2 参数指定新描述符的数值。如果 filedes2 已经打开,则先将其关闭。如若 filedes 等于 filedes2 ,则返回 filedes2 ,而不关闭它。 有关这部分的知识点我就不啰嗦了，放截图： 这两款调用非常给力，它们经常用来重定向进程的 stdin,stdout. 重定向好似抗战片中，我铁道游击队阻击日本鬼子，将铁轨移到别的路上：或南辕北辙，转向一条错误的道路 fd；或干脆把铁轨坠下深谷 /dev/null。 但是，后来问题来了: 你为了让自己干活方便，把管子移到别处了，你干完活后，总不能留下一地鸡毛就走吧，为了不影响后来人，得把现场恢复。 看了下前辈们的血泪史，偶遇一个11年前的好贴 《使用dup2重定向了标准输出后,使用什么方法恢复对终端的输出??》 解决了心中疑惑。 Demo来来来，搞个 demo 验证下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;;#include &lt;unistd.h&gt;;#include &lt;stdlib.h&gt;;#include &lt;fcntl.h&gt;#include &lt;sys/types.h&gt;;#include &lt;sys/stat.h&gt;;#include &lt;string.h&gt;;#include &lt;strings.h&gt;;#define TESTSTR "Hello dup2\n"int main ()&#123; int fd3; int s_fd; int n_fd; int r_fd; fd3 = open ("testdup2.dat", O_WRONLY | O_CREAT| O_TRUNC, 0666); printf ("after open, fds:%d\n", fd3); if (fd3 &lt; 0) &#123; printf ("open error\n"); exit (-1); &#125; // 复制标准输出描述符 s_fd = dup (STDOUT_FILENO); printf ("after dup, s_fd:%d\n", s_fd); if (s_fd &lt; 0) &#123; printf ("err in dup\n"); exit (-1); &#125; // 重定向标准输出到文件 n_fd = dup2 (fd3, STDOUT_FILENO); // 写入testdup2.dat中 printf ("after dup2, n_fd:%d\n", n_fd); if (n_fd &lt; 0) &#123; printf("err in dup2\n"); exit(-1); &#125; // 写入testdup2.dat中 write (STDOUT_FILENO, TESTSTR, strlen(TESTSTR)); // 恢复标准输出 r_fd = dup2 (s_fd, STDOUT_FILENO); printf ("after restore, r_fd:%d\n", r_fd); if (r_fd &lt; 0) &#123; printf("err in dup2\n"); &#125; // 输出到屏幕上 write (STDOUT_FILENO, TESTSTR, strlen(TESTSTR)); return 0;&#125; 编译，运行： 123456789hxz@pc0170:~/workspace/c++$ gcc -o dup dup.chxz@pc0170:~/workspace/c++$ ./dupafter open, fds:3after dup, s_fd:4after restore, r_fd:1Hello dup2hxz@pc0170:~/workspace/c++$ cat testdup2.datafter dup2, n_fd:1Hello dup2 归纳一下，利用 dup/dup2 处理 i/o的大致流程: 12345678910fd2 = dup(STDOUT_FILENO); //fd2表示stdout fd = open(filename, O_WRONLY|O_CREAT, fd_mode); dup2(fd, STDOUT_FILENO); //把输出重定向到新打开的文件fd //all stdout content will be redirect to fd close(fd); dup2(fd2, STDOUT_FILENO); //恢复stdout 小明在 2016 年了翻出了 2004 的技术帖，今天真是考得一首好古啊～蛤蛤]]></content>
      <categories>
        <category>Coder</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>dup</tag>
        <tag>dup2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[管道是个好东西]]></title>
    <url>%2F2016%2F02%2F02%2Fpipe%2F</url>
    <content type="text"><![CDATA[临近春节假期之际，我司提供给客户用的命令行工具还遭遇一个新需求： 支持管道输入/输出。 需求背景： 原始的视频流体积巨大（一个十分钟视频的原始视频流就占用 2G 多空间），为了节约机器资源，客户希望能将原始的视频流直接通过管道输入，而不必转码生成临时媒体文件。 简而言之，客户希望支持这种调用方式： 1cat some_big_rawvideo | ./my_prog 比如，我们用到的 ffmpeg 和 ffplay 工具也支持通过 - 或 pipe来指定管道输入输出： 123ffmpeg -i input.mp4 -f avi - | ffplay -ffmpeg -i input.mp4 -f avi pipe: | ffplay pipe:ffmpeg -i input.mp4 -f avi pipe:1 | ffplay pipe:0 不幸的是，我们现有的工具并不支持，它只能根据命令行中的文件路径来指定输入输出。 1my_prog -i /path/to/inputfile -o /path/to/outputfile 咋办？改！ 已知首先，小明知道，对于标准的命令行程序，它遵从基本的「一进二出」规范。 123456789 ---&gt; stdout, pipe:1 / / ||======================||stdin, pipe:0 ---&gt; || cmd || ||======================|| \ \ ---&gt; stderr, pipe:2 管道管道是 unix 设计哲学之一，其核心思想就是将前一个命令的标准输出作为后一个命令的标准输入。 比如programo0 | program1 | program2 的输入输出示意图如下： 12345678910111213 stdin stdout stdin stdout stdin stdout || ======================= ====================== /\ || /\ || /\ || || || || || || || || \/ || \/ || \/ ||||==========|| ||==========|| ||==========|||| program0 || || program1 || || program2 || ||==========|| ||==========|| ||==========|| || || || || || || \/ \/ \/ stderr stderr stderr 基于这么一条简单到爆的原则，管道通过 | 把一系列命令连接起来：第一个命令的输出会作为第二个命令的输入通过管道传给第二个命令，第二个命令的输出又会作为第三个命令的输入……，最终结果为管道行中最后一个命令的输出。 举个栗子： 1cat /etc/passwd | grep /bin/bash | wc -l 这条命令使用了两个管道，利用第一个管道将 cat 命令（显示passwd文件的内容）的输出送给grep命令，grep命令找出含有/bin/bash的所有行；第二个管道将grep的输出送给wc命令，wc命令统计出输入中的行数。这个命令的功能在于找出系统中有多少个用户使用bash。 stdin stdout stderr在 unix 世界中，一切皆文件。文件描述符是与打开文件或者数据流相关联的整数，0、1、2 是系统保留的三个文件描述符，分别对应标准输入、标准输出、标准错误。 0: stdin 标准输入串流 (键盘輸入） 1: stdout 标准输出串流 (终端屏幕） 2: stderr 标准错误输出串流 (终端屏幕) 重定向比如： 1my_prog &lt;inputfile &gt;outfile 2&gt;&amp;1 将标准输入重定向到 inputfile（意味着 my_prog不再从标准输入而是从 inputfile 中读取数据），将标准输出和标准错误结果都重定向到 outfile。 如何才能让一个命令行程序支持管道？So，小明上 StackOverflow 上先看看各位同仁怎么说： To be “pipe compatible” your program will need to read from stdin and write to stdout. 原来如此:「为了支持管道，你的程序需要从 stdin读取输入并且将输出写到 stdout」 小试牛刀1234567891011121314151617181920//pipe-std.c#include &lt;stdio.h&gt;int main()&#123; FILE * fi = stdin; FILE * fo = stdout; char buf[1024]; int r_cnt, w_cnt; while ((r_cnt = fread (buf, 1, 1024, fi)) &gt; 0) &#123; w_cnt = fwrite (buf, 1, r_cnt, fo); if (w_cnt != r_cnt) &#123; fprintf (stderr, "some err: %d, %d\n", r_cnt, w_cnt); return -1; &#125; &#125; return 0;&#125; 这个示例非常简单，编译、运行： 123456hxz@pc0170:~/workspace/c++$ gcc -o pipe-std pipe-std.chxz@pc0170:~/workspace/c++$ ls -l ~/test/input/2.mp4-rw-r--r--@ 1 hxz staff 1958612 Nov 27 18:01 /Users/hxz/test/input/2.mp4hxz@pc0170:~/workspace/c++$ cat ~/test/input/2.mp4 | ./pipe-std &gt;copy.mp4 2&gt;errorhxz@pc0170:~/workspace/c++$ ls -l copy.mp4 -rw-r--r-- 1 hxz staff 1958612 Mar 1 14:22 copy.mp4 瞧见了没，这个简单的程序通过管道将输入的内容~/test/input/2.mp4复制到输出copy.mp4。 实践出真知原理搞懂了，接下来就是体力活了。在实际码代码过程中，还是发现了几点管道程序需要注意的地方： 由于是从管道读取输入内容，而管道每获取到片段内容就会发送到下一级程序处理，这意味着我们不能事先获知输入文件的大小了。因此，像 get_file_size之类的方法将不再可用。 管道内容只能顺序读取，不可逆回溯，也不可重复读取同一段内容。所以啊，我们的程序要珍惜每一次读取的机会，不能open了再open，只能open、do_work1、do_work2……close 。具体到 ffmpeg 解码程序就是，avformat_open_input 这个api只能用一次，一次就要把需要的信息全部预加载进来。]]></content>
      <categories>
        <category>Coder</category>
      </categories>
      <tags>
        <tag>pipe</tag>
        <tag>C++</tag>
        <tag>ffmpeg</tag>
        <tag>命令行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[张小龙饭否语录]]></title>
    <url>%2F2016%2F02%2F01%2Ffanfou-Zhang-Xiaolong%2F</url>
    <content type="text"><![CDATA[饭否因为张小龙重新火了一把，蛤蛤。 人性 中小学每次考试都给同学们排名，这应该让所有人都增强了对比意识和自卑心理吧。2010-12-29 15:33 人生是个被道德调制的过程，却没有人负责解调。2010-12-29 15:49 如果社会进步到没有商人了，生产的人直接赚钱，该是种进步吧。app store所以好。2010-12-29 16:32 让子弹飞激起男人的豪情女人的柔情，是因为，子弹象征着精子。2010-12-29 16:41 所以“让子弹飞”是今年名字取得最好的电影名。2010-12-29 16:43 爱如潮水的科学解释来自于月亮对地球的影响。2010-12-29 17:19 鸟的羽毛是给自己用的，人的羽毛是给别人看的。2010-12-30 15:04 话语在口语口之间传播，形成为可通过传播来生存的有生命的文化。因此，对着树洞说话属于观点自杀行为。每句话，都有它的自私基因，都是希望能更远更长久地生存下去。2010-12-30 15:22 人类做的几乎每一件事情都是错的，却要求机器做的每件事情都是对的。2011-01-02 16:41 古人写诗写词，不超过140字，是因为墨水太贵。今人写微博，纯属偷懒。2011-01-04 19:23 《黑天鹅》里总结得太好了：人有天生的归纳能力来将复杂事物模型化。但这也导致人的认知误区，没有见过黑天鹅就认为天鹅都是白的。2011-01-05 16:43 《黑天鹅》让我知道我是如何被我的经验和直觉所愚弄了。2011-01-06 12:37 没有自由的人，只有被念头所控制的人。2011-01-07 16:09 转：“人们往往出于责任做慈善，但事实是，做慈善有益于自己的身心，有助于自己了解生活。我从难民身上学到了最多东西，比如如何当母亲、做一个坚强的人并生存下去，所以我只是希望能回报一些东西。”–安吉丽娜朱莉 2011-01-09 14:50 人的思维如同膝跳反射，需要外力刺激一下才会反弹。弹得不好就变成踢人了。2011-01-11 02:02 谈产品 和“敌人比我们自己更了解我们”相对应的是，用户比我们自己更了解我们的产品。产品是有人用才成为有灵魂的产品，图纸和代码堆出来的只是躯壳。2010-12-29 16:30 人走茶凉是世间常态，但是在机器的世界里，ID是永恒的。2010-12-29 17:24 很多人争论说自己选择的手机是最好的，别人选择的手机是垃圾。大部分时候，他们争论的不是手机，是捍卫自己的选择是聪明的，怕被别人当作傻逼。但我就承认，我用了10年windows并且当时觉得windows很好，是很傻逼的。2010-12-30 14:27 针无两头利。考核一个技术专家，还要要求他有极好的客户导向，难。2010-12-30 14:41 我不跟人说我正在做的东西比别人好，因为我无法保证中立。但我可以说我做的东西有什么不好，因为我很了解。对祖国也是这样。2010-12-30 15:46 在经过3天的吵架式讨论之后，终于砍掉了一个已经做好的功能。2010-12-30 20:20 中移动有个秘密一直未跟用户说：其实短信是不会丢失或延迟的。移动太了解人性了，每天，有多少人都在用“没有收到短信”或者“才看到短信”作为借口啊！2010-12-30 22:58 当whatsapp，kik，米聊，速聊，kiki都狂推实时聊天概念时，老夫决定反其道而行。2011-01-02 15:18 你问我们和竞争对手比有什么区别，我说我们没有他们那些臃肿艳俗的部分。2011-01-02 15:20 在一个always online的时代，就不需要宣称自己是否是online的了。但always online并不意味着需要立即回应。2011-01-02 15:27 短信的好处在于它是默认隐身的。2011-01-02 15:31 这么多天过去了，米聊竟然才3千个用户。2011-01-03 18:58 FaWave这类工具，汇集了多个产品的数据和功能，看似提高效率，但人毕竟不只是效率工具，汇集类工具脱离了原产品的气息后，就丢失了对产品的情感认同。2011-01-03 19:29 所谓的“N合一”产品，都是单个产品做烂了以后，合起来甩卖。2011-01-03 19:32 表白这么多，是时候搞个表白网了。转@像疯一样 又有人要表白了。刚在学校教学楼公告栏看到的，差不多每个布告栏都贴满了 http://fanfou.com/photo/lyg...2011-01-05 16:51 我们总是高估了用户的智商，低估了用户的情商。2011-01-06 17:48 小众的会做得更动人，大众的会做得更中庸。2011-01-10 12:58 正儿八经竟然上榜了，这事让我明白，蝴蝶效应背后，其实还是有推手存在的。2011-01-10 18:19 评论的意义：一个人如果自顾自写东西会写到离谱，评论相当于自动控制系统的负反馈，让人从偏激中收缩，趋于稳定。最终一个社区的个体互相影响，形成一个稳定的中庸的气场。2011-01-11 18:52 谈科技 当我在嘲笑盛大kiki的时候，其实我比它也好不了多少。2010-12-30 16:58 quora让我感叹的是，人家的知识底子确实必我们厚太多了。2010-12-31 01:36 古人对过去的一年有无数种表达方法，如今是数字时代，统一表达为“2010”。看起来像3进制的。2010-12-31 13:42 if 2010-1/365 then 2010+1 2010-12-31 13:46 企业email越来越成为官僚化的工具。少数的无能的人拼命通过email来混个脸熟。2010-12-31 15:23 现代通讯工具的要义是：我发出消息，你看，或者不看，都与我无关。人们在IM上花费的时间将越来越少。2011-01-01 14:33 方向盘是手的延伸，油门刹车是脚的延伸。汽车并不单是个运输工具，而更像人工肢体。开车和坐车是不同的。对驾驶者来说，汽车是有生命的。2011-01-02 15:16 手机QQ，是当作留言性质用，还是狂聊的多呢？转@bjshadow 移动QQ不就是吗？实时聊天一个很重要的体验就是输入法要好用。转@gzallen 手机上需要实时聊天吗？谁有耐心用手机输入来聊天呢？2011-01-02 15:16 手机是人的最重要的人工器官。2011-01-02 15:33 电脑都能接摄像头看到外部世界了，盲人们还无法接个摄像头将图像接入到视觉神经。可见神经系统很复杂。2011-01-02 15:35 一些手机软件说，将通讯录的电话号码用“不可逆的单向加密上传到服务器，无人可以知晓号码”。问题是，全球手机号是有限的，先生成对应表，遍历一下就逆向破解了。2011-01-03 14:53 围棋是个介于模拟和数字之间的奇怪事物，它自古就有，但又只有0和1两态。2011-01-04 18:56 如果有这样一个网站，号称数据放在月球，服务器放在卫星上，太阳能供电，永久运行，100年没问题。因此，你写的任何记录都会永久保存。不知道会不会很多人去用。2011-01-04 19:31 看到那么多人在macbook里面直接运行windows，我就想，苹果你也有失败的时候啊。2011-01-05 00:49 10年前我跟用windows mobile的朋友争得面红耳赤到底是windows手机好还是塞班手机好。现在我不争了，直接说，你手里的是最好的。2011-01-05 00:52 总结一下，我在app store花钱买的软件基本都没玩过几次。一些免费的倒经常用。有可能是，卖钱的软件都不会有人气。2011-01-05 01:37 用macbook的恶果终于出现了：以前用鼠标，中指基本没用，而macbook的触摸板，全靠中指了。现在中指痛。2011-01-06 14:56 以后的互联网公司的组成是，一个ceo和一堆会写程序的机器人。2011-01-10 15:05 成功是个概率事件，这些传记可以当故事看，但不能当推理看。2011-01-10 18:09 谈饭否 你最需要他们加上什么功能？我来转告。转@琦殿 饭否从回归到现在，功能几乎没有任何改善，我很失望。凭感情做事，做不长久。2010-12-30 14:18 一个最聪明的饭否机器人是：对每一个帖子，都转播一句话，“表现贴。鉴定完毕！” 是基本不会错的。对@大本钟beta 这类机器人就无效了，只有机器人不需要表现什么。2010-12-30 15:07 所谓话痨，就如同一个美女，不停地到镜子前面照一下镜子。只不过，镜子上有个自动相机，把每次镜子的影像都自动发到饭否上了。2010-12-30 15:37 每条消息，都是一个快照，饭否是个相机。2010-12-30 15:46 我的消息是555了，应该给我挂个三五香烟勋章的。2010-12-31 20:19 饭否确实有bug，一些消息，在ta的个人页可以看到，但是timeline没有显示。2011-01-02 17:10 子说，吾日三省吾身于饭否，不亦乐乎。2011-01-05 01:53 什么时候，中国的sns将“饭局”这个应用做火了，一定大快民心。2011-01-06 01:11 每天能够抛离烦琐杂事来饭否刷下，还是很爽的。以后饭否上刷屏应该叫做刷锅。2011-01-10 01:48 谈sns 李开复说：“有网友问我为什么写微博。回答：记录自己的思想和趣事 +正面影响社会和他人。” 我想，唐骏也会这么回答的吧。2011-01-05 01:33 初次进入pengyou.com，同事很多啊，唯一一个加好友的请求，竟然来自pony。这是不是一个要鼓励公司同事都用的策略呢。2011-01-06 00:44 在pengyou.com里决定加入一个行业，叫做“互联网”，必须选择职务，通看一遍，有测试猿但是没有PM这个职务，于是我选择了“嵌入式硬件开发（主板）”。2011-01-06 00:50 pengyou.com让我头晕目眩。看来我是跟不上热闹事物的节奏了。2011-01-06 01:09 怎么看怎么觉得社交这个词很有中国气质。似乎社交是种技能和工具，而不是生活。2011-01-06 01:21 新浪和腾讯微博的社交气氛太浓厚，建议改名为社交微博。2011-01-06 01:23 将来每个人需要两个微博，一个是社交型微博，一个是自我表达型微博。2011-01-06 01:26 刚看到的，“如果这个世界上有什么事比谈论自己更重要的话，那就是能够探究一个陌生人的陌生生活了。”2011-01-06 02:40 微博是个穿衣服的地方，饭否是个脱衣服的地方。2011-01-06 12:44 社交网络，并不是好友越多越好。2011-01-06 13:13 sns上，一下子给我100个好友，怎能给我一个一个去发现和找到好友的乐趣呢。2011-01-06 13:16 很多人学了数据结构以后，思维就变得太结构化了。这就是微博的结构化数据展示的来由。2011-01-07 19:13 社会是所大学，选修表演专业者众。2011-01-07 21:37 我不能孤独地坐在微博身边。这可能是我用微博少了的原因吧。2011-01-09 01:33 认识的人超过一个村子的人，就应该算太多了。2011-01-10 01:42 陌生人组成的社区，虽然冰冷，但是去掉了熟人社区的温情和虚伪，多了规则。2011-01-10 15:30 关系千万重。facebook竟然要将关系一网打尽，它不会有好下场的。2011-01-11 18:19 开复竟然写了本《微博改变一切》的书。我很佩服他竟然能就微博写出那么厚一本书出来。2011-01-11 19:33 微博改变了什么吗？改变了工作？房价？生活？交友？舆论？2011-01-11 19:34 牧羊人把羊群从三只一堆划分成十只一堆，然后说，everything changed。2011-01-11 19:36 央视决定出一本书，《春晚改变一切》2011-01-11 19:40 有一句歌词是这么唱的，“是微博改变了我们，还是我们改变了微博”。2011-01-11 19:45 谈 windows windows的糟糕的字体表现让中国人的UI审美水准滞后了10年。2010-12-30 03:29 在鄙视了windows mobile多年之后，开始为windows phone7叫了一声好。微软这次能在iPhone之外找到了完全不同的另外一种交互模式，还是很牛逼闪闪的！2010-12-30 15:32 抽风 我智商高的时候，情商就低。情商高的时候，智商就低。两个一样高的时候，我就双高了。2010-12-29 01:20 夜间不睡觉，天明徒悲伤 2010-12-29 02:07 “严以律己，宽以待人”这么假的一句话竟然流传至今。所以我的输入法直接显示的组合是，“宽衣待人”。 2010-12-30 17:17 我知道一个真相，就是真相是基本不会知道的。2011-01-03 17:38 为了让我的air能开光，我决定带它去星巴克喝咖啡。2011-01-03 17:57 清醒就是痛苦，一般指晚上睡不着。2011-01-04 02:39 晚上闲到闷头睡，白天睡到自然醒。2011-01-04 02:43 内心强大的检验标准是，是否怕冷。2011-01-04 17:48 乱花确实迷人眼，但谁又不喜欢乱花呢。2011-01-05 02:05 要给农民兄弟们做个网站，让他们聚集在村口的大树下面聊天。2011-01-05 02:25 谈工作 工作邮件，现在基本上只看邮件标题了。2010-12-29 16:07 看来，沉默才能长久啊。转@Xiaochao99 而我已经从里边被移除。。。转@gzallen 有个叫lecterhe的人还每天都出现在微博运营日报邮件的收件人里。2010-12-29 18:38 在提交完年终考核之后，我身心如橘皮。2010-12-30 15:41 下午两件事：处理邮件和谈话。并在这些事情的间隙到饭否发泄情绪。2010-12-30 16:38 去年就是itouch。转@马克叔叔 itouch4 背后激光刻 转@gzallen 每年，我们都会给同事们发一个礼品，并把名字刻在上面。正在想今年能发个什么牛逼哄哄的东西值得刻名字上去的。2010-12-30 16:54 办公室竟然有私欲在飘荡 2010-12-31 15:59 同意。请各部门按此落实执行。转@和菜头 公司里，凡是有老板参加的会议就拼命发言的人，凡是有抄送老板的邮件就拼命回复的人，直接炒掉根本不会影响任何业绩，而且团队的开心度上升了。2010-12-31 17:19 为了让大家有更多时间干活，决定取消今天下午的周会。2011-01-04 15:29 作为PM，怎么能悲伤地坐在开发人员身旁呢。所以从小诅咒有感而歌。2011-01-06 12:24 将whatsapp，kik，miliao打下来，也算是个小小的刺激吧。2011-01-10 01:19 我现在沦落到只能靠折磨programmer为乐了。2011-01-10 01:52 决定买个sim卡来正儿八经地体验下windows phone。2011-01-10 15:21 决定买个红杏牌vpn来正儿八经地体验下出墙。2011-01-10 15:37 决定买个饭岛来正儿八经体验下神马叫爱。转@Xiaochao99 决定买个腾兰来正儿八经体验一下什么叫武。2011-01-10 17:26 明天要开大会了。尝试下用饭否来写ppt。主题是创新。2011-01-11 22:25 1，创新是无稽之谈。创新不是决定取舍的理由。创新一般都是空想。创新是靠不住的，死得很快的。2，要的，是把握用户心理。其结果，才被观察为创新。3，创新是件碰运气的事，你只是蝴蝶，剩下的交给云。ppt over。2011-01-11 22:31 生活 中午剪头发，是个男的洗头，我只能奋力想象，这是机器手臂。2010-12-29 15:32 钟南山说，空气污染对肺的伤害远远超过吸烟了。搞得我都不好意思戒烟了。转@阳光不锈钢 RT @elaoda 中国疾病专家最近表示，中国空气污染与呼吸疾病的联系越来越紧密，广州、北京、上海等许多大城市都面临肺癌率明显上升的趋势，肺癌已经取代肝癌成为中国癌症死亡的第一杀手。2010-12-29 17:09 今天证明了，刷瓶确实是有快感的。2010-12-30 17:01 各位饭友新年快乐了！2011-01-01 00:43 2010，股沟走了，360运动了，群众怒了，微博火了，苹果牛逼了，饭否回来了，巴尔扎克来了，春天快到了，春晚又要上演了。2011-01-01 01:45 你问我去向何方，我指着球场的方向。打球去了。2011-01-01 14:13 你们这些人一到深更半夜就来劲啊。2011-01-02 02:52 睡前饭否？No，会长胖的。看看@和菜头 吧！2011-01-02 02:54 大家，晚安 2011-01-02 03:15 我证明，这是虚构的。转@和菜头 上岛咖啡不行的。。。转@大咸魚 为啥我天天带着没人理。。。 转@和菜头 早不出！！！转 @苑小帅 MacBook Air 果真是装逼神物，今天下午坐咖啡厅4个小时，去掉认识我的，还有4个美女过来搭讪，ipad党赶快投靠MBA吧。 #人人都是装逼犯 2011-01-04 01:27 装，当然要装壁，我没听说过宁住毛坯房也不装修墙壁的。2011-01-04 01:38 从今晚开始，早睡。从明天开始，早起。2011-01-06 01:37 起得太早就会无所事事。2011-01-06 12:40 想起一天中最美好的时刻，就在午夜1点。2011-01-10 01:12 文艺 夜阑卧听风吹雨，铁马冰河入梦来。2010-12-30 03:32 安得大叔千万只，大庇天下腐女俱欢颜。2010-12-30 15:16 一个人在不务正业的时候，干出来的事情往往是最牛逼的。2010-12-30 15:17 理想成为现实的点缀，还是比没有点缀要好点。2010-12-30 15:25 说出来的，如水花跃出水面，稍纵即逝。没有说出来的，还在暗流涌动。2010-12-30 15:38 将树干涂上白漆，是为了显示出庄严感吧。2010-12-31 00:14 在网上看到母校的一张照片，恍惚半天。我怀念的不是母校，只是我住过的宿舍。2010-12-31 00:17 人说女人被物化，我还不信，现在连xiaochao也称她为它了。转@Xiaochao99 2010马上过去了，我很怀念它。2010-12-31 17:26 多年前，我在武昌的体育馆听崔健的现场，是纯粹的荷尔蒙的盛会。现在，是一堆老男人在回味当年的味道吧。转@和菜头 崔健演唱会，大多观众为中年糙汉。 http://fanfou.com/photo/4tN... 2010-12-31 20:13 脑满肠肥的粉丝们已经不再一无所有了，不再问你何时跟我走了。2011-01-02 03:08 年岁越大，朋友也越来越少了。2011-01-06 01:18 抖机灵 人民搜索有A片？转@和菜头 谷歌：搜一下，全知道。百度：搜一下，让你知道的你知道。人民搜索：你搜个毛啊你？！2010-12-29 15:36 不让让人知道有气无力吧。转@泡芙先生 十万个为什么：为什么生日蜡烛要一口气吹灭？2010-12-29 15:35 人类群星闪耀，是牛逼照出来的。2010-12-30 15:33 我说，或者不说，意识都在那里，没有多一份，没有少一份。2010-12-30 15:34 人类群星总能闪耀，说明人类总是在夜间。2010-12-30 15:39 盛大出了一个叫“Kiki”的软件。我只能说，好歹，不要在名字上也这么山寨吧！取个名字有那么难么？2010-12-30 15:53 我以为她说，“你把我倒起来看看”。转@马克叔叔 林志玲对记者说，“我的胸是真的，如果我要是说谎，以后就把名字倒起来念。”看来取名字很重要。–转 2010-12-30 17:02 空山新雨后 人比黄花瘦。一个自动组句的尝试。转@和菜头 自发性直觉写作需要药物，冥想，或者简单一点：随意说废话，直到句子自动组织起来，意象喷涌而出 2011-01-02 02:51 搞IT的人看不到月亮，一个都没有，更别说两个。2011-01-04 02:14 牛逼的bug，都选择在1月1号或者4月1号才发作。2011-01-04 02:48 不管你怎么说互联网的发展如何被我们的国学所包涵，我知道的是，扎克伯格不懂我们的国学。2011-01-04 17:56 我说网民怎么增长这么快。农民们都没地了，或者离开土地了，不上网干嘛？2011-01-04 20:41 一种新型的智能验证码诞生了。转@和菜头 Twitter今天的热词No.1是：tYp3 LyK tHi5。这是英文和数字的混合，意思是：Type like this。原句是：If you tYp3 LyK tHi5 I hope you can read this: k7LL y0 2011-01-09 01:56 天气很冷的时候，说的笑话都成冷笑话了。2011-01-10 01:46]]></content>
      <categories>
        <category>心旷神怡</category>
      </categories>
      <tags>
        <tag>张小龙</tag>
        <tag>饭否</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[间谍之桥 | 大师手笔，尽管放心]]></title>
    <url>%2F2016%2F01%2F31%2FBridge-of-Spies%2F</url>
    <content type="text"><![CDATA[历史背景简介: 1957年，鲁道夫·阿贝尔因涉嫌充当苏联间谍而被逮捕，纽约律师詹姆斯·多诺万被推荐去当他的辩护律师。在多诺万的努力之下，阿贝尔最终被免除死刑，判30年监禁。 1960年，美国空军飞行员加里·鲍里斯因驾驶侦察机在苏联上空拍照被击落俘虏。美苏双方私下达成协议，将在柏林伯尼克桥互换阿贝尔和鲍里斯，但介于局势敏感，多诺万以非官方身份被派往柏林进行交换事宜，而他最终不止救出了一个人…… 这是一个关于「交换俘虏」的故事，斯皮尔伯格以回归古典主义的手法娓娓道来，没有故作煽情，没有各种拍摄的奇技淫巧，有的只是一股慢慢渗透的剧情张力，让你在觉得不温不火的同时却始终按不下停止键。 这是一部工整的片子，如教科书般工整的主旋律电影，一如既往的考究的细节，一如既往的四平八稳的叙事，一如既往的几近完美的调度。斯导还是那个斯导，宝刀未老，人物塑造之成功，柏林危机反映之真实，令人震撼，令人心寒。 给想看这部电影的人一个定心丸：大师手笔，尽管放心。 间谍惊悚与法庭文案的完美结合，斯皮尔伯格又贡献了一部优雅、智慧并具娱乐精神的电影。9分，高分力荐所有人观看，我觉得奥斯卡应该爱它，而不是《荒野猎人》，小李子继续去厕所哭吧～ 宪法 人权汤姆·汉克斯在面对 CIA 猥琐探员朗诵的那段鸡汤箴言听起来老套却依然带感： 你我来自不同的国家，正是我们称之为宪法的东西，使得我们成为「美国人」。 他在最高法院九位大法官前为了捍卫苏联间谍的人权将美式人权鸡汤炖至沸腾： who we are – is that not the greatest weapon we have in this Cold War? 在我看来，片名《间谍之桥》除了交换俘虏的那座大桥，更多地，是在比喻多诺律师。他竭尽自己所能，冒着死亡的危险，去拯救一个敌国的间谍的生命，一个素不相识的CIA飞行员的生命，以及，一个留学生的生命。他凭借一己之力，在险恶的国际政治漩涡之上架起一座保护生命与正义的桥梁！ 友谊多诺敢于忤逆美苏两个大国的意志，只因为他是鲁道夫·阿贝尔的律师。 他也不负律师这个职业，他甚至不在乎阿贝尔是否真是间谍，即使他隐约感觉到阿贝尔真是间谍。从死刑争到30年监禁，判决后上诉至联邦最高法院，在9位大法官慷慨陈词，直到他的家人因为受到公众骚扰才不得不中止。 他们建立起一种微妙的友谊，多诺为了能救出阿贝尔不惜远赴动乱之中的东德于反覆无常的俄国使馆交涉互换俘虏事宜，而阿贝尔也视多诺为知己，看到多诺，阿贝尔才会改变僵硬、凄冷、无助的表情，朝他久违一笑。 他也相信多诺，在伯尼克桥交换俘虏的关键时刻，多诺还在等待西德当局押送的另一名美国公民（一位在东德研究共产主义经济的25岁研究生）。当时，美方人员明确告知他已恢复人生自由，可自行离开步行至桥对头。但阿贝尔此刻没有马上就走，当他发现多诺似乎还在等另一个人时，他说： 我愿意多等一会。 也许，在阿贝尔心中，他和多诺惺惺相惜，多诺甚至比他死死守护的苏联更贴心。接送阿贝尔的苏联人员甚至都没有给他一个拥抱，阿贝尔被苏联人员押送上车，他夹在中间，旁边坐着两个人，可以看出，他是不受苏联待见的，他们怀疑他熬不住煎熬已经泄漏了苏联的国家机密。]]></content>
      <categories>
        <category>心旷神怡</category>
      </categories>
      <tags>
        <tag>间谍</tag>
        <tag>冷战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本来天气预报说今天有雨]]></title>
    <url>%2F2016%2F01%2F18%2Fit-says-today-will-be-rain%2F</url>
    <content type="text"><![CDATA[本来天气预报说今天有雨，江主席一来天清气朗。 今天来聊一聊我国当代著名的气象专家：徐嘉诰老先生。 那是1947年，当时竺可桢老先生因为于子三事件（http://baike.baidu.com/view/251380.htm）和 KMT（原名罗马化：Kuomintang；简称国民党、KMT；英文亦可直译作“Chinese Nationalist Party”）闹翻了，一家老小住在杭州浙大医学院教师公寓的斗室之中，生活困顿。 徐老爷子在一个雪天从上海益民食品厂弄来一车即将过期的蛋糕，解决了燃眉之急。 竺老先生一高兴，就口授了一部《天气晴朗学》，徐老爷得此真传，加上天资聪颖，勤奋专研，刻苦攻读，数十年后，终有所成。 据徐老的夫人回忆，相处几十年，徐老先生一有闲暇，便会抬起头以45度角仰望苍穹，略有所思，他默默地记录下当天天气状况，并总结出规律，逐渐地，徐老磨练出一种对天气情有独钟的感觉。 所谓天人合一、万法自然，除了静观天象，随时记录晴雨表，徐老爷有时候还会和一些生物现象结合起来。 此中最大的贡献就是把生物学和气象学结合起来，根据一位老学者的出行，就能预报天气了。 徐老灵活应用这项研究成果的高光时刻是在2009年，当时，某位德高望重的领导人视察徐老所在的中国联合工程公司。作为他的学弟，徐老一向将这位长者以慈父视之，在座谈会上，徐老意气风发，他向师兄展示了研究多年的气象生物学，一时传为美谈。 《长江论语》有云： 徐公嘉诰曰：「钦天监主簿语余曰，今日有雨。然尊师驾到，则晴空万里。」 徐老爷子的气象生物学的研究成果获得我党领导的高度重视。 此后，气象生物学在国庆阅兵、世博会、APEC会议等多项大型国际赛事、会议上广有建树，或「阅兵蓝」、或「世博蓝」、或「APEC蓝」，保证了沪、京、粤等地顺利举办各项会议的天气条件。]]></content>
      <categories>
        <category>一颗赛艇</category>
      </categories>
      <tags>
        <tag>长者</tag>
        <tag>徐嘉诰</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular CQRS https request in nw.js]]></title>
    <url>%2F2016%2F01%2F14%2Fangular_cqrs_https_request_in_nw.js%2F</url>
    <content type="text"><![CDATA[This articl records my experience with development on “NW.js + Angular”, implementing https request by $http. pure $httpin nw.js + angualr: host = &quot;192.168.10.69&quot;; $http({ method : &apos;POST&apos;, url : &quot;https://&quot; + host + &apos;/mediawise/auth&apos;, data: &apos;{&quot;protocols&quot;: [&quot;5.2.6&quot;], &quot;user&quot;: &quot;&apos;+ $scope.user.name + &apos;&quot;,&quot;password&quot;:&quot;&apos; + $scope.user.pwd +&apos;&quot;}&apos;, }) .then (function(res) { setLocalStorage(&quot;cur_user&quot;, $scope.user.name); setLocalStorage(&quot;vdnaGenPwd_&quot; + $scope.user.name, $scope.user.pwd); if($scope.remember == true){ $scope.remPwd(); } else { setLocalStorage(&quot;pwd_&quot; + $scope.user.name, null); } $scope.user = {name : &apos;&apos;, pwd : &apos;&apos;}; $scope.remember = false; window.location = &quot;main.html&quot;; }, function(res) { console.log (JSON.stringigy (res.data)); }); in Nginx config: if ($request_method = &apos;OPTIONS&apos;) { add_header &apos;Access-Control-Allow-Origin&apos; &apos;*&apos;; add_header &apos;Access-Control-Allow-Credentials&apos; &apos;true&apos;; add_header &apos;Access-Control-Allow-Methods&apos; &apos;GET, POST, OPTIONS&apos;; add_header &apos;Access-Control-Allow-Headers&apos; &apos;DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&apos;; add_header &apos;Access-Control-Max-Age&apos; 1728000; add_header &apos;Content-Type&apos; &apos;text/plain charset=UTF-8&apos;; add_header &apos;Content-Length&apos; 0; return 204; } if ($request_method = &apos;POST&apos;) { add_header &apos;Access-Control-Allow-Origin&apos; &apos;*&apos;; add_header &apos;Access-Control-Allow-Credentials&apos; &apos;true&apos;; add_header &apos;Access-Control-Allow-Methods&apos; &apos;GET, POST, OPTIONS&apos;; add_header &apos;Access-Control-Allow-Headers&apos; &apos;DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&apos;; } if ($request_method = &apos;GET&apos;) { add_header &apos;Access-Control-Allow-Origin&apos; &apos;*&apos;; add_header &apos;Access-Control-Allow-Credentials&apos; &apos;true&apos;; add_header &apos;Access-Control-Allow-Methods&apos; &apos;GET, POST, OPTIONS&apos;; add_header &apos;Access-Control-Allow-Headers&apos; &apos;DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&apos;; } if you meet this error: Basically you need to use: &quot;chromium-args&quot;: &quot;--allow-running-insecure-content --ignore-certificate-errors&quot;, And it has to go outside of the window object (e.g. after name property) in the package.json file. eg: 123456789101112131415161718192021&#123; "name": "VDNA", "chromium-args": "--enable-file-cookies --allow-running-insecure-content --ignore-certificate-errors", "main": "index.html", "descrption": "client for Ingesting, Query and manage VDNA meta", "version": "0.1.0", "dependencies": &#123; "request": "^2.49.0" &#125;, "window": &#123; "title": "VDNA", "icon": "images/login_bg.png", "toolbar": true, "frame": true, "width": 1180, "height": 820, "position": "center", "min_width": 960, "min_height": 660 &#125; &#125; node request()12345678910111213141516171819202122232425262728function do_request (method, path, data, callback)&#123; var request = require('request'); var options = &#123; url: 'https://192.168.10.111' + path, method: method, rejectUnauthorized: false, //very important headers: &#123; //'Content-Type': 'application/x-www-form-urlencoded', //'Content-Length': data.length, 'Cookie': getLocalStorage ("auth_token") &#125;, &#125;; if (method != 'GET' &amp;&amp; data != null) &#123; options.body = data; &#125; request (options, callback); /* callback = function (error, response, body) &#123; if (!error &amp;&amp; response.statusCode == 200) &#123; ... &#125; &#125; */&#125; or 1234567891011121314151617181920212223242526272829303132333435363738394041424344function do_request2 (method, path, data, callback) &#123; //process.env.NODE_TLS_REJECT_UNAUTHORIZED = "0"; var https = require('https'); var options = &#123; host: '192.168.10.113', port: 443, path: path, method: method, rejectUnauthorized: false, headers: &#123; 'Content-Type': 'application/x-www-form-urlencoded', 'Content-Length': data.length, 'Cookie': getLocalStorage ("auth_token") &#125; &#125;; var req = https.request(options, callback); req.on('error', function(e) &#123; console.error(e); &#125;); req.write(data); req.end(); /* //callback eg: callback = function (res) &#123; var xxx = ""; res.on('data', function (d) &#123; process.stdout.write('RESPONSE:' + d); xxx += d; &#125;); res.on ('end', function () &#123; if (res.statusCode == 200) &#123; //handle received data:xxx &#125; &#125; &#125; */&#125; 参考 https://github.com/nwjs/nw.js/issues/3123#issuecomment-96393512]]></content>
      <categories>
        <category>Coder</category>
      </categories>
      <tags>
        <tag>Angular</tag>
        <tag>CQRS</tag>
        <tag>nw.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Stay Young Stay Simple | 全球首届蛤丝大会暨张宝华成都见面会]]></title>
    <url>%2F2016%2F01%2F13%2FStay-Young-Stay-Simple%2F</url>
    <content type="text"><![CDATA[张宝华，15年前，一个长者怒斥的香港女记者，现在已经是寰亚传媒集团高级副总裁。最近宝华姐第一次来内地参加活动，而且是和年轻人见面。 本来天气预报说今天有雨，结果宝华姐一来天气晴朗。 活动地点定在IFS内一家餐厅。 3点30分，会场的粉丝还不会太多。随着时间推移，粉丝越来越多，大家都开始拿出自己带来学习的书籍。 原定活动开始时间为4点。时间到了4点03分，宝华姐才姗姗来迟，只见宝华姐身着带黑框眼睛的黄色针织衫，出现在众人面前，众粉丝纷纷对在场的传媒记者表示： 将来在报道聚会时间上出现了偏差，你们是要负责的。 不知道这次的主讲座位安排，是否故意模仿16年前的那次采访。 宝华姐拿出了六本她的新书《失眠书店》，会面一开始就来了一次钦定：钦定在场年纪最大的一位长者和年纪图森破的一位少女，以及其他四位粉丝。分别签名并送出新书《失眠书店》。 当然了，在场要求宝华姐签名的还有其他书籍，宝华姐欣然接受。 宝华姐坦言: 16年过去了，她今天作为一名长者，要告诉我们一点人生经验。她绝对不知道她一个香港记者怎么到现在还被我们记得。 她说“长者”的威力真的很大。 当然还是需要介绍一点主办方，主办方以“你们继续，就不打扰你们交流了。”把话筒转给宝华。粉丝热情继续高涨： 你也实在不是谦虚，中央已经决定了，你来继续讲。 宝华姐说很多微博上面的朋友会私信她一些问题，例如问学业啦，爱情啦，有时候她也不懂怎么回答。只能说加油继续追，并且希望大家 stay young stay simple。 她说父母都是上海人，她全家都是很年轻的样子。她也不知道，她怎么就在香港出生了。粉丝问道: 你作为一个上海人怎么被选到香港去了？ 另一位粉丝回答： 中央已经决定了。 宝华笑谈: 他们的决定权也很重要。 宝华姐说除了学习提高姿势水平，运动也很重要。要跑得比谁都快，希望大家多跑步。粉丝当中有一个人问到底她跑得有多快。她也通过一些国内的学生知道了黄薄码，知道了之前的蛤三篇，知道了有人统计过她跑得到底有多快。有粉丝说，就不要跑步了，我们到重庆比赛爬山比赛拔河啊。 宝华姐随后问在场是否有外地来朋友，许多昆明南京来的朋友热情回应。继续问到在坐各位有哪些学校的，其中南京大学，和上海交大的同学引来粉丝热情欢呼。川大新闻系也是很大的。并且其中有人是学微电子的。 宝华姐也鼓励年轻人多恋爱，鼓励大家早恋。粉丝提问“是彭定康说的吗？”宝华姐回答“他没这么说，但他直接这么做的。”并且说希望大家多给她私信，她会尽量解决粉丝的问题。 通过宝华13年的脸书我们发现，宝华也是中学时候早恋的。她喜欢高高瘦瘦文采风流的男生，不知道是否这样的男生在微博上留言，她回复点赞概率更高？ 这时候现场粉丝提问了“16年前面对长者的心态是什么？” 宝华姐回答“当时年轻，只是尽到自己的责任，没有想太多。但是没想到现在还有这么多粉丝记得她。” 在场年纪最大的长者继续追问“如果继续做记者，那有没有勇气向当今领导人这样提问？” “我现在真的没有跑新闻了，如果继续跑新闻我也会尽责。而这个不是勇气，是责任。” 国内传媒人也对宝华有了提问，不过这位传媒人被硬点坐在了宝华姐的位置上。 “国内媒体成就感低，很多没法报道。你当初为什么选择媒体？” “有些事情是改变不了的，做自己能够做的，对未来要有希望。自己内心要强大，每个人的成长都会遇到这种事。例如我本来也不运动，可是后来也开始了跑步。不要灰心，每个人成长都会遇到这种事。”随后也对另一位传媒人表示，每个行业都有自己的困难和压力，应该找到自己的空间。 “那你会参选港姐吗？” “很惭愧，超龄了。” 当然有暴力的粉丝问宝华姐是否吃过蛤蟆？ 宝华姐坦言回答“没吃过，我是吃素的。而且吃素可能更容易保持年轻，stay young。”笔者提醒想要保养的女粉丝记得多吃素。并表达她信奉佛教，明天会去大慈寺和看熊猫。 也有粉丝问到每天被骚扰你会觉得困扰了？宝华姐回答其实是很荣幸的别人都没有，这是很特别的一件事。并希望大家不要提16年前的事情，因为这样大家会知道她年龄。如果她嫁出去无所谓，如果没嫁出，粉丝要负责的。 最后宝华姐总结了这次演讲的三句话： 多跑步，多拍拖，stay young stay simple。并祝愿粉丝姿势水平越来越高，相约天气暖和时候在成都和大家一起跑步。 北京时间17点04分，在场粉丝领唱《毕业歌》送给宝华姐，活动圆满结束。在场的粉丝今后都可以怒斥他人一个: 香港的张宝华，比你们不知道高到哪里去了，我和她谈笑风生。 总结：宝华姐亲自来到成都和蛤丝见面，现场蛤意盎然，蛤友们神魂颠倒，坐卧难安，大家都很 excited！ 很惭愧，就做了一次不完整的会议记录这么点微小的工作，谢谢大家。]]></content>
      <categories>
        <category>一颗赛艇</category>
      </categories>
      <tags>
        <tag>长者</tag>
        <tag>张宝华</tag>
        <tag>成都</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ffmpeg 使用指南]]></title>
    <url>%2F2016%2F01%2F07%2Fffmpeg-tutorial%2F</url>
    <content type="text"><![CDATA[本文档翻译自: https://ffmpeg.org/ffmpeg.html 中间加入了部分笔者的个人理解。有翻译生硬之处，难登“信、达、雅”之境界。望读者不吝指正。 语法1ffmpeg [global_options] &#123;[input_file_options] -i input_file&#125; ... &#123;[output_file_options] output_file&#125; ... 概述ffmpeg 是一个快速的音视频转换工具，它能在任意的采样率和视频大小之间转换并且获得高质量多态的过滤。 ffmpeg 根据 -i 选项读取任意数量的输入文件（普通文件、管道流、网络流、可抓取设备等等），将转换结果写入到指定的多个输出 文件。命令行参数中不能被解析为选项的所有参数都被视为一个输出文件名。 理论上讲，每个输入或输出文件都可以包含任意数量的多媒体流（视频、音频、字幕、附件及额外信息），但实际允许的多媒体流数量可能受限于转换格式。 通过 map 选项（参考流筛选章节）可自动地从某个输入文件的某个多媒体流映射到某个输出文件。 为了指定输入文件，你必须遵从从 0 开始的索引规律，第一个输入文件的索引为 0，第二个输入文件的索引为 1，以此类推。类似的，文件内的多媒体流也是从 0 开始计数，比如 2:3 指第三个输入文件的第四个多媒体流。 一般来说，参数选项都将应用于下一个文件。因此，命令行参数都顺序非常重要，你可以在命令行中多次使用同一个参数，将它用于不同的文件，每个参数都会应用于下一个输入或输出文件。除非是全局选项，它们必须在命令行中的最前面。 切勿混合使用输入和输出文件：首先指定输入文件选项，然后再指定输出文件选项。同样地，不要在不同文件间混合使用参数，所有的选项都只会应用于紧挨着它都下一个输入或输出文件。 将输出文件的比特率置为 64 kbit/s: 1ffmpeg -i input.avi -b:v 64k -bufsize 64k output.avi 强制输出文件的帧率为 24 fps: 1ffmpeg -i input.avi -r 24 output.avi 强制输入文件（仅限于原始格式）的帧率为 1 fps，输出文件的帧率为 24 fps: 1ffmpeg -r 1 -i input.m2v -r 24 output.avi 详细说明ffmpeg 的转码过程可以用如下图表示： 12345678910111213141516 _______ ______________| | | || input | demuxer | encoded data | decoder| file | ---------&gt; | packets | -----+|_______| |______________| | v _________ | | | decoded | | frames | |_________| ________ ______________ || | | | || output | &lt;-------- | encoded data | &lt;----+| file | muxer | packets | encoder|________| |______________| ffmpeg 调用 libavformat库来读取输入文件，从中获得压缩数据包，如果输入文件为多个，ffmpeg 尝试在每一个有效的输入流中将它们同步并记录最小时间戳。 然后，压缩数据包传递给相应的流解码器，输出原始的未压缩的数据流（原始视频或者 pcm 音频……），这些数据流经过过滤后传递给相应的编码器，对其进行编码、压缩，最后将压缩数据包写入到输出文件。 过滤在编码之前，ffmpeg 能通过 libavfilter库对原始音视频流进行过滤，多个过滤器构成了一幅过滤图，ffmpeg识别简单和复杂的两种过滤图。 简单过滤只有一种类型的输入和输出，如上图中，可在解码和编码之间插入一个简单过滤： 12345678910 _________ ______________| | | || decoded | | encoded data || frames |\ _ | packets ||_________| \ /||______________| \ __________ / simple _\|| | / encoder filtergraph | filtered |/ | frames | |__________| 简单过滤根据每一个流的过滤选项（-vf 和 -af）来配置，一个简单的视频过滤示例如下： 1234 _______ _____________ _______ ________| | | | | | | || input | ---&gt; | deinterlace | ---&gt; | scale | ---&gt; | output ||_______| |_____________| |_______| |________| 复杂过滤当输入或输出为多个，或者输入和输出文件的媒体流类型不同时，不能对流进行简单地进行线性过程处理，这个过程如下图： 12345678910111213141516 _________| || input 0 |\ __________|_________| \ | | \ _________ /| output 0 | \ | | / |__________| _________ \| complex | /| | | |/| input 1 |----&gt;| filter |\|_________| | | \ __________ /| graph | \ | | / | | \| output 1 | _________ / |_________| |__________|| | /| input 2 |/|_________| 通过 -filter_complex 全局选项指定，-lavfi 等同于 -filter_complex. 流拷贝流拷贝是提供给 -codec 选项的一种流筛选模式，它让 ffmpeg 跳过解码和编码步骤，因此它只有解复用步骤。流拷贝对于修改容器格式或容器级别的元数据是很实用的。 12345 _______ ______________ ________| | | | | || input | demuxer | encoded data | muxer | output || file | ---------&gt; | packets | -------&gt; | file ||_______| |______________| |________| 少了解码和编码步骤，拷贝过程是很快并且无损的。但是，受多种因素影响，在某些情况下它可能无法应用。流过滤因此也显然不可用，因为过滤必须工作于未压缩的原始数据上。 流筛选ffmpeg 默认只从输入文件中选择一个同种流媒体类型（音频、视频、字幕等），将它们包装到输出文件中。基于如下标准，它挑选出最 好 的那个流： 对于视频，它是最高分辨率的那个流； 对于音频，它是通道数最大的那个流； 对于字幕，它是第一个字幕流。 如果有多个同类型流都符合标准，那么选择索引最小的那个流。 你可以通过 -vn/-an/-sn 等选项移除默认筛选的这些流，若要人工控制选择哪些流，可用 -map选项。 参数选项所有数值选项，如果没有另外的规定，表示接受数字作为输入，其可以随后 SI单位 前缀之一的字符串，例如：K，M，或G。 如果i被附加在SI单位前缀，则完整的前缀将被解释为一个以 1024 （而非 1000 ）为基数的二进制倍数的单元前缀，将 B 附加到SI单位后缀将乘以 8。这允许使用，例如：“KB”，“MIB”，“G”和“B”为数字后缀。 选项不带参数的布尔选项，并设置相应的值设置为 true, 它们可以通过与no的前缀选项名称设置为 false。例如使用-nofoo将设置名称为foo为flalse的布尔选项。 流选择器有些选项适用于每个媒体流，比如 bitrat 和 codec。流选择器用于精确指定给定的选项适用于哪个流。 一个流选择器是一个字符串，它被追加到一个选项中并且用 :分隔，比如 -codec:a:1 ac3 包含流 a:1, 它匹配第二个音频流，因此，这个流选择器将在第二个音频流上采用 ac3编码器。 一个流选择器可以匹配多个流，因此选项将默认用于所有的流。比如 -b:a 128k将所有的音频流的比特率置为 128k。 一个空的流选择器匹配所有流，比如 -codec copy 或 -codec:copy 将拷贝所有的流。 流选择器的形式有： stream_index匹配中这个索引指代的流，比如，-threads:1 4将会把第二个流的线程数设置为 4. stream_type[:stream_index]stream_type可以是：v or V for video, afor audio, sfor subtitle, dfor data, and tfor attachments。v 匹配所有的视频流，V之匹配没有附加图片、视频缩略图或者封面的视频流。如果指定了stream_index，那么它指定该stream_index 索引对应的那个流，否则，它匹配该类型的所有流。 p:program_id[:stream_index]If stream_index is given, then it matches the stream with number stream_index in the program with the id program_id. Otherwise, it matches all streams in the program. stream_id or i:stream_idMatch the stream by stream id (e.g. PID in MPEG-TS container). m:key[:value]Matches streams with the metadata tag key having the specified value. If value is not given, matches streams that contain the given tag with any value. uMatches streams with usable configuration, the codec must be defined and the essential information such as video dimension or audio sample rate must be present.Note that in ffmpeg, matching by metadata will only work properly for input files. 时间戳格式1[-][HH:]MM:SS[.m...] 或者 1[-]S[.m...] 示例：55,12:03:45,23.189, 适用于 -t,-ss,-sseof,-t等选项。 常用选项 -f fmt (input/output) 强制输入/输出的媒体格式。一般情况下，ffmpeg 会自动从输入文件中识别出媒体格式，并且从输出文件名后缀猜测出输出格式，因此，大多数情况下，不需要此选项。 -y (global) 不提示，覆盖同名的输出文件。 -n (global) 不准覆盖输出文件，如果存在同名文件，则立即退出程序。 -c[:stream_specifier] codec (input/output,per-stream) -codec[:stream_specifier] codec (input/output,per-stream) ffmpeg -i INPUT -map 0 -c:v libx264 -c:a copy OUTPUT 将所有视频流以 libx264 编码并且拷贝所有的音频流。 对每个流，起作用的是最后一个-c选项。 ffmpeg -i INPUT -map 0 -c copy -c:v:1 libx264 -c:a:137 libvorbis OUTPUT 将拷贝所有的流，除了第二个视频流以 libx264 编码，第 138 个音频流以 libvorbis 编码。 -t duration (input/output) 当用于输入选项（-i 之前），限制从输入文件中最多读取的时长。 当用于输出选项（output_file 之前），当写入时长超过该时长时，将停止写入。 -to和-t不允许同时存在，-t优先。 -to position (output) 指定在何时停止写入，必须以 ffmpeg 允许的时间格式表示。 -ss position (input/output) 当用于输入选项时，定位到该文件的这个位置开始解码。 当用于输出选项时，解码当前位置前面的媒体但是忽略这些输入直到读取到该时间戳。 -sseof position (input/output) 和 -ss类似，但是相对于文件尾部而言，它是距离文件尾部的非正值，0 代表 EOF。 ffmpeg -sseof -00:06 -t 00:05 -i input output 将从距离 input 末尾 6 秒的地方开始，解码 5 秒。 视频选项 -vframes number (output) 指定输出多少视频帧，等同于-frames:v。 -r[:stream_specifier] fps (input/output,per-stream) 指定帧率 fps。 作为输入，忽略原有的时间戳并且用新生成的时间戳代替。 它和用于某些输入媒体的格式如 image2或v4l2 的 -framerate 选项不同，如有疑问，请用 -framerate代替-r选项。 作为输出，复制或丢弃某些帧以达到指定的帧率。 -s[:stream_specifier] size (input/output,per-stream) 指定帧尺寸， w*h 或 wxh。 -aspect[:stream_specifier] aspect (output,per-stream) 指定视频的显示宽高比，4:3, 16:9, 1.3333, 1.7777等。 -vn (output) 不输出视频内容 -vcodec codec (output) 指定视频编码器，等同于 -codec:v。 音频选项 -aframes number (output) 指定输出多少音频帧，等同于-frames:a。 -ar[:stream_specifier] freq (input/output,per-stream) 指定音频采样率。 -ac[:stream_specifier] channels (input/output,per-stream) 指定音频声道数。 -an (output) 不输出音频内容 -acodec codec (input/output) 设置音频编解码器，等同于 -codec:a . -sample_fmt[:stream_specifier] sample_fmt (output,per-stream) 指定音频采样格式。 高级选项 -map [-]input_file_id[:stream_specifier][,sync_file_id[:stream_specifier]] | [linklabel] (output) 指定一个或多个输入流作为输出源。 每个输入流根据输入文件索引、输入文件id和输入流索引来标示。所有的索引从 0 开始。第一个 -map选项确定输出流 0, 第二个 -map 选项确定输出流 1, 以此类推。 -符号表示不对该输入流进行映射。 示例： 将第一个输入文件的所有流映射至输出： ffmpeg -i INPUT -map 0 -f FORMAT output ffmpeg -i INPUT -map 0 output.mp4 假设你有一个输入文件，其中含有两个音频流，分别以0:0,0:1标示，只将第二个音频流输出： ffmpeg -i INPUT -map 0:1 out.wav 选取输入文件 a.mov中第三个输入流，标示为0:2 ，和输入文件 b.mov 中第 7 个输入，流标示为1:6 ，将它们拷贝到输出文件out.mov： ffmpeg -i a.mov -i b.mov -c copy -map 0:2 -map 1:6 out.mov 从输入文件中选中所有的视频流和第三个音频流： ffmpeg -i INPUT -map 0:v -map 0:a:2 OUTPUT 将所有流，除了第二个音频流，映射至输出： ffmpeg -i INPUT -map 0 -map -0:a:1 OUTPUT 音视频转换 视频 ==&gt; yuv ffmpeg -i 2.mp4 2.yuv ffmpeg -i input.mp4 -f rawvideo -vcodec rawvideo -pix_fmt yuv420p -s 1920x1080 -r 25 rawvideo.yuv yuv ==&gt; 视频 必须指定输入的 yuv 分辨率 -s ffmpeg -s 320x240 -i 2.yuv -c:v mpeg4 output.mp4 ffmpeg -f rawvideo -vcodec rawvideo -s 1920x1080 -r 25 -pix_fmt yuv420p -i inputfile.yuv -s 320x240 -c:v libx264 -qp 0 output.mp4 audio + yuv ==&gt; 视频 ffmpeg -i /tmp/a.wav -s 640x480 -i /tmp/a.yuv /tmp/a.mpg 音频转换 ffmpeg -i /tmp/a.wav -ar 22050 /tmp/a.mp2 通过映射流，将输入同时编码成多种格式到不同输出: ffmpeg -i /tmp/a.wav -map 0:a -b:a 64k /tmp/a.mp2 -map 0:a -b:a 128k /tmp/b.mp2 从视频中抽取图像 从 foo.avi 中每一秒抽取一张大小为 320x240 的图像到 foo-001.jpeg, foo-002.jpeg… ffmpeg -i foo.avi -r 1 -s 320x240 -f image2 foo-%03d.jpeg 如果只想抽取指定数量的图像帧，可搭配使用 -vframes`-t-ss`等选项。 根据图像序列生成视频 ffmpeg -f image2 -framerate 12 -i foo-%03d.jpeg -s 480x240 foo.avi 将多个 同类型 的输入媒体映射至输出 ffmpeg -i test1.avi -i test2.avi -map 1:1 -map 1:0 -map 0:1 -map 0:0 -c copy -y test12.nut 将 test1.avi 和 test2.avi 的音视频流逆序映射至 test12.nt 。（注意：这不是拼接视频，用 ffplay 播放的话，可以看出只播放了前面的 test.avi 部分） 从视频中生成 GIF ffmpeg -ss 00:10:00 -t 10 -i capx.mp4 -s 320x240 jilu.gif 拼接视频前提条件 视频图像尺寸一样 编码格式相同 protocol 支持文件级别拼接(MPEG-1, MPEG-2 PS, DV)，媒体类型必须一致。 ffmpeg -i &apos;concat:input1|input2&apos; -codec copy output 在 `OS X 10.11` 下 `ffmpeg 2.8.2` 用该方式拼接后，只有 `input1` 部分。 demuxer 推荐使用此方法 支持媒体流级别拼接，比 protocol 更灵活，可用于不同的媒体类型。 123456$ cat mylist.txtfile '/path/to/file1'file '/path/to/file2'file '/path/to/file3'$ ffmpeg -f concat -i mylist.txt -c copy output 编码格式不同 video filter适用于不同编码格式、不同媒体类型的文件拼接。 1ffmpeg -i opening.mkv -i episode.mkv -i ending.mkv -filter_complex '[0:0] [0:1] [1:0] [1:1] [2:0] [2:1] concat=n=3:v=1:a=1 [v] [a]' -map '[v]' -map '[a]' output.mkv 参考 https://ffmpeg.org/ffmpeg.html http://stackoverflow.com/questions/15778774/using-ffmpeg-to-losslessly-convert-yuv-to-another-format-for-editing-in-adobe-pr https://trac.ffmpeg.org/wiki/Concatenate]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>转码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[请按那个橙色键]]></title>
    <url>%2F2015%2F12%2F26%2Fplease-press-the-orange-key%2F</url>
    <content type="text"><![CDATA[12月25日，习近平在视察解放军报社时，通过军报微博微信平台，敲击键盘、发出了一条微博: 值此新年即将到来之际，我代表党中央、中央军委向全体解放军指战员、武警部队官兵和民兵预备役人员祝贺新年。希望大家践行强军目标，有效履行使命，为实现中国梦强军梦做出新的更大贡献！ 然而，细心的网友发现，习主席所操作的那台电脑的 Enter 键，被贴上了“微博发布”的橙色标签…… 这个”多此一举”的标注引起了不少网友对习大大电脑技术水平的怀疑，以及对下级无微不至的“贴心服务（回车键还要涂成全黄色，怕习主席找不到吗？）”的嘲笑。一时间，“赵王回车”火爆全网，庙堂与江湖齐欢。 更让人怀疑的是，所谓的“习主席键盘发微博”并不是指习主席本人 one by one 地用某狗输入法打出了这条消息，他只是负责在百忙中按下那个醒目的回车键而已。 要我说，这事活该，作秀要么来真的，像人家影帝就真哭，不行就干脆仪式化，没人觉得有问题，现在弄得不伦不类，贻笑天下。 小明还有两处疑问不解： “微博管理平台”不是新浪的吗？咋成军报技术团队自主研发的“微博管理平台”了？ “习主席敲击回车键，于16时13分把这条微博同时发布到4个平台。”，这么高端的“同时发布到4个平台”是如何实现的？ 小明供个方案：做个御用键盘，发微博专用，比金三胖的那个核按纽还牛哦。]]></content>
      <categories>
        <category>心旷神怡</category>
      </categories>
      <tags>
        <tag>赵王回车</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一曲动山河，熬碗鸡汤给你喝]]></title>
    <url>%2F2015%2F11%2F29%2FFade%2F</url>
    <content type="text"><![CDATA[《Fade》这首电音，没有一句歌词，却是辣么好听。 无论是运动、Party、车载，还是聚会，甚至一个人的时候都可以无限循环的神曲，蛤蛤，你值得拥有！ 有一天，小明开着车听这首歌，听完跪着开了20公里，被交警抓到，问他为什么跪着开车，他打开门让交警听一下，听完交警跪着给小明开了罚单。 《Fade》这首美到窒息的电音，旋律着实抓耳，恢弘大气而不失婉约，Alan 把他对生命热烈的赞美和青春流逝的叹息都注入这澎湃起伏的旋律中: 起初的一段曲调引人入胜，象征着少年得志，意气风发，对世间万物、人生百态充满了想象和希望……而后少年恣意地成长，他开始领略这世间的繁花簇锦，他开始在这滚滚红尘中打拼奋斗……看他在绚烂地绽放生命的花朵、看他在傲娇地挥洒青春热血……或高亢激昂，或低沉深吟，如同乐调一样，跌宕起伏，暂时的高峰接下来就是低谷，他还是不停的攀爬，背负起悲伤和痛苦，不断的前进……一路的各种经历使人颤栗，到最后沧桑巨变物是人非，他依然守住初心不变，笑看这潮起潮落云卷云舒…… 铿锵岁月融入到这一曲绚烂的青春舞曲中，这是一种既感慨生活的艰辛又无比热爱生活的人生哲学。 它，就好比《海阔天空》中的“原谅我这一生不羁放纵爱自由”它，就好比《蜗牛》中的“我要一步一步往上爬”它，就好比《相信自己》中的“超越极限超越自己”它，就好比《怒放的生命》中的“飞翔在辽阔天空，穿行在无边的旷野”它，就好比《最初的梦想》中的“最想要去的地方，怎么能在半路就放”它，就好比《阳光总在风雨后》中的“请相信有彩虹” 这排比句写的我连自己都感动了几百遍…… 4 分 24 秒，曲子播放完了。 来，干了这碗鸡汤： 生活虐我千百倍，我待生活如初恋。 我们又多了一首可以单曲循环的 《Fade》。 温馨提醒下：无论这首曲子多么好听，我都不建议你把它设为闹铃。]]></content>
      <categories>
        <category>心旷神怡</category>
      </categories>
      <tags>
        <tag>Fade</tag>
        <tag>鸡汤</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蓝色骨头]]></title>
    <url>%2F2015%2F10%2F31%2FThe-Blue-Bone%2F</url>
    <content type="text"><![CDATA[《蓝色骨头》是中国华语歌手崔健首次参与执导的一部文艺电影，由崔健亲自担任编剧。 “一首歌，两代人，三段故事，四种曲风”，这是崔健对《蓝色骨头》极为简练的介绍，后来，他又多透露了点内容，这部电影在他 2005 年制作专辑《给你一点颜色》时就已经成形. 电影讲述了一个地下摇滚歌手兼网络黑客的年轻男子钟华，勾搭了一个小歌手萌萌，但萌萌却是老板的情人……钟华父亲的一个邮包又牵出 wen ge（懂？）期间的一段凄婉故事…… 电影将分为三个篇章，《蓝色骨头》这首歌贯穿始终，观众将听到四种曲风的《蓝色骨头》。这首歌是崔健2005年专辑《给你一点颜色》的主打歌，也是他个人以摇滚的态度看人生的真实写照。 该片故事较为敏感，整体风格偏向文艺，对于部分观众有一定的吸引力。 2013年11月16日该片于第8届罗马国际电影节上首映并获得组委会特别提及奖 2014年10月17日正式在中国内地公映。]]></content>
      <categories>
        <category>心旷神怡</category>
      </categories>
      <tags>
        <tag>崔健</tag>
        <tag>文革</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一周墓碑记]]></title>
    <url>%2F2015%2F10%2F26%2Fno-see-for-a-week%2F</url>
    <content type="text"><![CDATA[小明这个星期干嘛去了？ 怎么一个礼拜没有更新了？ 后台收到不少粉丝的亲切问候，其中不乏不明真相的群众开始胡思乱想： 小明哥是不是被领导请去喝茶了？小明不会是在东莞被抓了吧，哎！怎么那么不小心呢？一日不见小明发牢骚，顿觉世界黑暗了许多……几日不见先生推送新文章，先生莫非有什么苦衷？先生有空还是写写吧。小黄你是不是被弟妹罚跪搓衣板了？你妈的到底什么时候更新啊？ 其实，是人家的公众号一不小心被微信后台屏蔽了，屏蔽周期：2015-10-19 至 2015-10-26。 为了证明你们敬爱的小明老师并不是因为在东莞被抓，也不是被老婆体罚，我还是晒一下后台的处罚记录吧，看看这华丽的、屡战屡败、屡败屡战、屡教不改的违规记录： 关注我微信公众号的朋友们可能发现，有部分推送出去的文章存活期不到一天有时甚至几小时就被后台以“违法”之名删除，究其原因大概是长者的文章发多了吧……说到这，让我们鄙视下文字狱。 我也真是奇了怪了，人家经营公众号不足三月，粉丝数可怜的尚未破千，难不成我的粉丝队伍不纯洁，其中居然埋伏有朝廷的鹰犬每日对我发的文章虎视眈眈：一看到“长者”就举报，一说政府坏话就举报，也不管其中内容为何，只问立场、不问是非，俨然文革再世，何其可怖？ 经过此次被封事件，小明总结了一下三点经验教训： 堡垒是从内部被攻破的，要保证革命队伍的纯洁性。兹决定审查粉丝名单，对那些地下特工嫌疑分子一律拉黑名单，宁可错杀三千（虽然我粉丝还没有那么多），绝不放过一人。 逐步提高笔杆子斗争的技术含量。指点尖山、激扬文字、粪土万户侯也是门技术活。有些话不能直说，要拐着弯说；有些人即使欠骂也不能图嘴舒服乱骂，要拐着弯儿不带脏字地骂；有些理念不能说得太直白，too simple，要用冷门专业词汇加西文翻译点缀之；有些句子不能说得太通顺，要主语谓语宾语状语补语和名词动词形容词糅合着用，不能被人一眼就看明白文章的真实寓意……以此为文，以期达到即使文章“被举报+后台漂亮MM来人工审查”，也无法看出文章的弦外之音。 劈开枪林弹雨，准确把握“反围剿”的最佳战期。以前发文章的时间大多为晚上9点多后，其实8点到凌晨这个时间段是公众号后台文章审核最严格的时间段，稍微检测到几个敏感词，就被告知”违反相关法律法规规定，发送失败……”，相比而言，审核最松懈的时间段为早上8点到10点。我曾经把某篇在前一晚死活发不出去的文章放到第二天早上9点左右发，结果一次就发送成功了。Surpried~]]></content>
      <categories>
        <category>一颗赛艇</category>
      </categories>
      <tags>
        <tag>微信</tag>
        <tag>屏蔽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[$watch vs ng-change]]></title>
    <url>%2F2015%2F10%2F25%2Fwatch-vs-ng-change%2F</url>
    <content type="text"><![CDATA[When something changesIn the olden days, before you used MVC frameworks such as Angular, you were probably used to doing stuff like this in jQuery: 12345function showNameChanged() &#123; // stuff...&#125;$('input.show-name').change(showNameChanged); This achieves the simple task of performing an operation whenever the user typed something inside an input, using JS change events. In Angular, though, most people would consider this code the equivalent: 12&lt;input type=text ng-model=show.name&gt;$scope.$watch('show.name', showNameChanged); Now, you might think I’m being nit picky here, but I’d usually rather write it like this: 1&lt;input type=text ng-model=show.name ng-change="showNameChanged()"&gt; ng-change?I’m always surprised that this directive is foreign for a lot of newcomers to Angular, and that $watch seems to be the tool everyone reach for first. ng-change is a simple directive that operates much like using jQuery to register a change event listener. In my opinion, this is the “real” equivalent of the first code sample we saw. The differences Using ng-change would call our showNameChanged() function only on actual changes to the input by the user. Watches, as you might know, are called in other cases too: right when they’re being defined the first time and on changes made to the value not by the user, e.g. programmatically. I’m a big believer in expressing intent when writing code (you do know The 4 Rules of Simple Design, right?). If my intent is to only listen to changes by the user, and I don’t expect the input to be changed programmatically, I would rather explicitly show that. Using $watch means whenever you read this code in the future you’ll have to consider whether it’s being triggered by something else, too. Another plus for intent for ng-change is that you can see from the template that this input is bound to something and how. Otherwise you’d need to start looking for the value in ng-model in the controller for usages. This way you can see right away who’s listening for these changes. Less code. And “less code == less things to debug”. As you can see above we didn’t need to add another line to the controller to listen for input changes. Using ng-change is a tiny bit more performant, since it uses one less watch expression. Since Angular knows it should only call the expression on change events it doesn’t need to keep evaluating it on every digest cycle, as opposed to, well, a watch. Yes, just this one doesn’t matter a lot, but across a big app these things stack up. Of course, sometimes $watch is what you want. But sometimes – it ain’t! References http://stackoverflow.com/questions/15112584/angularjs-using-scope-watch-and-scope-apply http://www.angularjs.cn/A0a6]]></content>
      <categories>
        <category>Coder</category>
      </categories>
      <tags>
        <tag>watch</tag>
        <tag>ng-chane</tag>
        <tag>angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OS X 上配置 Apache 虚拟主机]]></title>
    <url>%2F2015%2F10%2F14%2FOSX-Apache-VirtualHost%2F</url>
    <content type="text"><![CDATA[我使用的系统是 OS X Yosemite Version 10.10.5。 启动Apache打开 terminal，输入 sudo apachectl -v，如下显示 Apache 的版本： 1234hxz@Mac-mini:~$ sudo apachectl -vPassword:Server version: Apache/2.4.16 (Unix)Server built: Jul 22 2015 21:03:09 接着输入sudo apachectl start，这样 Apache 就启动了。打开浏览器地址栏输入 http://localhost，可以看到内容为It works!的页面。其位于/Library/WebServer/Documents/下，这是 Apache 的默认根目录。 设置虚拟主机 在终端运行 sudo vi /etc/apache2/httpd.conf，打开Apche的配置文件在 httpd.conf 中找到 #Include /private/etc/apache2/extra/httpd-vhosts.conf，去掉前面的＃，保存并退出。 运行sudo apachectl restart，重启 Apache 后就开启了虚拟主机配置功能。 运行sudo vi /etc/apache2/extra/httpd-vhosts.conf，配置虚拟主机了。该文件默认开启了两个作为例子的虚拟主机： 123456789101112131415&lt;VirtualHost *:80&gt; ServerAdmin webmaster@dummy-host.example.com DocumentRoot "/usr/docs/dummy-host.example.com" ServerName dummy-host.example.com ErrorLog "/private/var/log/apache2/dummy-host.example.com-error_log" CustomLog "/private/var/log/apache2/dummy-host.example.com-access_log" common&lt;/VirtualHost&gt; &lt;VirtualHost *:80&gt; ServerAdmin webmaster@dummy-host2.example.com DocumentRoot "/usr/docs/dummy-host2.example.com" ServerName dummy-host2.example.com ErrorLog "/private/var/log/apache2/dummy-host2.example.com-error_log" CustomLog "/private/var/log/apache2/dummy-host2.example.com-access_log" common&lt;/VirtualHost&gt; 而实际上，这两个虚拟主机是不存在的，在没有配置任何其他虚拟主机时，可能会导致访问 http://localhost 时出现如下提示： 12ForbiddenYou don't have permission to access /index.php on this server 最简单的办法就是在它们每行前面加上#，注释掉，这样既能参考又不导致其他问题。 增加如下配置:123456&lt;VirtualHost *:80&gt; alias /Upload "/Users/hxz/workspace/ng-flow-2.6.1/samples/Upload" &lt;Directory "/Users/hxz/workspace/ng-flow-2.6.1/samples/Upload"&gt; Require all granted &lt;/Directory&gt;&lt;/VirtualHost&gt; 上面这个虚拟配置的作用是：将 /Upload 的访问路径映射到 /Users/hxz/workspace/ng-flow-2.6.1/samples/Upload目录。 如果不确定自己添加的配置是否合法，可用 sudo apachectl -t 测试下，例如： 123hxz@Mac-mini:~$ sudo apachectl -tAH00526: Syntax error on line 36 of /private/etc/apache2/extra/httpd-vhosts.conf:Illegal option FollowSymLinkss 有个“坑”如果出现下面这种错误信息：1[Fri Oct 16 15:20:43.568523 2015] [authz_core:error] [pid 13293] [client ::1:49853] AH01630: client denied by server configuration: /Users/hxz/workspace/ng-flow-2.6.1/samples/Upload/ 可能原因：apache 2.4 版本和 2.2 以前的版本，配置上有些许改动。具体 fix 方法： 将 &lt;/Directory&gt; 下面的 12Order allow,denyAllow from all 修改为： 1Require all granted 参考 http://note.rpsh.net/posts/2013/11/27/osx-10-9-apache-server-php-mysql/ http://stackoverflow.com/questions/18739764/how-to-set-up-a-virtual-host-on-apache-2-4-4-mac-nix http://stackoverflow.com/questions/11215283/alias-403-forbidden-with-apache]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>OSX</tag>
        <tag>Apache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular HTML5 file upload]]></title>
    <url>%2F2015%2F10%2F12%2FAngular-HTML5-file-upload%2F</url>
    <content type="text"><![CDATA[A JavaScript + Angular.js library providing multiple simultaneous, stable, fault-tolerant and resumable/restartable file uploads via the HTML5 File API. features Multi file upload support Folder upload support(Chrome only) Darg &amp; Drop support Upload progress bar Cancelable uploads Pause/Resumable uploads Chunked uploads Cross-site uploads DemoYou can try it at:http://hxzqlh.com/Upload/ Files1234567891011121314151617181920212223├── README.md ├── chunk_temp_dir //chunked files will be uploaded here ├── index.html ├── js│ ├── angular.js │ ├── app.js│ ├── appController.js│ └── ng-flow-standalone.js├── src │ └── Flow│ ├── Autoloader.php│ ├── Basic.php│ ├── Config.php│ ├── ConfigInterface.php│ ├── File.php│ ├── FileLockException.php│ ├── FileOpenException.php│ ├── FustyRequest.php│ ├── Request.php│ ├── RequestInterface.php│ └── Uploader.php├── temp //uploaded files will be saved here└── upload.php How do I set it up with my server?Please read the How do I set it up with my server? section of https://github.com/flowjs/flow.js upload.php and src folder is a php implementation of server, you can rewrite to python or other languages. References flow.js ng-flow]]></content>
      <categories>
        <category>Coder</category>
      </categories>
      <tags>
        <tag>Angular</tag>
        <tag>upload</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[习大大中秋访美，阜博通迷情月宴]]></title>
    <url>%2F2015%2F09%2F25%2Fmiddle-autumn-in-Vobile%2F</url>
    <content type="text"><![CDATA[中秋将近，朋友圈又被刷屏，《人民日报》说：“中秋节不发月饼的领导不是好领导” 。这下好了，员工转给小领导看，小领导转给大领导看，大家各怀鬼胎，互相敲打，反正是《人民日报》的尚方宝剑，可不能说是我们没有政治觉悟和奉献精神了吧。 小明又在没出息地想，今年我大阜博通发不发中秋福利呢？ 我为什么会有这种想法呢，这是有根据的，端午节就冷冷地什么也没有呀？去年好歹有 100 呢（一个棒棒糖 + 两个咸鸭蛋）。 左顾右盼地观望了一个礼拜后，直到昨天，公司也没有半点要发的意思。这几天我下班回到家都要跟老婆唠叨下：“看来今年只能沦落到自己去买月饼吃咯……” 看那边在银行、国企工作的小伙伴们，在朋友圈晒： 左手一盒月饼、右手一桶油，挤上公车、挤下地铁，历尽千辛万苦哼哧哼哧拎回家，满头大汗中洋溢着沉甸甸的成就感。 心酸~咦？你一个大老爷们，怎么还出眼泪了？ 是在下输了，居然还在乎过节领导发不发月饼。 阜博通祝全体员工：中秋快乐 有好事者吟诗为证： 我司中秋花样多，月饼礼盒真不错。猜谜中奖送惊喜，男女老少都快活。]]></content>
      <categories>
        <category>心旷神怡</category>
      </categories>
      <tags>
        <tag>阜博通</tag>
        <tag>中秋</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件上传哪家强]]></title>
    <url>%2F2015%2F09%2F24%2Ffile-upload%2F</url>
    <content type="text"><![CDATA[金轮好法王最近的项目开发中，需要在网页应用中实现“文件上传”功能。 话说“文件上传”，是一个古老得不能再普通的问题，说简单也简单，但是要把它做到极致、完美，那就要考虑很多方面的问题，下面是我列举的几个功能及用户体验上的问题： 是否支持一次选择多个文件 是否支持添加文件夹 是否支持文件拖曳、粘贴版复制 是否支持暂停、恢复、取消上传 是否支持断点续传 是否有上传进度提示 多平台、多浏览器支持问题 服务端配合工作是否简单 本着 “90% 的问题，前人都已经有解决方案”的思路，加上我不想也暂时没有那个功力去“重复造轮子”，于是先上 Google 找“轮子”。 一钻进去，发现了另一片广阔的天地：得益于 HTML5 开发技术的流行，还真有不少做得很精致的文件上传库。 比如 jQuery File Upload 这个插件就可以轻松地实现方便灵活、用户友好的文件上传功能，它几乎完美地解决了跟文件上传相关的每一个问题。 下图是官方 Demo 的截图： 它强有多强多文件支持 允许一次选择多个文件或文件夹。 拖放支持 可以从您的桌面或文件管理器中拖放他们在您的浏览器窗口中上传文件。 上传进度条 显示一个进度条显示为单独的文件和所有上传组合上传进度。 可取消上传 单个文件上传可以取消来停止上传进度。 可恢复上传 中止的上传可以与浏览器支持的 Blob API 进行恢复。 分块上传 大文件可以上传较小的块与浏览器支持的 Blob 的 API 。 客户端图像大小调整 图像可以自动调整大小，显示缩略图。 预览 支持对图像、音频和视频文件的实时预览和播放。 没有浏览器插件要求 该实现是基于开放的标准，如 HTML5 和 JavaScript 的，不需要额外的浏览器插件（例如 Adobe 的 Flash ）。 跨站点的文件上传 支持上传文件到不同的域与跨站点的 XMLHttpRequest 或 iframe 重定向。 多个插件 允许在同一个网页上的使用多个插件实例。 可定制和可扩展 提供了一个 API 来设置各个选项，并定义回调方法的各种重载事件，能跟其他前端框架（比如 Angular）无缝衔接。 多重和文件内容流上传 文件可以被上传为标准的“多部分/窗体的数据”或文件内容流（ HTTP PUT 文件上传） 完备的浏览器支持 支持的桌面浏览器： Google Chrome Apple Safari 4.0+ Mozilla Firefox 3.0+ Opera 11.0+ Microsoft Internet Explorer 6.0+ 支持的手机浏览器： Apple Safari on iOS 6.0+ Google Chrome on iOS 6.0+ Google Chrome on Android 4.0+ Default Browser on Android 2.3+ Opera Mobile 12.0+ 兼容任何服务器端应用平台 适用于任何服务器端平台（PHP, Python, Ruby on Rails, Java, Node.js, Go etc.） ，支持标准的 HTML 表单文件上传。 Tutorial下载压缩包，解压到网站或者使用 npm、bower 等前端库管理工具就可打造跟官方 Demo 一样的客户端 + 服务端环境。 简单应用网页上需要一个 input 元素： 1&lt;input id="fileupload" type="file" name="file[]" multiple&gt; 需要加载的 js 文件有: jquey-1.11.3.min.js jquery-ui-widget.js jquery.iframe-transport.js jquery.fileupload.js 代码： 1234567891011121314151617181920212223242526&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;jQuery File Upload Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input id="fileupload" type="file" name="files[]" data-url="server/php/" multiple&gt;&lt;script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="js/vendor/jquery.ui.widget.js"&gt;&lt;/script&gt;&lt;script src="js/jquery.iframe-transport.js"&gt;&lt;/script&gt;&lt;script src="js/jquery.fileupload.js"&gt;&lt;/script&gt;&lt;script&gt;$(function () &#123; $('#fileupload').fileupload(&#123; dataType: 'json', done: function (e, data) &#123; $.each(data.result.files, function (index, file) &#123; $('&lt;p/&gt;').text(file.name).appendTo(document.body); &#125;); &#125; &#125;);&#125;);&lt;/script&gt;&lt;/body&gt; &lt;/html&gt; 这样就实现了一个基础版的文件上传功能。 显示进度条插件支持显示单个文件的上传进度 (progress) 显示和所有文件的总体上传进度(progressall) 显示： 123456789$('#fileupload').fileupload(&#123; progressall: function (e, data) &#123; var progress = parseInt(data.loaded / data.total * 100, 10); $('#progress .bar').css( 'width', progress + '%' ); &#125;&#125;); 需要一个容器用来显示进度条： 123&lt;div id="progress"&gt; &lt;div class="bar" style="width: 0%;"&gt;&lt;/div&gt;&lt;/div&gt; 给进度条显示不同颜色，可以通过 CSS 来设置： 1234.bar &#123; height: 18px; background: green;&#125; 显示上传的文件名你可以经常要将上传的文件显示到特定的元素上，这个可以通过 add 回调函数来实现： 12345678910$('#fileupload').fileupload(&#123; dataType: 'json', add: function (e, data) &#123; data.context = $('&lt;p/&gt;').text('Uploading...').appendTo(document.body); data.submit(); &#125;, done: function (e, data) &#123; data.context.text('Upload finished.'); &#125;&#125;); 点击开始上传在上例基础上，可以通过按钮点击事件来触发上传（上例是自动上传） 1234567891011121314$('#fileupload').fileupload(&#123; dataType: 'json', add: function (e, data) &#123; data.context = $('&lt;button/&gt;').text('Upload') .appendTo(document.body) .click(function () &#123; $(this).replaceWith($('&lt;p/&gt;').text('Uploading...')); data.submit(); &#125;); &#125;, done: function (e, data) &#123; data.context.text('Upload finished.'); &#125;&#125;); 参考 http://blog.csdn.net/violet_day/article/details/17231425]]></content>
      <categories>
        <category>Coder</category>
      </categories>
      <tags>
        <tag>upload</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lost and Found]]></title>
    <url>%2F2015%2F09%2F23%2FLost-and-Found%2F</url>
    <content type="text"><![CDATA[之前写过一篇 《那些相见恨晚的 Mac 使用技巧》（点击【阅读原文】），列举了几个实用的 Mac 小技巧。 上周，小明挤公交时，一不小心， iPhone 被小偷摸走了，为此，我曾怀着悲愤的心情怒诗一首（回复关键字【20150914】）。 今天给大家再分享一个冷门但很实用的 Mac 小技巧。 试想以下场景在一个阳光明媚的午后，你背着心爱的 MacBook 出门，准备再去星巴克体验一把一边喝卡布奇诺一边玩 Mac 的逼格，无奈，粗心的你，回来时不小心把小白 「遗落」 在出租车或者店里，说来也巧了，你的 Mac 本恰好被某位好心人捡到打算交还给你，Only to find 找不到你的联系方式，打开电脑发现有开机密码，全剧终。 好不容易遇到好心人，这最后的一线希望也要泡汤了。 并不是每个”好心人”捡到东西都会归还吧？解：不妨试试悬赏，酬谢，又做好事又有钱拿，何乐而不为呢。 更何况，电脑内的资料和隐私对于失主来讲，其价值往往远胜机器本身。 使用技巧通过设置「锁屏显示信息」，让笔记本在屏幕锁定时额外显示一段文字，如下图： 这段文字往往会是 Mac 失而复得的关键，它往往能在你百密一疏的时候带来一丝希望。 设置方法  - System Preferences - Security &amp; Privacy - General - Set Lock Message 作为一个细心体贴的好老湿，考虑到读者您不识 English 或者您的系统语言为中文，小明为你翻译下对应的中文语言版本：  - 设置 - 安全性与隐私 - 通用 - 设定锁定信息 当然我们也可以自由发挥，把它当做一个「公告牌」来用，在公共场所往往能游刃有余，看看下面的招式： 如果捡到本本，请联系 xxx ，必有重谢。主人去 WC 了，稍安勿躁。密码很好很强大，一般人破解不了，Enjoy!充电中，勿扰！美女请忽略这条提示……约吗？@hxzqlh 小结建议大家动手设置一下这个锁屏信息，如果不慎遗失了心爱的 Mac ，说不定会因此遇到好心人送回来，说不定会因此偶遇个帅哥美女，说不定……相信，还是好人多吧。]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《毛骗》| 中国最大农村石家庄的重大贡献]]></title>
    <url>%2F2015%2F09%2F22%2FMao-Fraud%2F</url>
    <content type="text"><![CDATA[世界上分为两种人：一种是喜欢看《毛骗》的，另一种是不知道《毛骗》的。 《毛骗》，这是一个难登大雅之堂的片名，它故在说骗，内里其实是讲人、说义、言信、传情。 9 月 10 日，断更 20 个月后，它索性带着终结篇回归。可喜的是，它没有步一般续集狗尾续貂之后尘，并且还带来了不少惊喜。历史、地理、古文、中医、物理、化学，引经据典，布局推理，一步一步，环环相扣，计中计中计，局中局中局，套中套中套，它把全剧最大的反转特色玩转得炉火纯青，令人拜服，看完全集我真是一个大写的服气！ 凡你所看到的，都不是真的；你所看到的反转，也未必都是真的；至于你所看到的反转的反转，呵呵，你猜……这就是传说中的「若见诸相非相，即见如来」吧。 《毛骗》第一季开播于 2010 年，五年来，对大多数的该剧粉丝来说，这是他们或美好或不美好的青春记忆。你可以从这停更的一年半来剧组人员微博下面的评论中，了解到这五年中粉丝们都经历了些什么。从高中到大学到毕业工作，从单身狗到谈恋爱到换的男（女）朋友十个指头都数不过来，从结婚到生子到离婚到二婚……大抵如此。 在大二时就与同学自组影视团队，拍摄网络短片和广告。而团队中每个人都身兼导演、编剧、摄像、剪辑多职，靠的仅仅是问同学借的小 DV，和满腔的热情，满腹的才华，满脑的创意。所以你在他们毕业后拍摄的《毛骗》第一季中，看到的是连现在的手机拍摄效果都不如的渣画质，以及简陋的道具，场景等。 李洪绸是这样形容的：「回想起我们一开始拍片那会儿，往往是一个导演，一个摄像，一个录音，几个演员就搞定一场戏。群演？无所谓，找身边的朋友，实在不行，现场现抓，再不行，录音上，演员举杆，录音出现过了？那摄像上，固定机位或者导演扛机；场景？无所谓，酒店用不了，用旅馆，再不行就日租房；光？能看清脸就行了，晚上的外景怎么办？哪里路灯多就上哪拍。我靠，有些地方的路灯十二点就灭了，改戏，改另一条街；道具？导演，你要的青花瓷的瓶子不好找啊，你看这个怎么样？导演：这太像痰盂了吧。道具：这就是痰盂。导演：……。众人：没事，拍吧，观众看不出来。」 这一切都掩盖不了李洪绸才华的展现，尤其是扎实的原创剧本，他是一个你给他资金他能还你奇迹的人。 在之后两季中随着投资的引入，画质道具场景剧情等全面升级，单集长度也逐渐逼近一部电影的长度。而这，正是这部剧的独特之处：你可以清楚地看到在这五年内，这群刚从河北传媒学院毕业不久的大学生是如何从当初青涩的演技、生硬的台词、简陋的硬件装备中一步步走到今天，从那个网剧始开垦的荒芜时代，一步步走到今天，最终将《毛骗》终结版这部两年磨一剑，无论从剧本、演员、表演角度，还是画面、声音、剪辑、音乐层面都堪称网剧甚至是国产剧良心之作，毫不夸张地说，随便拉个单集出来都碾压大多数院线电影。 不信？豆瓣评分可以说明一切： 感谢中国最大农村石家庄，这里，一个年轻的狠导，拍了一部至今我看过的最棒的国产剧。]]></content>
      <categories>
        <category>心旷神怡</category>
      </categories>
      <tags>
        <tag>毛骗</tag>
        <tag>李洪绸</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你的 Xcode 已签收，签收人：草签]]></title>
    <url>%2F2015%2F09%2F19%2Fxcode-bug%2F</url>
    <content type="text"><![CDATA[从昨天上午开始，关于 「XcodeGhost 病毒」的信息充斥了 IT 圈，一石激起千层浪，其火爆程度丝毫不亚于一颗炸弹扔进了粪坑，分量十足。 作为一个嗅觉灵敏的技术男，我也心安理得地放下手上正在码的代码，过去凑了会热闹。 又作为一个循循善诱育人不倦的好老师，小明先给技术盲普及下计算机基础知识： 你现在常用的电脑软件、手机 APP，都是由那群号称「技术改变世界」的程序猿编好代码（这个快乐而痛苦的过程俗称「码代码」，这群苦逼的程序猿俗称「码农」），然后用某款神通广大的编译器编译成可执行程序，然后打包、发布，最后你通过各种渠道下载对应的软件、APP 装到电脑或手机上执行。 下面再科普「病毒」和「漏洞」： 病毒，好比癌细胞，它会繁殖、感染，往一切可能被渗透的地方扩散，更要命的是，它还会自身复制，一生二，二生四，四生八，八方万物……「天下武功，为快不破」，病毒都是主动出击，寻找自己的肉鸡。软件要是中病毒了，如果放任不管，不但自身被吸血，最后变成行尸，还会连累跟你做邻居的其他软件。所以，为了所谓的安全，一般电脑上都要装安全防护软件，用大家都听得懂的人话来讲就是「杀毒软件」（Mac 用户请不要觉得惊讶） 漏洞，则是由于软件本身的 Bug 导致的，由于程序员也不是万能的，大脑也有缺氧短路的时候，谁能保证自己的代码百分百正确呢，一时的逻辑混乱就可能挖下一个巨大的坑，导致软件日后被人利用，这种就是「漏洞」。 自从软件诞生的那一天起，病毒、漏洞这对夺命双头鲨就和它相伴相随，不离不弃，弃而不舍，剪不断理还乱……没有一款软件胆敢号称终身无病毒无毒副作用，当然，也没有哪一种漏洞、病毒能号称能百发百中、侵之四海而皆准。 软件和病毒到底谁能干掉谁？这就涉及到各自「术」的能力高低了，两大阵营之间的斗争从上世纪四五十年代一直延续至今。这对冤家的关系好比「道」和「魔」： 道高一尺，魔高一丈，道挡不过马上穿金钟罩铁布衫护体，魔诡魅一笑放出三分归元气，道感觉到一阵强烈的地震波袭来，马上用降龙第十八掌降龙有悔回击，魔见正面久攻不进，改用暗器，刷刷刷，五枚冰魄银针射出，说时迟那时快，在距离眼睫毛只有 0.01 公分的一刹那…… 好吧，天亮了，梦醒了，别意淫了。 醒来继续说说今天的主题，什么是 XCodeGhost？ 9 月 17 日上午 9 点，著名的 iOS 开发工程师唐巧老师发了一篇微博： 在非官方渠道下载的 Xcode（苹果软件开发必备工具）居然自带病毒文件？！这种事小明老师还是第一次知道： 这个 XcodeGhost 病毒颇有创新意识，它不走传统病毒传播的老路，而是独辟蹊径，直接把病毒代码嵌入了开发工具源头，只要用了注入病毒的 Xcode 来开发软件，任凭你代码如何健壮，照样毒入真身。 造成的结果是，通过这些 Xcode 编译出来的 App 会被注入不知名的第三方代码，并且向一个陌生的可疑的非苹果官方网站： http://init.icloud-analysis.com 发送数据。 众所周知，由于车迟国互联网与世隔绝，车池国人民访问海外网站的速度只能用「你懂的」蜗速形容。有些程序员急于开发，就想偷懒从国内的某鸟类图标的下载软件搜索下载 Xcode，而木马作者，将他开发的带有木马的编译器发布到了各种平台上，提供种子，导致不明真相的程序员下载到了包含木马的版本，当然，其中有些人也大意得忘了去和官网的版本校验比对。 程序员号称智商一流，没想到啊没想到，在他们都完全不知情的情况下，乐呵呵地发布了包含木马的 APP，而苹果公司在审核过程中，居然也没有能检测出这些恶意代码，因此这些包含恶意代码的 APP 顺利登录了 Appstore，并被数百万甚至数千万用户下载…… 这个中招的名单非常恐怖，截止目前，包括但不限于这些 iPhone 上的 APP 均中枪： 网易云音乐 网易公开课 12306 移动端 中信银行动卡空间 下厨房 中国联通手机营业厅 高德地图 简书 豌豆荚开眼 滴滴打车 51卡保险箱 同花顺 细思恐极，后背发凉。 已经有各种技术宅通过代码逆向等方式（详见：http://drops.wooyun.org/news/8864）对该木马挖坟鞭尸，从目前来看，在 Xcode 中莫名加入的这段代码并没有什么恶意，只是收集一些 iPhone 和 APP 相关的时间、包名、应用名称、系统版本、语言、国家等部分数据，但是不得不防的是，未来很可能出现更加带有攻击性的病毒注入 Xcode，那么对于用户手机安全，这其中存在巨大的隐患。 在此，严重建议： 所有使用苹果手机的用户，请密切关注有关报道，尽快卸载公告名单中的软件，并跟踪乌云：http://drops.wooyun.org 或其他安全组织最新的公告寻求解决方案，安全起见，建议修改 Apple ID 及 iCloud 密码。]]></content>
  </entry>
  <entry>
    <title><![CDATA[偶遇一只尤物 nw.js]]></title>
    <url>%2F2015%2F09%2F16%2Fnw.js%2F</url>
    <content type="text"><![CDATA[Node-Webkit（现已正式改名为 NW.js），一个用 HTML5/CSS/Javascript 等 Web 技术来写跨平台桌面客户端应用程序的开源框架（跟移动终端上的 PhoneGap 等项目的原理类似），开发者只需写一份代码，就能编译出可同时跑在 Windows、Linux 和 Mac 上的桌面应用程序。 让我意外的是， Node-Webkit 项目的发起人居然是国人， Rogerwang，真名王文睿，英特尔开放源码技术中心（OTC）的软件架构师。最开始，node-webkit 只是他的一个业余项目，该项目从 2011 年开始，截至目前，在 GitHub 上已经有 24000 多个 Star，2600 多个 Fork。 从 nw.js 官网 可以看出，使用 Node-Webkit 开发的应用领域非常丰富，其中也不乏一些设计精良体验优美的软件。很大程度上，这得益于目前硬件的性能提升和 Web 技术的发展，动画、图形、音频、视频、2D、3D、WebGL 等等，都让基于 HTML5 的应用开发充满了想象力。 Node-Webkit 是通过 Node.js 和 WebKit 技术的融合，让开发者可以用 HTML5/CSS/Javascript 技术编写 UI，同时又能利用 Node.js 平台上众多 library 访问本地 OS 甚至跨域访问 ，最终达到用 Web 技术就可以编写桌面应用的目的。 具体实现的内部原理，作者这样解释道： 核心思想是把 Node.js 的消息循环（libuv）和 Chromium Renderer 进程的消息循环合并到一起，这样从 DOM（HTML）中可以直接调用 Node.js 提供的函数；把 Node.js 使用的 V8 引擎和 Chromium 的 V8 引擎合并，使得 Node.js 的 Javascript 和 DOM 里面的 Javascript 可以互相访问。 传统的桌面应用开发中，用户界面的复杂性一直是一个难题，而 node-webkit 方式可以降低很多用户界面开发的复杂性，将界面开发交给更加灵活、更加容易编写和调试的方式：HTML + CSS。 小试牛刀nw.js 框架下的开发流程是： 编写一个 HTML 页面（作为程序入口），然后在这个页面上引入额外的 CSS（界面风格）和 JavaScript（动作），然后将这些资源交给工业级浏览器内核 Webkit 来渲染 。 我们来通过一段最简单的 HelloWorld 程序，窥探一下 Node-webkit 的样子: 示例代码:下面一段简单的 HTML 文本，显示一个”Hello World!”的问候，它将是我们这个应用程序的入口。 123456789&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Sample App&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello World!&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 再新建一个配置文件：package.json 123456789101112&#123; "main": "index.html", "name": "sample-app", "description": "demo app of node-webkit", "version": "0.1.0", "window": &#123; "toolbar": false, "resizable": false, "width": 800, "height": 500 &#125;&#125; 该文件是 node-webkit 的应用描述文件，一个完整的 node-webkit 应用程序必须包含这样一个文件。它用于定义应用程序的基本信息以及运行相关的参数，比如名称、介绍、入口文件名称以及应用程序窗口的各项配置，如窗口的显示尺寸、显示位置、是否显示工具栏等等。 运行安装好 nw.js 后，nwjs 添加到系统的环境变量，只需在当前目录下运行 nw .命令，就会看到如下窗体： 上图是 Windows 平台下效果，再看 Mac OS X 平台下的效果： 以及 Linux 平台下的效果（请忽略虚拟机界面）： Look it，So easy~真正实现了一份代码适用各种平台。 从这个简单的实例可以看出： 页面运行在一个「桌面应用程序」中。没有地址栏，状态栏，菜单栏等，看起来更像是一个桌面应用。 用户界面开发的复杂性被「外包」给一个更简单的 Web 环境。这就是传说中的混合（hybrid）开发模式，比如现在移动开发中的 cordova 就是采用这种模式，使得本来被视为天堑的原生的用户界面开发变为坦途。 展望未来用 Web 技术来开发桌面应用，其实这条路老早就有人在走，比如： 跨平台+多终端毫无疑问，这货会成为桌面开发的神器。因为它具备了以下这些无可比拟的优势： 人力成本最低招一个会 C++ 的码农要花多少钱？招一个牛逼哄哄的既会 C++ 还对 QT、MFC 等了如指掌的码农又要花多少钱？对比一下，招一个会 JS + CSS 的呢？如果你是老板，你怎么想？再说了，市面上会 C++ 的码农更多，还是会 JS + CSS 的码农更多？无需小僧多言，其中的奥妙您自个儿体会。 APP 的体积更小列位一定还记得当年大明湖畔的疼讯 QQ 只有十几 M 的体积，俗话说，岁月是把杀猪刀，在集成了疼讯的各种应用之后，如今的 QQ 身材早已发福走形。可以想象，如果 QQ 不使用嵌入浏览器内核的方式，恐怕体积早就超过 100M 了吧！ 不需要整体更新 APP如果是按照传统的方式开发桌面应用，每次升级的时候都需要用户重新下载整个应用，比如疼讯 QQ。但是用 node-webkit 的这种方式，可以很好地避免这个问题，就像网站一样，网站内容可以不断更新，但是浏览器本身的更新不需要那么频繁。 跨平台不多说了，显而易见的优势。 多终端由于 node.js 和 chromium 本身都是可以在桌面平台和移动平台上运行的，因此用这货来支持多终端开发，保持技术栈的一致性是非常合适的。 完善的工具链由于 node.js 的兴起，它下面的 npm 模块数量已经有几十万个；而各种基于chrome 内核的定制版浏览器就不用再介绍了。加上传统 B/S 开发模式下已经具备的完整开发和设计工具，用 node-webkit 来开发桌面应用已经具备了完善的工具链。 总结node-webkit 很大程度上简化了桌面程序的开发，为 Web 前端以及桌面客户端的开发人员提供了一个新的舞台。 就是啊，这货 2011 年就出来了，我们去年还在殚精竭虑地搞 web client，想想真是欲哭无泪 ~ 最近，我司因战略发展需要，亟需给客户研发出一款「跨平台、易扩展」的客户端软件，刚好在这个时机，乔帮主地下显灵，让我捡到了 nw.js 这只尤物，好巧啊，怎么会这么巧呢，要我说啊，这事真是活活给巧死了……呜呼~这下又有事做了……]]></content>
      <categories>
        <category>Coder</category>
      </categories>
      <tags>
        <tag>nw.js</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iPhone 6 Plus 丢了，怒诗一首]]></title>
    <url>%2F2015%2F09%2F14%2FiPhone6-Plus-lost%2F</url>
    <content type="text"><![CDATA[今天傍晚下班路上 熟悉的 37 路公交车 我的 iPhone 6 Plus 不慎遗失 打电话过去 宁波的号码已关机 是真的丢了 是真的被偷了 世界突然静下来 手足无措的荒草爬满心坎 我试着腾空一切 让自己做一个思想者 一不小心的悔恨 不可名状的紧迫感 成为被派来的说客 堵塞了心口 我第一次这样刻骨铭心地纪念 这一串代表我个人的数字 但一遍一遍打不出亲 也骂不出爱 家中领导怒上红颜 抓我几个红手印 亏老娘省吃俭用一个月 你就是没有用爱疯的命 最后问题来了 手机防盗哪家强 小心为上 只能骂娘]]></content>
      <categories>
        <category>心旷神怡</category>
      </categories>
      <tags>
        <tag>iPhone</tag>
        <tag>小偷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一部看完后你会自觉把裤子穿好的香艳大片]]></title>
    <url>%2F2015%2F09%2F13%2FThe-Treacherous%2F</url>
    <content type="text"><![CDATA[前不久，韩国上映了一部很不错的情色片《奸臣》（想看的朋友，回复关键字【奸臣】，推送百度云影片链接），今天，本着艺术鉴赏的初衷，我来小叙一下关于韩国情色片的那些事儿。 虽然「情色片」和「色情片」本质都是：「废纸」， 但「情色片偏重艺术，色情片偏重技术」，还是一语道破了二者的区别，而将这一区别展现得淋漓尽致的，在东亚三雄中，非韩国的情色片莫属。 岛国的成人片多半是剧情简单、直奔主题，男主角丑爆、女的一上来就雅玛碟，来也匆匆，去也匆匆，偶尔泄欲看上一两部还可以，欣赏就谈不上了。 中国香港的情色片，往往取材并乱改于古典文学名著，过度夸张、极度意淫、品质低劣，缺乏上乘之作。即便有，手段也并不高明，比如展现女性美好胴体，港片一般只有「洗浴」和「艳舞」两招。说到重头戏男欢女爱，则更是草草而成，布景简单、动作夸张并且千篇一律，有时甚至加进些低俗笑料，哪有半点唯美情境可言？ 韩国的情色电影，因为社会体制的关系，没有发展成日本的 AV 影片，又不像中国电影在表现情欲方面束手束脚，因而打出了一片独特的天地…… 如果要用一两个词来概括韩国情色片的话，「唯美、精致」应该是最好的形容。韩国情色片在营造男女的情爱气氛上下足功夫，对音乐、灯光、布景、颜色都极有考究，那精雕细刻出的优美画面与片中唯美激情的氛围契合得天衣无缝。观之足以让人于心神激荡、心旷神怡：「男女的床第之欢被拍到如此境界，还真不好说是卖弄色情了」。 细论《奸臣》这部情色片依然保持了韩国电影制作精良、剧情考究的优良传统。 从成色上看，丝毫不逊于中国的张艺谋大胸片《满城尽带黄金甲》。哗啦啦，满屏满屏的华服丽人酥胸美腿，香艳、妖艳、美艳，美的让人痴迷，艳得让人口水直流。有图为证： 在剧情上，为了表现淫乱暴政，影片充斥了大量大胆犀利的情色桥段，比如昏庸的燕山王一边让女人口活之一边射杀女人父亲一段，尺度之大，简直是叹为观止。 但，《奸臣》并没有沦为简单的泄欲型影片，非但如此，还拍出了民族大义的高度：它不仅是脱裤子的事情，而是提起裤子，去思考这个民族的走向问题。 在主题上，《奸臣》其实是情色片的面子，伦理片的里子。看到最后，有一股说不清道不明的孤独、哀怨、痛惜的感觉，它是在思考：「这个民族何以沦入如此昏庸溃烂？」，更是疾吁：「这个民族不能重蹈覆辙！」 影片为什么叫《奸臣》？其实影片所谓的「奸臣」并不单单指任崇载任士洪父子，在那样的暴政时期，每个人都是「奸臣」，每个「忠臣」都会为了自己想要的利益去做「奸臣」，所谓的「忠臣」和「奸臣」根本没办法分的清楚，而君王也只不过是他们手中的一个傀儡而已。 究竟是先有昏君，还是先有奸臣？是昏君毁了忠臣的效忠之心，还是奸臣毁了明君的王道之志？ 电影没有给出答案，将问题抛给了观众。 这句台词，引人深思： 你把我当成傻瓜吗？你认为让朕成为昏君的是谁？王犯错时，臣子是该拼命谏言还是豁出性命来顺从？朕所作所为暗合敌人之意，你都不为之担忧，你就是奸臣！用一件血衣蒙蔽君主眼睛、毁了国家，你就是亡国之臣！朕的朝廷里没有忠臣，只有忠犬而已。]]></content>
  </entry>
  <entry>
    <title><![CDATA[你中有我，我中有你。]]></title>
    <url>%2F2015%2F09%2F12%2Fyou-and-me%2F</url>
    <content type="text"><![CDATA[今天分享下最近学习到的：在 Mac OS X 平台上，实现 Javascript 与 Objective-C 两种编程语言的交互机制。 你侬我侬，忒煞情多。情多处热如火。把一块泥，捻一个你，塑一个我，将咱两个，一齐打破，用水调和，再捻一个你，再塑一个我。我泥中有你，你泥中有我，与你生同一个衾（qin），死同一个椁（guo）。 背景现在很多视频或者音乐的客户端，比如 QQ Music For Mac。往往通过在客户端嵌入网页的方式来展现内容，并通过 Javascript 调用客户端的一些功能，比如下载视频或者播放音乐等。 嵌入网页基本都是采用 WebView 控件来展示网页，这时客户端好像内嵌了一个微型的浏览器。 用嵌入网页的方式，好处是显然的： 网页可以轻易做出很炫丽的效果，当然客户端通过艰难的自绘也可以做出很华丽的效果，但开发时间跟开发难度跟网页比起来没得比。 网页可以随时更改，更改后可以实时更新到你发出去的每一个客户端版本，这种扩展性在实战中是很重要的。 Javascript 与 Objective-C 双方是对等的，也就是 JS 可以调用 OC，反过来 OC 也可以调用 JS。 Demo 官方例子： CallJS ，详细了介绍上面所述的所有技术细节。 你也可以在 GitHub 上直接下载我写的这个 Demo：JS-OC-Communicate-Tutorial 技术细节类型转换从 Demo 中可以看出，在 OC 与 JS 通信时，变量的类型会自动进行转换，基本类型都会自动转换，如 JS 中的 number、boolean 都会转换成 OC 中的 NSNumber 类型，而 String 类型会自动转换成 NSString 类型，JS 中的对象会转换成 WebScriptObject 对象，而相关的属性信息可以通过 Key-Value 的方法读取和写入。 OC 调用 JS：1、OC 执行一段 JS 代码，使用下面的函数： - (NSString *)stringByEvaluatingJavaScriptFromString:(NSString *)script; 2、OC 调用 html 页面里面的 JS 函数 比如 js 端有一个函数 JSFunction： function JSFunction(parameter) { //显示OC返回的值 document.getElementById(&apos;view&apos;).value = parameter; //返回成功的消息 var result = {&apos;message&apos;:&apos;Web page has received msg！&apos;}; return result; } OC 端可以用下面的方法来调用： - (IBAction)doAction:(id)sender { //设置对象 WebScriptObject *result = [[self.webView windowScriptObject] callWebScriptMethod:@&quot;JSFunction&quot; withArguments:@[self.textField.stringValue]]; NSString *message = [result valueForKey:@&quot;message&quot;]; } JS 调用 OC:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/* 当页面加载完成，将要执行JS之前，didClearWindowObject 消息将会发送给 webview 的frameLoadDelegate。我们可以在这个最完美的时机里，设置一个属于我们自己的JS对象 */- (void)webView:(WebView *)sender didClearWindowObject:(WebScriptObject *)windowObject forFrame:(WebFrame *)frame&#123; /*将当前对象加到JS里面的window全局对象里面，并命名为native。 之后可以在JS通过使用native变量来使用当前的对象 */ [windowObject setValue:self forKey:@"native"];&#125;/* 返回是否阻止响应该方法, 返回NO即能响应该方法 */+ (BOOL)isSelectorExcludedFromWebScript:(SEL)selector&#123; if (selector == @selector(status:)) &#123; return NO; &#125; return YES;&#125;/* 返回本地方法在JS中的名称 */+ (NSString *)webScriptNameForSelector:(SEL)sel&#123; if (sel == @selector(status:)) &#123; return @"ocMethod"; &#125; return nil;&#125;/* 返回是否阻止获取该属性, 返回NO即能获取该属性*/+ (BOOL)isKeyExcludedFromWebScript:(const char *)property&#123; if (strcmp(property, "sharedValue") == 0) &#123; return NO; &#125; return YES;&#125;/* 返回本地属性在JS中的名称*/+ (NSString *)webScriptNameForKey:(const char *)name&#123; if (strcmp(name, "sharedValue")) &#123; return @"oc_sharedValue"; &#125; return nil;&#125; JS 中代码如下： 12345678910111213function CallNative()&#123; if (native) &#123; //将当前显示的文本组装成对象发给OC var consoleValue = document.getElementById('view').value; var parameter = &#123;'message':consoleValue&#125;; var result = native.ocMethod(parameter); //显示OC返回的结果 document.getElementById('view').value = result['message']; &#125;&#125; 总结利用 Javascript 与 Objective-C 的通信机制，可以通过 HTML、Javascript、CSS 等 Web 技术实现炫丽的 UI ，而通过原生 API 实现与本地相关的操作。这对于 OSX 平台上的桌面客户端开发者而言是大大的福音。 参考 http://blog.csdn.net/pjk1129/article/details/6936545]]></content>
      <categories>
        <category>Coder</category>
      </categories>
      <tags>
        <tag>Object-C</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手把手教你开发浏览器]]></title>
    <url>%2F2015%2F09%2F11%2Fmake-a-browser%2F</url>
    <content type="text"><![CDATA[浏览器大家都不陌生，想要上网，就不得不用到浏览器。 国内网民计算机上常见的网页浏览器有，QQ 浏览器、Internet Explorer、Firefox、Safari，Opera、Google Chrome、百度浏览器、搜狗浏览器、猎豹浏览器、360 浏览器、UC 浏览器、傲游浏览器、世界之窗浏览器等。 Safari 浏览器、Opera 浏览器、谷歌浏览器用的都是 WebKit 引擎，其他浏览器引擎还有 Gecko（Mozilla Firefox 等使用）和 Trident（也称 MSHTML，IE 使用） 什么是 WebKit？WebKit 是开源的 Web 浏览器引擎，它就像一个黑盒，我们把 HTML、CSS、JS 和其他一大堆东西丢进去，然后 WebKit 魔法般的以某种方式把一个看起来不错的网页展现给我们。 WebKit 内核在手机上的应用也十分广泛，例如 Android、iPhone、Nokia’s 60 系列的手机浏览器所使用的内核引擎，都是基于 WebKit。 一个浏览器的诞生既然是开发浏览器，很重要的一点就是如何展示浏览器界面，WebView 控件是 OS X 平台上负责展现 Web 内容、实现和用户交互的核心控件，相比 IOS 平台上同类型的 UIWebView，它功能更强大（先挖个坑，以后有机会再介绍手机浏览器上的 UIWebView）。 下面用一个 Demo（源码：https://github.com/hxzqlh/WebView-Tutorial）来说明一下 WebView 主要的 api 接口, 最终效果如下图所示： 该 Demo 实现的是一个微型浏览器，包含了基本的前进、后退、刷新、回车访问 url，点击 Go 按钮访问 url，在标题栏显示网站的标题等功能。 实现过程：一、首先要引入 WebKit.framework。 #import &lt;WebKit/WebKit.h&gt; 二、从 Library 面板拉一个 WebView 控件，在程序创建该 WebView 控件的object，比如名字为 webView，并通过 IBOutlet 关联起来。通过发送下面的消息让 WebView 控件加载一个网页。 [[webView mainFrame] loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;www.google.com&quot;]]; 至此，WebView 控件就可以展示网页了。也就是说只要一行代码就可以简单实现一个浏览器展示页面的功能。 三、跟踪 WebView 整个 loading 的过程，用到 WebFrameLoadDelegate。 1.加载过程： 在访问一个网页的的整个过程，包括开始加载、加载标题、加载结束等。webkit 都会发送相应的消息给 WebFrameLoadDelegate 。 webView:didStartProvisionalLoadForFrame:—开始加载，我们可以在这里获取加载的 url，并展示出来 webView:didReceiveTitle:forFrame:—获取到网页标题 webView:didFinishLoadForFrame:—加载完成，我们可以在这里设置前进后退按钮的状态 2.错误的处理： 加载的过程当中，有可能会发生错误。错误的消息也会发送给WebFrameLoadDelegate。我们可以在这两个函数里面对错误信息进行处理 webView:didFailProvisionalLoadWithError:forFrame: 这个错误发生在请求数据之前，最常见是发生在无效的URL或者网络断开无法发送请求 webView:didFailLoadWithError:forFrame: 这个错误发生在请求数据之后 3.显示 loading 状态： 网页只有在加载完成后，才会被展示出来。加载过程如果很久的话，会一片空白然后才出来网页。为了让我们的网页更加人性化，可以在webView:didStartProvisionalLoadForFrame: 加一些 loading 的状态 四、处理加载策略，用到 WebPolicyDelegate 在 safari 浏览器，对于网页里面有 target=_blank 的链接，默认行为是点击后会弹出新的标签窗口。 如果在我们的 webView 控件里面点击此类链接的时候，会触发该消息并会发送给 WebPolicyDelegate，然后我们可以在这里控制对该事件的处理。比如我们可以使用我们自定义的控件打开该url。 12345678910//网页里面target=_blank的链接，在这里捕获，并在这里控制对该事件的处理。- (void)webView:(WebView *)sender decidePolicyForNewWindowAction:(NSDictionary *)actionInformation request:(NSURLRequest *)request newFrameName:(NSString *)frameName decisionListener:(id &lt; WebPolicyDecisionListener &gt;)listener&#123; NSURL *URL = [request URL]; //在当前窗口打开 [[webView mainFrame] loadRequest:[NSURLRequest requestWithURL:URL]]; //也可以用默认浏览器打开 //[[NSWorkspace sharedWorkspace] openURL:URL]; //或者也可以加代码，新建一个tab打开&#125; 前进，后退，刷新等按钮的事件，可以直接绑定到 WebView 控件的 goForward、goBack、reload 事件，而不需要我们自己写事件去处理。 主要代码：12345678910111213141516171819202122232425//// AppDelegate.h// WebView-Tutorial//// Created by hxz on 9/9/15.// Copyright (c) 2015 vobile. All rights reserved.//#import &lt;Cocoa/Cocoa.h&gt;#import &lt;WebKit/WebKit.h&gt;@interface AppDelegate : NSObject &lt;NSApplicationDelegate&gt;@property (weak) IBOutlet NSWindow *window;@property (weak) IBOutlet WebView *webView;@property (weak) IBOutlet NSButton *btnGoBack;@property (weak) IBOutlet NSButton *btnGoForward;@property (weak) IBOutlet NSButton *btnReload;@property (weak) IBOutlet NSTextField *navBar;@property (weak) IBOutlet NSButton *btnGo;- (IBAction)clickGo:(id)sender;- (IBAction)enterTogo:(id)sender;@end 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111//// AppDelegate.m// WebView-Tutorial//// Created by hxz on 9/9/15.// Copyright (c) 2015 vobile. All rights reserved.//#import "AppDelegate.h"@implementation AppDelegate@synthesize btnGoBack;@synthesize btnGoForward;@synthesize btnReload;@synthesize navBar;@synthesize webView;- (void)applicationDidFinishLaunching:(NSNotification *)aNotification &#123; // Insert code here to initialize your application&#125;- (void)applicationWillTerminate:(NSNotification *)aNotification &#123; // Insert code here to tear down your application&#125;- (void) awakeFromNib &#123; //设置delegate [webView setFrameLoadDelegate:self]; [webView setPolicyDelegate:self]; [[webView preferences] setPlugInsEnabled:YES]; [navBar setStringValue:@"http://www.baidu.com"]; [self onGo];&#125;//加载网站- (void)onGo&#123; NSString *urlString = [navBar stringValue]; if(![urlString hasPrefix:@"http://"])&#123; urlString = [NSString stringWithFormat:@"http://%@",urlString]; &#125; NSLog(@"onGo url:%@",urlString); [[webView mainFrame] loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:urlString]]];&#125;- (IBAction)clickGo:(id)sender&#123; [self onGo];&#125;//回车访问网站- (IBAction)enterTogo:(id)sender&#123; [self onGo];&#125;//开始加载,可以在这里加loading- (void)webView:(WebView *)sender didStartProvisionalLoadForFrame:(WebFrame *)frame&#123; NSString * currentURL = [webView mainFrameURL]; [navBar setStringValue:currentURL]; NSLog(@"webview url:%@",currentURL);&#125;//收到标题，把标题展示到窗口上面- (void)webView:(WebView *)sender didReceiveTitle:(NSString *)title forFrame:(WebFrame *)frame&#123; NSLog(@"receive title:%@",title); // Report feedback only for the main frame. if (frame == [sender mainFrame])&#123; [[sender window] setTitle:title]; &#125;&#125;//加载完成- (void)webView:(WebView *)sender didFinishLoadForFrame:(WebFrame *)frame&#123; //设置前进，后退按钮的状态 if (frame == [sender mainFrame])&#123; [btnGoBack setEnabled:[sender canGoBack]]; [btnGoForward setEnabled:[sender canGoForward]]; &#125;&#125;//错误处理:如无效的URL或者网络断开无法发送请求- (void)webView:(WebView *)sender didFailProvisionalLoadWithError:(NSError *)error forFrame:(WebFrame *)frame&#123; &#125;//错误处理- (void)webView:(WebView *)sender didFailLoadWithError:(NSError *)error forFrame:(WebFrame *)frame&#123; &#125;//网页里面target=_blank的链接，在这里捕获，并在这里控制对该事件的处理。- (void)webView:(WebView *)sender decidePolicyForNewWindowAction:(NSDictionary *)actionInformation request:(NSURLRequest *)request newFrameName:(NSString *)frameName decisionListener:(id &lt; WebPolicyDecisionListener &gt;)listener&#123; NSURL *URL = [request URL]; //在当前窗口打开 [[webView mainFrame] loadRequest:[NSURLRequest requestWithURL:URL]]; //也可以用默认浏览器打开 //[[NSWorkspace sharedWorkspace] openURL:URL]; //或者也可以加代码，新建一个tab打开&#125;@end]]></content>
      <categories>
        <category>Coder</category>
      </categories>
      <tags>
        <tag>WebView</tag>
        <tag>Object-C</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
</search>
